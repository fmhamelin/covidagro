{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Bienvenue ! Ce site rassemble des ressources p\u00e9dagogiques li\u00e9es \u00e0 la mod\u00e9lisation de l'\u00e9pid\u00e9mie de COVID-19 en France, r\u00e9alis\u00e9es par et pour les \u00e9l\u00e8ves ing\u00e9nieurs agronomes de L'institut Agro de Rennes, non sans apports des \u00e9tudiants du Master MODE (Mod\u00e9lisation en \u00e9cologie), qui est \u00e9galement une Sp\u00e9cialisation du cursus ing\u00e9nieur. Il s'agit d'exercices \u00e0 vis\u00e9e strictement p\u00e9dagogique. La critique des mod\u00e8les fait partie de l'exercice. Les donn\u00e9es proviennent de data.gouv.fr . Commentaires bienvenus : merci d'\u00e9crire \u00e0 Fr\u00e9d\u00e9ric Hamelin (frederic.hamelin@agrocampus-ouest.fr). Derni\u00e8re mise \u00e0 jour : le 20/05/2021. Travaux dirig\u00e9s en ligne Les TD sont propos\u00e9s en langage R . Introduction \u00e0 la mod\u00e9lisation en \u00e9pid\u00e9miologie : COVID-19 1\u00e8re flamb\u00e9e TD1 : croissance exponentielle des d\u00e9c\u00e8s TD2 : estimation du taux de l\u00e9talit\u00e9 sur la base des donn\u00e9es de tests et de d\u00e9c\u00e8s 1er confinement TD3 : dynamique \u00e9pid\u00e9mique sur la base des donn\u00e9es d'hospitalisations TD4 : dynamique \u00e9pid\u00e9mique sur la base des donn\u00e9es de tests et de d\u00e9c\u00e8s 2\u00e8me flamb\u00e9e TD5 : dynamique \u00e9pid\u00e9mique sur la base des donn\u00e9es de tests et de d\u00e9c\u00e8s L'appli COVID-19 pr\u00e9sente un ajustement sur la base des donn\u00e9es d'hospitalisations 2\u00e8me confinement TD6 : dynamique \u00e9pid\u00e9mique sur la base des donn\u00e9es de tests, de d\u00e9c\u00e8s, et d'hospitalisations Applications interactives Les applis sont r\u00e9alis\u00e9es avec Shiny . COVID-19 Cette appli permet de visualiser l'\u00e9volution des hospitalisations et des admissions des malades, d'ajuster un mod\u00e8le simple (cf. section \" information on the model \", onglet \"model\") et de r\u00e9aliser des projections. Dans la section \" information on the model \", l'onglet \" Fitting example \" donne un exemple d'ajustement de la dynamique \u00e9pid\u00e9mique durant la 2\u00e8me flamb\u00e9e, sur la base des donn\u00e9es d'hospitalisations. Appli r\u00e9alis\u00e9e par Maimouna Diarra (\u00e9l\u00e8ve ing\u00e9nieure agronome) dans le cadre d'un stage de S7 en d\u00e9cembre 2020/janvier 2021. CovidContact Cette appli propose un mod\u00e8le structur\u00e9 en \u00e2ge pour mod\u00e9liser la dynamique pendant et apr\u00e8s le 1er confinement, et tester des sc\u00e9narios de d\u00e9confinement. Le mod\u00e8le est pr\u00e9sent\u00e9 sur la page suivante : Transmission du coronavirus confinement/post-confinement et impact des mesures de distanciation sociale . Un exemple de sorties est propos\u00e9 dans la section \"Ajustement du mod\u00e8le\" puis \"Repr\u00e9sentations graphiques\". Appli cr\u00e9\u00e9e par Nath\u00e9o Beauchamp et Lo\u00efc Lehnhoff (\u00e9l\u00e8ves ing\u00e9nieurs agronome) dans le cadre de l'UE Mod\u00e9lisation en \u00e9pid\u00e9miologie du M2 MODE en novembre 2020.","title":"Bienvenue"},{"location":"#bienvenue","text":"Ce site rassemble des ressources p\u00e9dagogiques li\u00e9es \u00e0 la mod\u00e9lisation de l'\u00e9pid\u00e9mie de COVID-19 en France, r\u00e9alis\u00e9es par et pour les \u00e9l\u00e8ves ing\u00e9nieurs agronomes de L'institut Agro de Rennes, non sans apports des \u00e9tudiants du Master MODE (Mod\u00e9lisation en \u00e9cologie), qui est \u00e9galement une Sp\u00e9cialisation du cursus ing\u00e9nieur. Il s'agit d'exercices \u00e0 vis\u00e9e strictement p\u00e9dagogique. La critique des mod\u00e8les fait partie de l'exercice. Les donn\u00e9es proviennent de data.gouv.fr . Commentaires bienvenus : merci d'\u00e9crire \u00e0 Fr\u00e9d\u00e9ric Hamelin (frederic.hamelin@agrocampus-ouest.fr). Derni\u00e8re mise \u00e0 jour : le 20/05/2021.","title":"Bienvenue !"},{"location":"#travaux-diriges-en-ligne","text":"Les TD sont propos\u00e9s en langage R .","title":"Travaux dirig\u00e9s en ligne"},{"location":"#introduction-a-la-modelisation-en-epidemiologie-covid-19","text":"","title":"Introduction \u00e0 la mod\u00e9lisation en \u00e9pid\u00e9miologie : COVID-19"},{"location":"#1ere-flambee","text":"TD1 : croissance exponentielle des d\u00e9c\u00e8s TD2 : estimation du taux de l\u00e9talit\u00e9 sur la base des donn\u00e9es de tests et de d\u00e9c\u00e8s","title":"1\u00e8re flamb\u00e9e"},{"location":"#1er-confinement","text":"TD3 : dynamique \u00e9pid\u00e9mique sur la base des donn\u00e9es d'hospitalisations TD4 : dynamique \u00e9pid\u00e9mique sur la base des donn\u00e9es de tests et de d\u00e9c\u00e8s","title":"1er confinement"},{"location":"#2eme-flambee","text":"TD5 : dynamique \u00e9pid\u00e9mique sur la base des donn\u00e9es de tests et de d\u00e9c\u00e8s L'appli COVID-19 pr\u00e9sente un ajustement sur la base des donn\u00e9es d'hospitalisations","title":"2\u00e8me flamb\u00e9e"},{"location":"#2eme-confinement","text":"TD6 : dynamique \u00e9pid\u00e9mique sur la base des donn\u00e9es de tests, de d\u00e9c\u00e8s, et d'hospitalisations","title":"2\u00e8me confinement"},{"location":"#applications-interactives","text":"Les applis sont r\u00e9alis\u00e9es avec Shiny .","title":"Applications interactives"},{"location":"#covid-19","text":"Cette appli permet de visualiser l'\u00e9volution des hospitalisations et des admissions des malades, d'ajuster un mod\u00e8le simple (cf. section \" information on the model \", onglet \"model\") et de r\u00e9aliser des projections. Dans la section \" information on the model \", l'onglet \" Fitting example \" donne un exemple d'ajustement de la dynamique \u00e9pid\u00e9mique durant la 2\u00e8me flamb\u00e9e, sur la base des donn\u00e9es d'hospitalisations. Appli r\u00e9alis\u00e9e par Maimouna Diarra (\u00e9l\u00e8ve ing\u00e9nieure agronome) dans le cadre d'un stage de S7 en d\u00e9cembre 2020/janvier 2021.","title":"COVID-19"},{"location":"#covidcontact","text":"Cette appli propose un mod\u00e8le structur\u00e9 en \u00e2ge pour mod\u00e9liser la dynamique pendant et apr\u00e8s le 1er confinement, et tester des sc\u00e9narios de d\u00e9confinement. Le mod\u00e8le est pr\u00e9sent\u00e9 sur la page suivante : Transmission du coronavirus confinement/post-confinement et impact des mesures de distanciation sociale . Un exemple de sorties est propos\u00e9 dans la section \"Ajustement du mod\u00e8le\" puis \"Repr\u00e9sentations graphiques\". Appli cr\u00e9\u00e9e par Nath\u00e9o Beauchamp et Lo\u00efc Lehnhoff (\u00e9l\u00e8ves ing\u00e9nieurs agronome) dans le cadre de l'UE Mod\u00e9lisation en \u00e9pid\u00e9miologie du M2 MODE en novembre 2020.","title":"CovidContact"},{"location":"TD1/","text":"Introduction \u00e0 la mod\u00e9lisation en \u00e9pid\u00e9miologie : COVID-19 - 1\u00e8re flamb\u00e9e - croissance exponentielle des d\u00e9c\u00e8s Fr\u00e9d\u00e9ric Hamelin, le 22 Mars 2021. Dans ce premier TD, nous allons mod\u00e9liser la croissance initiale de l'\u00e9pid\u00e9mie de COVID19 en France sur la base des donn\u00e9es de d\u00e9c\u00e8s uniquement. Mod\u00e8le \u00e9pid\u00e9miologique Les variables du mod\u00e8le sont : S(t) : le nombre de personnes sensibles au temps t , I(t) : le nombre de personnes infect\u00e9es et infectieuses, R(t) : le nombre de personnes r\u00e9tablies ou gu\u00e9ries, D(t) : le nombre de personnes d\u00e9c\u00e9d\u00e9es. La taille de la population est N=S+I+R . Les param\u00e8tres du mod\u00e8les sont \\beta : le taux de transmission de la maladie, \\gamma : le taux de gu\u00e9rison, \\alpha : le taux de mortalit\u00e9 due \u00e0 la maladie. Ce sont des \"taux\" par unit\u00e9 de temps. Le mod\u00e8le s'\u00e9crit : \\begin{eqnarray} \\frac{\\mathrm{d}S}{\\mathrm{d}t}&=&-\\beta \\frac{I}{N}S\\,,\\\\ \\frac{\\mathrm{d}I}{\\mathrm{d}t}&=&\\beta \\frac{I}{N}S - (\\alpha+\\gamma)I\\,,\\\\ \\frac{\\mathrm{d}R}{\\mathrm{d}t}&=&\\gamma I\\,,\\\\ \\frac{\\mathrm{d}D}{\\mathrm{d}t}&=&\\alpha I\\,. \\end{eqnarray} Comme nous nous int\u00e9ressons \u00e0 la phase initiale de l'\u00e9pid\u00e9mie, nous faisons l'hypoth\u00e8se que pour tout t dans cette phase initiale, I,R,D \\ll S , de sorte que S\\approx N (la taille de la population est approximativement constante durant cette p\u00e9riode). Le mod\u00e8le simplifi\u00e9 s'\u00e9crit : \\begin{eqnarray} \\frac{\\mathrm{d}I}{\\mathrm{d}t}&=&(\\beta - \\alpha-\\gamma)I\\,,\\\\ \\frac{\\mathrm{d}R}{\\mathrm{d}t}&=&\\gamma I\\,,\\\\ \\frac{\\mathrm{d}D}{\\mathrm{d}t}&=&\\alpha I\\,. \\end{eqnarray} Ainsi, I(t) = I(0)\\exp\\left(\\left(\\beta-\\alpha-\\gamma\\right)t\\right), et \\begin{eqnarray} D(t)&=&D(0)+\\int_0^t\\alpha I(\\tau) \\mathrm{d}\\tau\\,,\\\\ &=& D(0)+\\alpha\\int_0^t I(0)\\exp\\left(\\left(\\beta-\\alpha-\\gamma\\right)\\tau\\right) \\mathrm{d}\\tau\\,,\\\\ &=& D(0) + \\frac{\\alpha I(0)}{\\beta-\\alpha-\\gamma}\\left[\\exp\\left(\\left(\\beta-\\alpha-\\gamma\\right)t\\right)-1\\right]\\,. \\end{eqnarray} Soient r=\\beta-\\alpha-\\gamma\\,,\\quad\\mbox{et}\\quad q=\\alpha I(0)\\,. Le mod\u00e8le s'\u00e9crit enfin D(t)=D(0)+\\frac{q}{r}\\left(\\exp(rt)-1\\right)\\,. Selon le mod\u00e8le, le nombre de d\u00e9c\u00e8s cumul\u00e9s cro\u00eet de fa\u00e7on exponentielle en fonction du temps. Traitement des donn\u00e9es Commen\u00e7ons par nettoyer le plan de travail : rm(list=ls()) # Efface les variables cr\u00e9\u00e9es lors des ex\u00e9cutions pr\u00e9c\u00e9dentes graphics.off() # Ferme les fen\u00eatres ouvertes lors des ex\u00e9cutions pr\u00e9c\u00e9dentes Nous aurons besoin de la librairie readr : library(readr) # N\u00e9cessaire pour utiliser la fonction read_csv ci-dessous Importons les Donn\u00e9es relatives \u00e0 l\u2019\u00e9pid\u00e9mie de COVID-19 en France : vue d\u2019ensemble : data <- read_csv(url(\"https://www.data.gouv.fr/fr/datasets/r/d3a98a30-893f-47f7-96c5-2f4bcaaa0d71\")) Rempla\u00e7ons les donn\u00e9es manquantes par des z\u00e9ros pour faciliter le traitement des donn\u00e9es ensuite : data[is.na(data)]=0 Nous sommes int\u00e9ress\u00e9s par les d\u00e9c\u00e8s totaux (h\u00f4pital + EHPAD) : Dobs=data$total_deces_hopital+data$total_deces_ehpad # d\u00e9c\u00e8s cumul\u00e9s Affichons les d\u00e9c\u00e8s en fonction du temps : L=length(data$date) # longueur de la s\u00e9rie de donn\u00e9es Tobs=seq(0,L-1,by=1) # Vecteur temps plot(Tobs,Dobs,xlab=\"Temps \u00e9coul\u00e9 depuis le 2 mars 2020 (en jours)\",ylab=\"Nombre de personnes d\u00e9c\u00e9d\u00e9es\",col=\"blue\") Restreignons la p\u00e9riode \u00e9tudi\u00e9e au mois de mars 2020 (1\u00e8re flamb\u00e9e) : Tmax=30 # Fin de la fen\u00eatre temporelle (le 31 mars 2020) w=seq(0,Tmax,by=1) # Fen\u00eatre temporelle consid\u00e9r\u00e9e Tobs=Tobs[w] # Troncation des donn\u00e9es Dobs=Dobs[w] Affichons les d\u00e9c\u00e8s cumul\u00e9s sur cette p\u00e9riode : plot(Tobs,Dobs,xlab=\"Temps \u00e9coul\u00e9 depuis le 2 mars 2020 (en jours)\",ylab=\"Nombre de personnes d\u00e9c\u00e9d\u00e9es\",col=\"blue\") La croissance est-elle exponentielle ? Si oui, le logarithme du nombre de d\u00e9c\u00e8s devrait cro\u00eetre de fa\u00e7on lin\u00e9aire en fonction du temps : plot(Tobs,log(Dobs),xlab=\"Temps \u00e9coul\u00e9 depuis le 2 mars 2020 (en jours)\",ylab=\"Log(Nombre de d\u00e9c\u00e8s cumul\u00e9s)\",col=\"blue\") reg=lm(log(Dobs)~Tobs) # R\u00e9gression lin\u00e9aire intercept=reg$coefficients[[1]] slope=reg$coefficients[[2]] abline(reg) Nous voyons que la croissance du logarithme est relativement lin\u00e9aire sur la p\u00e9riode consid\u00e9r\u00e9e. L'hypoth\u00e8se d'une croissance exponentielle du nombre de d\u00e9c\u00e8s cumul\u00e9s para\u00eet raisonnable sur la p\u00e9riode consid\u00e9r\u00e9e (mars 2020). Ajustement du mod\u00e8le aux donn\u00e9es Au 2 mars ( t=0 ), le nombre de d\u00e9c\u00e8s cumul\u00e9s est D(0)=3 : D0=Dobs[1] # Donn\u00e9e initiale Comme D(0) est petit par rapport au nombre de d\u00e9c\u00e8s cumul\u00e9s (ce nombre d\u00e9passe 3000 \u00e0 la fin du mois de mars), on peut consid\u00e9rer la relation suivante en premi\u00e8re et grossi\u00e8re approximation : D(t)=D(0)+\\frac{q}{r}\\left(\\exp(rt)-1\\right))\\approx \\frac{q}{r}\\exp(rt)\\,. Cela donne \\log(D(t))\\approx\\log\\left(\\frac{q}{r}\\right)+rt\\,, ce qui permet d'obtenir des estimations initiales des valeurs des param\u00e8tres r et q d'apr\u00e8s la r\u00e9gression lin\u00e9aire r\u00e9alis\u00e9e pr\u00e9c\u00e9demment : #estimations grossi\u00e8res initiales r=slope # r = beta - alpha - gamma q=r*exp(intercept) # q = alpha*I_0 Calculons la courbe issue du mod\u00e8le pour ces valeurs de param\u00e8tres : Tmodel=Tobs # on calcule la solution du mod\u00e8le pour les dates d'observation Dmodel=D0 + (q/r)*(exp(r*Tmodel)-1) Comparons le mod\u00e8le aux donn\u00e9es : plot(Tobs,Dobs,xlab=\"Temps \u00e9coul\u00e9 depuis le 2 mars 2020 (en jours)\",ylab=\"Nombre de d\u00e9c\u00e8s cumul\u00e9s\",col=\"blue\") lines(Tmodel,Dmodel,col=\"red\") L'ajustement pourrait \u00eatre meilleur. Appelons \\theta=\\{r,q\\} le vecteur des param\u00e8tres \u00e0 optimiser : theta=c(r,q) # Vecteur des param\u00e8tres \u00e0 optimiser M\u00e9thode des moindres carr\u00e9s Recherchons les valeurs des param\u00e8tres r et q qui minimisent la somme des carr\u00e9s des \u00e9carts entre mod\u00e8le et donn\u00e9es (SCE) : \\mbox{SCE} = \\sum_{t=0}^T \\left(D_{\\small\\mbox{model}}(t)-D_{\\small\\mbox{data}}(t)\\right)^2\\,. Cr\u00e9ons une fonction qui prend en entr\u00e9e les param\u00e8tres \u00e0 optimiser et renvoie en sortie la quantit\u00e9 \u00e0 minimiser (SCE) : SCE_Covid=function(theta){ r=theta[1] q=theta[2] Dmodel = D0 + (q/r)*(exp(r*Tmodel)-1) ecarts = Dobs - Dmodel SCE = sum(ecarts^2) return(SCE) } Cherchons les valeurs des param\u00e8tres qui minimisent SCE : opt=optim(theta,SCE_Covid) # La fonction optim minimise par d\u00e9faut r=opt$par[1] q=opt$par[2] Affichons la solution optimale au sens des moindres carr\u00e9s : Dmodel = D0 + (q/r)*(exp(r*Tmodel)-1) plot(Tobs,Dobs,xlab=\"Temps \u00e9coul\u00e9 depuis le 2 mars 2020 (en jours)\",ylab=\"Nombre de d\u00e9c\u00e8s cumul\u00e9s\",col=\"blue\") lines(Tmodel,Dmodel,col=\"red\") L'ajustement est meilleur que celui obtenu en premi\u00e8re et grossi\u00e8re approximation. Affichons les valeurs des param\u00e8tres obtenues : print(r) print(q) On trouve r \\approx 0.17 et q \\approx 4.11 . M\u00e9thode du maximum de vraisemblance Une m\u00e9thode alternative consiste \u00e0 maximiser la probabilit\u00e9 des observations sachant les param\u00e8tres. C'est ce qu'on appelle la vraisemblance ( likelihood en anglais). Nous faisons l'hypoth\u00e8se que le nombre de d\u00e9c\u00e8s cumul\u00e9s observ\u00e9 au jour t est tir\u00e9 dans une loi de Poisson de moyenne D(t) telle que donn\u00e9 par le mod\u00e8le : D_{\\small\\mbox{data}}(t)\\sim \\mbox{Poisson}\\left(D_{\\small\\mbox{model}}(t)\\right) En admettant que les observations sont ind\u00e9pendantes conditionnellement au mod\u00e8le, la vraisemblance s'\u00e9crit : \\mbox{Like}(\\theta)=\\prod_{t=0}^{T} \\mbox{Prob}(\\mbox{observe }D_{\\small\\mbox{data}}(t)|D_{\\small\\mbox{model}}(t))\\,. Rechercher les valeurs de \\theta qui maximisent la vraisemblance est \u00e9quivalent \u00e0 rechercher les valeurs de \\theta qui maximisent la log-vraisemblance, qui transforme le produit en somme : \\mbox{logLike}(\\theta)=\\log(\\mbox{Like}(\\theta))=\\sum_{t=0}^T \\log\\left (\\mbox{Prob}(\\mbox{observe }D_{\\small\\mbox{data}}(t)|D_{\\small\\mbox{model}}(t))\\right )\\,. Cr\u00e9ons une fonction qui prend en entr\u00e9e les param\u00e8tres \u00e0 optimiser et renvoie en sortie la quantit\u00e9 \u00e0 minimiser (-logLike) : LL_Covid=function(theta){ #Log-likelihood r=theta[1] q=theta[2] Dmodel = D0 + (q/r)*(exp(r*Tmodel)-1) probas = dpois(Dobs,Dmodel) LL=sum(log(probas)) return(-LL) #on renvoie l'oppos\u00e9 pour minimiser } Cherchons les valeurs des param\u00e8tres qui maximisent logLike : opt=optim(theta,LL_Covid) r=opt$par[1] q=opt$par[2] Affichons la solution optimale au sens du maximum de vraisemblance : Dmodel = D0 + (q/r)*(exp(r*Tmodel)-1) plot(Tobs,Dobs,xlab=\"Temps \u00e9coul\u00e9 depuis le 2 mars 2020 (en jours)\",ylab=\"Nombre de d\u00e9c\u00e8s cumul\u00e9s\",col=\"blue\") lines(Tmodel,Dmodel,col=\"red\") L'ajustement est comparable \u00e0 celui obtenu via les moindres carr\u00e9s. Affichons les valeurs des param\u00e8tres obtenues : print(r) print(q) On trouve r \\approx 0.19 et q \\approx 2.47 , ce qui diff\u00e8re un peu des valeurs obtenues via les moindres carr\u00e9s. Interpr\u00e9tation des r\u00e9sultats L'ajustement du mod\u00e8le aux donn\u00e9es a permis de confirmer le caract\u00e8re exponentiel de la dynamique \u00e9pid\u00e9mique durant la premi\u00e8re flamb\u00e9e, telle que mesur\u00e9e par les d\u00e9c\u00e8s cumul\u00e9s en mars 2020, d'estimer les param\u00e8tres r=\\beta-\\alpha-\\gamma et q=\\alpha I(0) . En admettant que le taux de mortalit\u00e9 due \u00e0 la maladie (\\alpha) est tr\u00e8s petit devant le taux de gu\u00e9rison (\\gamma) , nous avons l'approximation r\\approx \\beta - \\gamma . Cela permet d'estimer la reproductivit\u00e9 du virus ( \\mathcal{R}_0 ), d\u00e9finie comme le nombre d'infections secondaires g\u00e9n\u00e9r\u00e9es par un individu infect\u00e9 dans une population initialement na\u00efve : \\mathcal{R}_0 = \\frac{\\beta}{\\alpha+\\gamma}\\approx \\frac{\\beta}{\\gamma} \\approx 1 + \\frac{r}{\\gamma}\\,. Admettons que le temps de gu\u00e9rison est de 10 jours en moyenne, soit \\gamma=0.1 par jour. On obtient : \\mathcal{R}_0\\approx 2.74 via la m\u00e9thode des moindres carr\u00e9s, \\mathcal{R}_0\\approx 2.98 via la m\u00e9thode du maximum de vraisemblance. Ces estimations sont coh\u00e9rentes avec celles obtenues par diff\u00e9rentes \u00e9tudes (ex. Roques et al 2020 ). Le taux de l\u00e9talit\u00e9 du virus (la probabilit\u00e9 moyenne de mourir lorsqu'on est infect\u00e9) est p=\\frac{\\alpha}{\\alpha+\\gamma}\\,. Supposons p=0.8\\% ( Roques et al 2020 ), ce qui donne \\alpha=p\\gamma/(1-p)\\approx p\\gamma = .0008 . Nous obtenons I(0)=q/\\alpha\\approx 5145 via les moindres carr\u00e9s, I(0)=q/\\alpha\\approx 3092 via le maximum de vraisemblance. Le mod\u00e8le permet d'estimer un ordre de grandeur du nombre total de personnes infect\u00e9es et infectieuses au 3 mars, alors que le nombre total de cas confirm\u00e9s \u00e0 cette date s'\u00e9levait \u00e0 191 d'apr\u00e8s les Donn\u00e9es relatives \u00e0 l\u2019\u00e9pid\u00e9mie de COVID-19 en France : vue d\u2019ensemble . D'apr\u00e8s le mod\u00e8le, on aurait approximativement 4000/200=20 personnes infect\u00e9es pour 1 cas confirm\u00e9 au 2 mars 2020.","title":"TD1 (Mars 2020)"},{"location":"TD1/#introduction-a-la-modelisation-en-epidemiologie-covid-19-1ere-flambee-croissance-exponentielle-des-deces","text":"Fr\u00e9d\u00e9ric Hamelin, le 22 Mars 2021. Dans ce premier TD, nous allons mod\u00e9liser la croissance initiale de l'\u00e9pid\u00e9mie de COVID19 en France sur la base des donn\u00e9es de d\u00e9c\u00e8s uniquement.","title":"Introduction \u00e0 la mod\u00e9lisation en \u00e9pid\u00e9miologie : COVID-19 - 1\u00e8re flamb\u00e9e - croissance exponentielle des d\u00e9c\u00e8s"},{"location":"TD1/#modele-epidemiologique","text":"Les variables du mod\u00e8le sont : S(t) : le nombre de personnes sensibles au temps t , I(t) : le nombre de personnes infect\u00e9es et infectieuses, R(t) : le nombre de personnes r\u00e9tablies ou gu\u00e9ries, D(t) : le nombre de personnes d\u00e9c\u00e9d\u00e9es. La taille de la population est N=S+I+R . Les param\u00e8tres du mod\u00e8les sont \\beta : le taux de transmission de la maladie, \\gamma : le taux de gu\u00e9rison, \\alpha : le taux de mortalit\u00e9 due \u00e0 la maladie. Ce sont des \"taux\" par unit\u00e9 de temps. Le mod\u00e8le s'\u00e9crit : \\begin{eqnarray} \\frac{\\mathrm{d}S}{\\mathrm{d}t}&=&-\\beta \\frac{I}{N}S\\,,\\\\ \\frac{\\mathrm{d}I}{\\mathrm{d}t}&=&\\beta \\frac{I}{N}S - (\\alpha+\\gamma)I\\,,\\\\ \\frac{\\mathrm{d}R}{\\mathrm{d}t}&=&\\gamma I\\,,\\\\ \\frac{\\mathrm{d}D}{\\mathrm{d}t}&=&\\alpha I\\,. \\end{eqnarray} Comme nous nous int\u00e9ressons \u00e0 la phase initiale de l'\u00e9pid\u00e9mie, nous faisons l'hypoth\u00e8se que pour tout t dans cette phase initiale, I,R,D \\ll S , de sorte que S\\approx N (la taille de la population est approximativement constante durant cette p\u00e9riode). Le mod\u00e8le simplifi\u00e9 s'\u00e9crit : \\begin{eqnarray} \\frac{\\mathrm{d}I}{\\mathrm{d}t}&=&(\\beta - \\alpha-\\gamma)I\\,,\\\\ \\frac{\\mathrm{d}R}{\\mathrm{d}t}&=&\\gamma I\\,,\\\\ \\frac{\\mathrm{d}D}{\\mathrm{d}t}&=&\\alpha I\\,. \\end{eqnarray} Ainsi, I(t) = I(0)\\exp\\left(\\left(\\beta-\\alpha-\\gamma\\right)t\\right), et \\begin{eqnarray} D(t)&=&D(0)+\\int_0^t\\alpha I(\\tau) \\mathrm{d}\\tau\\,,\\\\ &=& D(0)+\\alpha\\int_0^t I(0)\\exp\\left(\\left(\\beta-\\alpha-\\gamma\\right)\\tau\\right) \\mathrm{d}\\tau\\,,\\\\ &=& D(0) + \\frac{\\alpha I(0)}{\\beta-\\alpha-\\gamma}\\left[\\exp\\left(\\left(\\beta-\\alpha-\\gamma\\right)t\\right)-1\\right]\\,. \\end{eqnarray} Soient r=\\beta-\\alpha-\\gamma\\,,\\quad\\mbox{et}\\quad q=\\alpha I(0)\\,. Le mod\u00e8le s'\u00e9crit enfin D(t)=D(0)+\\frac{q}{r}\\left(\\exp(rt)-1\\right)\\,. Selon le mod\u00e8le, le nombre de d\u00e9c\u00e8s cumul\u00e9s cro\u00eet de fa\u00e7on exponentielle en fonction du temps.","title":"Mod\u00e8le \u00e9pid\u00e9miologique"},{"location":"TD1/#traitement-des-donnees","text":"Commen\u00e7ons par nettoyer le plan de travail : rm(list=ls()) # Efface les variables cr\u00e9\u00e9es lors des ex\u00e9cutions pr\u00e9c\u00e9dentes graphics.off() # Ferme les fen\u00eatres ouvertes lors des ex\u00e9cutions pr\u00e9c\u00e9dentes Nous aurons besoin de la librairie readr : library(readr) # N\u00e9cessaire pour utiliser la fonction read_csv ci-dessous Importons les Donn\u00e9es relatives \u00e0 l\u2019\u00e9pid\u00e9mie de COVID-19 en France : vue d\u2019ensemble : data <- read_csv(url(\"https://www.data.gouv.fr/fr/datasets/r/d3a98a30-893f-47f7-96c5-2f4bcaaa0d71\")) Rempla\u00e7ons les donn\u00e9es manquantes par des z\u00e9ros pour faciliter le traitement des donn\u00e9es ensuite : data[is.na(data)]=0 Nous sommes int\u00e9ress\u00e9s par les d\u00e9c\u00e8s totaux (h\u00f4pital + EHPAD) : Dobs=data$total_deces_hopital+data$total_deces_ehpad # d\u00e9c\u00e8s cumul\u00e9s Affichons les d\u00e9c\u00e8s en fonction du temps : L=length(data$date) # longueur de la s\u00e9rie de donn\u00e9es Tobs=seq(0,L-1,by=1) # Vecteur temps plot(Tobs,Dobs,xlab=\"Temps \u00e9coul\u00e9 depuis le 2 mars 2020 (en jours)\",ylab=\"Nombre de personnes d\u00e9c\u00e9d\u00e9es\",col=\"blue\") Restreignons la p\u00e9riode \u00e9tudi\u00e9e au mois de mars 2020 (1\u00e8re flamb\u00e9e) : Tmax=30 # Fin de la fen\u00eatre temporelle (le 31 mars 2020) w=seq(0,Tmax,by=1) # Fen\u00eatre temporelle consid\u00e9r\u00e9e Tobs=Tobs[w] # Troncation des donn\u00e9es Dobs=Dobs[w] Affichons les d\u00e9c\u00e8s cumul\u00e9s sur cette p\u00e9riode : plot(Tobs,Dobs,xlab=\"Temps \u00e9coul\u00e9 depuis le 2 mars 2020 (en jours)\",ylab=\"Nombre de personnes d\u00e9c\u00e9d\u00e9es\",col=\"blue\") La croissance est-elle exponentielle ? Si oui, le logarithme du nombre de d\u00e9c\u00e8s devrait cro\u00eetre de fa\u00e7on lin\u00e9aire en fonction du temps : plot(Tobs,log(Dobs),xlab=\"Temps \u00e9coul\u00e9 depuis le 2 mars 2020 (en jours)\",ylab=\"Log(Nombre de d\u00e9c\u00e8s cumul\u00e9s)\",col=\"blue\") reg=lm(log(Dobs)~Tobs) # R\u00e9gression lin\u00e9aire intercept=reg$coefficients[[1]] slope=reg$coefficients[[2]] abline(reg) Nous voyons que la croissance du logarithme est relativement lin\u00e9aire sur la p\u00e9riode consid\u00e9r\u00e9e. L'hypoth\u00e8se d'une croissance exponentielle du nombre de d\u00e9c\u00e8s cumul\u00e9s para\u00eet raisonnable sur la p\u00e9riode consid\u00e9r\u00e9e (mars 2020).","title":"Traitement des donn\u00e9es"},{"location":"TD1/#ajustement-du-modele-aux-donnees","text":"Au 2 mars ( t=0 ), le nombre de d\u00e9c\u00e8s cumul\u00e9s est D(0)=3 : D0=Dobs[1] # Donn\u00e9e initiale Comme D(0) est petit par rapport au nombre de d\u00e9c\u00e8s cumul\u00e9s (ce nombre d\u00e9passe 3000 \u00e0 la fin du mois de mars), on peut consid\u00e9rer la relation suivante en premi\u00e8re et grossi\u00e8re approximation : D(t)=D(0)+\\frac{q}{r}\\left(\\exp(rt)-1\\right))\\approx \\frac{q}{r}\\exp(rt)\\,. Cela donne \\log(D(t))\\approx\\log\\left(\\frac{q}{r}\\right)+rt\\,, ce qui permet d'obtenir des estimations initiales des valeurs des param\u00e8tres r et q d'apr\u00e8s la r\u00e9gression lin\u00e9aire r\u00e9alis\u00e9e pr\u00e9c\u00e9demment : #estimations grossi\u00e8res initiales r=slope # r = beta - alpha - gamma q=r*exp(intercept) # q = alpha*I_0 Calculons la courbe issue du mod\u00e8le pour ces valeurs de param\u00e8tres : Tmodel=Tobs # on calcule la solution du mod\u00e8le pour les dates d'observation Dmodel=D0 + (q/r)*(exp(r*Tmodel)-1) Comparons le mod\u00e8le aux donn\u00e9es : plot(Tobs,Dobs,xlab=\"Temps \u00e9coul\u00e9 depuis le 2 mars 2020 (en jours)\",ylab=\"Nombre de d\u00e9c\u00e8s cumul\u00e9s\",col=\"blue\") lines(Tmodel,Dmodel,col=\"red\") L'ajustement pourrait \u00eatre meilleur. Appelons \\theta=\\{r,q\\} le vecteur des param\u00e8tres \u00e0 optimiser : theta=c(r,q) # Vecteur des param\u00e8tres \u00e0 optimiser","title":"Ajustement du mod\u00e8le aux donn\u00e9es"},{"location":"TD1/#methode-des-moindres-carres","text":"Recherchons les valeurs des param\u00e8tres r et q qui minimisent la somme des carr\u00e9s des \u00e9carts entre mod\u00e8le et donn\u00e9es (SCE) : \\mbox{SCE} = \\sum_{t=0}^T \\left(D_{\\small\\mbox{model}}(t)-D_{\\small\\mbox{data}}(t)\\right)^2\\,. Cr\u00e9ons une fonction qui prend en entr\u00e9e les param\u00e8tres \u00e0 optimiser et renvoie en sortie la quantit\u00e9 \u00e0 minimiser (SCE) : SCE_Covid=function(theta){ r=theta[1] q=theta[2] Dmodel = D0 + (q/r)*(exp(r*Tmodel)-1) ecarts = Dobs - Dmodel SCE = sum(ecarts^2) return(SCE) } Cherchons les valeurs des param\u00e8tres qui minimisent SCE : opt=optim(theta,SCE_Covid) # La fonction optim minimise par d\u00e9faut r=opt$par[1] q=opt$par[2] Affichons la solution optimale au sens des moindres carr\u00e9s : Dmodel = D0 + (q/r)*(exp(r*Tmodel)-1) plot(Tobs,Dobs,xlab=\"Temps \u00e9coul\u00e9 depuis le 2 mars 2020 (en jours)\",ylab=\"Nombre de d\u00e9c\u00e8s cumul\u00e9s\",col=\"blue\") lines(Tmodel,Dmodel,col=\"red\") L'ajustement est meilleur que celui obtenu en premi\u00e8re et grossi\u00e8re approximation. Affichons les valeurs des param\u00e8tres obtenues : print(r) print(q) On trouve r \\approx 0.17 et q \\approx 4.11 .","title":"M\u00e9thode des moindres carr\u00e9s"},{"location":"TD1/#methode-du-maximum-de-vraisemblance","text":"Une m\u00e9thode alternative consiste \u00e0 maximiser la probabilit\u00e9 des observations sachant les param\u00e8tres. C'est ce qu'on appelle la vraisemblance ( likelihood en anglais). Nous faisons l'hypoth\u00e8se que le nombre de d\u00e9c\u00e8s cumul\u00e9s observ\u00e9 au jour t est tir\u00e9 dans une loi de Poisson de moyenne D(t) telle que donn\u00e9 par le mod\u00e8le : D_{\\small\\mbox{data}}(t)\\sim \\mbox{Poisson}\\left(D_{\\small\\mbox{model}}(t)\\right) En admettant que les observations sont ind\u00e9pendantes conditionnellement au mod\u00e8le, la vraisemblance s'\u00e9crit : \\mbox{Like}(\\theta)=\\prod_{t=0}^{T} \\mbox{Prob}(\\mbox{observe }D_{\\small\\mbox{data}}(t)|D_{\\small\\mbox{model}}(t))\\,. Rechercher les valeurs de \\theta qui maximisent la vraisemblance est \u00e9quivalent \u00e0 rechercher les valeurs de \\theta qui maximisent la log-vraisemblance, qui transforme le produit en somme : \\mbox{logLike}(\\theta)=\\log(\\mbox{Like}(\\theta))=\\sum_{t=0}^T \\log\\left (\\mbox{Prob}(\\mbox{observe }D_{\\small\\mbox{data}}(t)|D_{\\small\\mbox{model}}(t))\\right )\\,. Cr\u00e9ons une fonction qui prend en entr\u00e9e les param\u00e8tres \u00e0 optimiser et renvoie en sortie la quantit\u00e9 \u00e0 minimiser (-logLike) : LL_Covid=function(theta){ #Log-likelihood r=theta[1] q=theta[2] Dmodel = D0 + (q/r)*(exp(r*Tmodel)-1) probas = dpois(Dobs,Dmodel) LL=sum(log(probas)) return(-LL) #on renvoie l'oppos\u00e9 pour minimiser } Cherchons les valeurs des param\u00e8tres qui maximisent logLike : opt=optim(theta,LL_Covid) r=opt$par[1] q=opt$par[2] Affichons la solution optimale au sens du maximum de vraisemblance : Dmodel = D0 + (q/r)*(exp(r*Tmodel)-1) plot(Tobs,Dobs,xlab=\"Temps \u00e9coul\u00e9 depuis le 2 mars 2020 (en jours)\",ylab=\"Nombre de d\u00e9c\u00e8s cumul\u00e9s\",col=\"blue\") lines(Tmodel,Dmodel,col=\"red\") L'ajustement est comparable \u00e0 celui obtenu via les moindres carr\u00e9s. Affichons les valeurs des param\u00e8tres obtenues : print(r) print(q) On trouve r \\approx 0.19 et q \\approx 2.47 , ce qui diff\u00e8re un peu des valeurs obtenues via les moindres carr\u00e9s.","title":"M\u00e9thode du maximum de vraisemblance"},{"location":"TD1/#interpretation-des-resultats","text":"L'ajustement du mod\u00e8le aux donn\u00e9es a permis de confirmer le caract\u00e8re exponentiel de la dynamique \u00e9pid\u00e9mique durant la premi\u00e8re flamb\u00e9e, telle que mesur\u00e9e par les d\u00e9c\u00e8s cumul\u00e9s en mars 2020, d'estimer les param\u00e8tres r=\\beta-\\alpha-\\gamma et q=\\alpha I(0) . En admettant que le taux de mortalit\u00e9 due \u00e0 la maladie (\\alpha) est tr\u00e8s petit devant le taux de gu\u00e9rison (\\gamma) , nous avons l'approximation r\\approx \\beta - \\gamma . Cela permet d'estimer la reproductivit\u00e9 du virus ( \\mathcal{R}_0 ), d\u00e9finie comme le nombre d'infections secondaires g\u00e9n\u00e9r\u00e9es par un individu infect\u00e9 dans une population initialement na\u00efve : \\mathcal{R}_0 = \\frac{\\beta}{\\alpha+\\gamma}\\approx \\frac{\\beta}{\\gamma} \\approx 1 + \\frac{r}{\\gamma}\\,. Admettons que le temps de gu\u00e9rison est de 10 jours en moyenne, soit \\gamma=0.1 par jour. On obtient : \\mathcal{R}_0\\approx 2.74 via la m\u00e9thode des moindres carr\u00e9s, \\mathcal{R}_0\\approx 2.98 via la m\u00e9thode du maximum de vraisemblance. Ces estimations sont coh\u00e9rentes avec celles obtenues par diff\u00e9rentes \u00e9tudes (ex. Roques et al 2020 ). Le taux de l\u00e9talit\u00e9 du virus (la probabilit\u00e9 moyenne de mourir lorsqu'on est infect\u00e9) est p=\\frac{\\alpha}{\\alpha+\\gamma}\\,. Supposons p=0.8\\% ( Roques et al 2020 ), ce qui donne \\alpha=p\\gamma/(1-p)\\approx p\\gamma = .0008 . Nous obtenons I(0)=q/\\alpha\\approx 5145 via les moindres carr\u00e9s, I(0)=q/\\alpha\\approx 3092 via le maximum de vraisemblance. Le mod\u00e8le permet d'estimer un ordre de grandeur du nombre total de personnes infect\u00e9es et infectieuses au 3 mars, alors que le nombre total de cas confirm\u00e9s \u00e0 cette date s'\u00e9levait \u00e0 191 d'apr\u00e8s les Donn\u00e9es relatives \u00e0 l\u2019\u00e9pid\u00e9mie de COVID-19 en France : vue d\u2019ensemble . D'apr\u00e8s le mod\u00e8le, on aurait approximativement 4000/200=20 personnes infect\u00e9es pour 1 cas confirm\u00e9 au 2 mars 2020.","title":"Interpr\u00e9tation des r\u00e9sultats"},{"location":"TD2/","text":"Introduction \u00e0 la mod\u00e9lisation en \u00e9pid\u00e9miologie : COVID-19 - 1\u00e8re flamb\u00e9e - estimation du taux de l\u00e9talit\u00e9 Marie Joigneau, Sabine Lobligeois, Louise Belamy, Maimouna Diarra (M1 Agro Rennes), le 14 mars 2021. Edit\u00e9 par Fr\u00e9d\u00e9ric Hamelin et Marine Dorand (M1 MODE), le 23 avril 2021. On se base sur l\u2019\u00e9tude de l\u2019article suivant : Roques et al. (2020) Using Early Data to Estimate the Actual Infection Fatality Ratio from COVID-19 in France . Le but de notre \u00e9tude est de reproduire les r\u00e9sultats de l\u2019article avec les donn\u00e9es de morts actualis\u00e9es et publi\u00e9es par Sant\u00e9 Publique France . Mod\u00e8le \u00e9pid\u00e9miologique Dans ce TD, nous allons mod\u00e9liser la croissance initiale de l'\u00e9pid\u00e9mie de COVID19 en France sur la base des donn\u00e9es de tests dans un premier temps. Les donn\u00e9es concernant les d\u00e9c\u00e8s seront utilis\u00e9es dans un second temps pour estimer le taux de l\u00e9talit\u00e9 de la maladie au d\u00e9but de l'ann\u00e9e 2020 en France. Les variables du mod\u00e8le sont : S(t) : le nombre de personnes sensibles au temps t , I(t) : le nombre de personnes infect\u00e9es et infectieuses, R(t) : le nombre de personnes r\u00e9tablies ou gu\u00e9ries, D(t) : le nombre de personnes d\u00e9c\u00e9d\u00e9es. La taille de la population est N=S+I+R . Les param\u00e8tres du mod\u00e8les sont \\beta : le taux de transmission de la maladie, \\gamma : le taux de gu\u00e9rison, \\alpha : le taux de mortalit\u00e9 due \u00e0 la maladie. Ce sont des \"taux\" par unit\u00e9 de temps. Le mod\u00e8le s'\u00e9crit : \\begin{eqnarray} \\frac{\\mathrm{d}S}{\\mathrm{d}t}&=&-\\beta \\frac{I}{N}S\\,,\\\\ \\frac{\\mathrm{d}I}{\\mathrm{d}t}&=&\\beta \\frac{I}{N}S - (\\alpha+\\gamma)I\\,,\\\\ \\frac{\\mathrm{d}R}{\\mathrm{d}t}&=&\\gamma I\\,,\\\\ \\frac{\\mathrm{d}D}{\\mathrm{d}t}&=&\\alpha I\\,. \\end{eqnarray} Pour simplifier l'\u00e9tude, nous faisons l'hypoth\u00e8se que le taux de mortalit\u00e9 due \u00e0 la maladie est tr\u00e8s faible et n\u00e9gligeable d'un point de vue \u00e9pid\u00e9miologique devant le taux de gu\u00e9rison (\\alpha\\ll \\gamma) . Cela permet de d\u00e9composer le mod\u00e8le en deux parties, la premi\u00e8re \u00e9tant ind\u00e9pendante des d\u00e9c\u00e8s : \\begin{eqnarray} \\frac{\\mathrm{d}S}{\\mathrm{d}t}&=&-\\beta \\frac{I}{N}S\\,,\\\\ \\frac{\\mathrm{d}I}{\\mathrm{d}t}&\\approx&\\beta \\frac{I}{N}S -\\gamma I\\,,\\\\ \\frac{\\mathrm{d}R}{\\mathrm{d}t}&=&\\gamma I\\,. \\end{eqnarray} Elle sera ajust\u00e9e aux donn\u00e9es de tests. La seconde partie du mod\u00e8le sera ajust\u00e9e aux donn\u00e9es de d\u00e9c\u00e8s : \\begin{eqnarray} \\frac{\\mathrm{d}D}{\\mathrm{d}t}&=&\\alpha I\\,. \\end{eqnarray} Mod\u00e8le d'observation L'ajustement du mod\u00e8le se fera par maximisation de la vraisemblance. Cette m\u00e9thode consiste \u00e0 maximiser la probabilit\u00e9 des observations sachant les param\u00e8tres. Le mod\u00e8le d'observation d\u00e9finit la probabilit\u00e9 qu'un test soit positif au temps t\u200b d'apr\u00e8s le mod\u00e8le \u00e9pid\u00e9miologique : p(t)=\\frac{\\sigma I(t)}{I(t)+\\kappa S(t)}\\,, o\u00f9 \\sigma \u200b est la sensibilit\u00e9 des tests PCR (suppos\u00e9e connue) et \\kappa est probabilit\u00e9 relative pour les individus sensibles de se faire tester comparativement aux infect\u00e9s (\u00e0 estimer). Aussi, le nombre de tests positifs le jour t peut \u00eatre mod\u00e9lis\u00e9 comme un tirage dans une loi Binomiale de param\u00e8tres p(t) et n(t) (le nombre de tests r\u00e9alis\u00e9s le jour t ) : le nombre de nouveaux cas observ\u00e9s le jour t est c(t)\\sim \\mbox{Binomial}(n(t),p(t)) En admettant que les observations sont ind\u00e9pendantes conditionnellement au mod\u00e8le, la vraisemblance ( likelihood en anglais) s'\u00e9crit : \\mbox{Like}(\\theta)=\\prod_{t=0}^{T} \\mbox{Prob}(\\mbox{observe }c(t)|\\mbox{ model predicts }p(t))\\,. Soit \\theta = \\{ \\beta, \\kappa \\} le vecteur des param\u00e8tres \u00e0 estimer. Rechercher les valeurs de \\theta qui maximisent la vraisemblance est \u00e9quivalent \u00e0 rechercher les valeurs de \\theta qui maximisent la log-vraisemblance, qui transforme le produit en somme : \\mbox{logLike}(\\theta)=\\log(\\mbox{Like}(\\theta))=\\sum_{t=0}^T \\log\\left (\\mbox{Prob}(\\mbox{observe }c(t)|\\mbox{ model predicts } p(t) )\\right)\\,. Nous travaillerons avec la log-vraisemblance. Traitement des donn\u00e9es Commen\u00e7ons par nettoyer l'environnement de travail : rm(list=ls()) # Efface les variables cr\u00e9\u00e9es lors des ex\u00e9cutions pr\u00e9c\u00e9dentes graphics.off() # Ferme les fen\u00eatres ouvertes lors des ex\u00e9cutions pr\u00e9c\u00e9dentes On charge les librairies suivantes : library(deSolve) # pour r\u00e9soudre le syst\u00e8me d'\u00e9quations diff\u00e9rentielles (mod\u00e8le SIRD) library(R.matlab) # pour lire les fichiers de donn\u00e9es au format matlab library(downloader) # pour faciliter le t\u00e9l\u00e9chargement des donn\u00e9es library(zoo) # pour la moyenne mobile library(readr) # pour utiliser la fonction read_csv On t\u00e9l\u00e9charge l'archive contenant les donn\u00e9es utilis\u00e9es par Roques et al 2020 : download(\"https://www.mdpi.com/2079-7737/9/5/97/s1\", dest=\"suppMat.zip\", mode=\"wb\") On d\u00e9compresse l'archive : unzip(\"suppMat.zip\", exdir = \"suppMat\") On r\u00e9cup\u00e8re les donn\u00e9es relatives aux tests (du 1er janvier au 17 mars) : dataT = readMat(\"./suppMat/data_smooth5.mat\") TP=as.integer(dataT$DATA[1,]) # nombre de tests positifs cumul\u00e9s TT=as.integer(dataT$DATA[2,]) # nombre total de tests cumul\u00e9s LT=length(TP) # Longueur de la s\u00e9rie temporelle On r\u00e9cup\u00e8re les donn\u00e9es relatives aux d\u00e9c\u00e8s (\u00e0 partir du 2 mars) : dataD <- read_csv(url(\"https://www.data.gouv.fr/fr/datasets/r/d3a98a30-893f-47f7-96c5-2f4bcaaa0d71\")) dataD[is.na(dataD)]=0 # on remplace les donn\u00e9es manquantes par des z\u00e9ros avant de sommer DC=dataD$total_deces_hopital+dataD$total_deces_ehpad # nombre de d\u00e9c\u00e8s cumul\u00e9s On cr\u00e9e un vecteur des d\u00e9c\u00e8s cumul\u00e9s du 1er janvier au 17 mars : # Les donn\u00e9es de d\u00e9c\u00e8s sont disponible \u00e0 partir du 2 mars n=31+29+1 # nombre de jours en janvier + f\u00e9vrier 2020 + 1 mars zeros=rep(0,n) # nombre de z\u00e9ros \u00e0 ajouter pour janvier/f\u00e9vrier m=17-1 # la fen\u00eatre de l'\u00e9tude s'arr\u00eate au 17 mars DC = c(zeros,DC[1:m]) # les d\u00e9c\u00e8s cumul\u00e9s du 1er janvier au 17 mars On cr\u00e9e un vecteur pour le taux de positivit\u00e9 cumul\u00e9 : PP=TP/TT # taux de positivit\u00e9 cumul\u00e9 On cr\u00e9e un vecteur temps : temps=seq.Date(from=as.Date(\"2020-01-01\"), to=as.Date(\"2020-03-17\"), by=\"days\") On affiche les tests cumul\u00e9s en fonction du temps : plot(temps,TT,xlab=\"Date (Annee 2020)\",ylab=\"Nombre de tests\",col=\"black\") points(temps,TP,col=\"red\") legend(\"topleft\",c(\"Nombre de tests positifs\",\"Nombre de tests realises\"), fill=c(\"red\",\"black\")) title(\"Resultats cumules des tests realises de covid 19\") On affiche la proportion de tests positifs en fonction du temps : plot(temps,PP,xlab=\"Date (Annee 2020)\",ylab=\"Proportion de tests positifs\",col=\"purple\") title(\"Proportion de tests positifs en fonction du temps\") On affiche les d\u00e9c\u00e8s cumul\u00e9s en fonction du temps : plot(temps,DC,xlab=\"Date (Annee 2020)\",ylab=\"Nombre de morts\",col=\"orange\") title(\"Morts cumules du covid 19\") On retrouve les donn\u00e9es non-cumul\u00e9es en utilisant la fonction diff : tt=diff(TT) # nombre quotidien de tests r\u00e9alis\u00e9s tp=diff(TP) # nombre quotidien de tests positifs dc=diff(DC) # nombre quotidien de d\u00e9c\u00e8s lt=length(tt) # longueur de la s\u00e9rie temporelle (l=L-1) On utilise donc un intervalle de temps qui commence le 2 janvier 2020 : temps2=seq.Date(from=as.Date(\"2020-01-02\"), to=as.Date(\"2020-03-17\"), by=\"days\") On affiche les tests quotidiens en fonction du temps : plot(temps2,tt,xlab=\"Date (Annee 2020)\",ylab=\"Nombre de tests quotidiens\",col=\"black\") points(temps2,tp,col=\"red\") legend(\"topleft\",c(\"Nombre de tests positifs\",\"Nombre de tests realises\"), fill=c(\"red\",'black')) title(\"Resultats des tests quotidiens realises de covid 19\") On affiche le taux de positivit\u00e9 quotidien : pp=tp/tt # Proportion quotidienne de tests positifs plot(temps2,pp,xlab=\"Date (Annee 2020)\",ylab=\"Proportion de tests quotidiens positifs\",col=\"purple\") title(\"Proportion de tests positifs en fonction du temps\") On affiche les d\u00e9c\u00e8s quotidiens en fonction du temps : plot(temps2,dc,xlab=\"Date (Annee 2020)\",ylab=\"Nombre de morts\",col=\"orange\") title(\"Morts quotidiens du covid 19\") Ajustement du mod\u00e8le aux donn\u00e9es Les param\u00e8tres du mod\u00e8le sont : N=67e6; # Taille totale de la pop fran\u00e7aise gamma=1/10; # \"taux\" de guerison par jour (1/gamma est la periode infectieuse) R_0=3; # Reproductivite de la maladie beta=gamma*R_0; # R0=beta/alpha (estimation initiale \u00e0 optimiser) sigma=0.7;# Sensibilite des tests PCR # Probabilit\u00e9 relative pour les sensibles de se faire tester comparativement aux infect\u00e9s kappa=5e-3# (estimation initiale \u00e0 optimiser) Les conditions initiales du mod\u00e8le sont : I0=1; # On part d'un individu infect\u00e9. Ceci est fix\u00e9 pour la premiere flamb\u00e9e. R0=0; # On suppose que personne n'est immunis\u00e9 dans la population initialement. S0=N-I0-R0; # Nombre initial de sensibles (tout le monde sauf le premier infect\u00e9) X0=c(S0,I0); # Vecteur d'etat Cr\u00e9ons une fonction qui permet de simuler le mod\u00e8le SIR : SIR = function(t, X, P){ beta=P[1] # beta est le premier et unique \u00e9l\u00e9ment du vecteur des param\u00e8tres P # gamma est un param\u00e8tre dont la valeur est fix\u00e9e de fa\u00e7on globale S=X[1] # S est le premier \u00e9l\u00e9ment du vecteur d'\u00e9tat X I=X[2] # I est le second \u00e9l\u00e9ment du vecteur d'\u00e9tat X y=beta*S*I/N # y est le nombre de nouvelles infections par unit\u00e9 de temps dS = -y # dS/dt : variation du nombre d'individus sains dI = +y - gamma*I # dI/dt : variation du nombre d'individus infect\u00e9s dX=c(dS,dI) return(list(dX)) # la liste dX contient dS et dI les deriv\u00e9es de S et I } Cr\u00e9ons une fonction qui permet de calculer la vraisemblance associ\u00e9e \u00e0 un vecteur de param\u00e8tres \u00e0 optimiser \\theta = \\{ \\beta, \\kappa \\} . logLike = function(theta){ # theta est le vecteur des param\u00e8tres beta=theta[1] # beta est le premier \u00e9l\u00e9ment du vecteur theta kappa=theta[2] # kappa est le second \u00e9l\u00e9ment du vecteur theta X=ode(X0,t,SIR,beta) # la fonction ode renvoie les solutions du modele SIR avec beta pour param\u00e8tre # X0 est le vecteur des conditions initiales # t est le vecteur des dates d'observations # La fonction ode renvoie un matrice X de la forme : # 1\u00e8re colonne : t, 2\u00e8me colonne : S(t), 3\u00e8me colonne : I(t) # Proportion th\u00e9orique de tests quotidiens positifs (information issue du modele) p=sigma*X[,3]/(X[,3]+kappa*X[,2]) # On met des zeros avant t0 (en pratique 1e-12 pour eviter log(0) plus bas) p=c(rep(1e-12,t0-1),p) # Probabilite d observer \"tp\" positifs sachant le nombre de tests \"tt\" # et \"p(t)\" telle que donn\u00e9e par le mod\u00e8le (loi binomiale de parametre \"pt\") L=dbinom(tp, tt, p, log=TRUE) # Vecteur des vraisemblances (likelihood) #Log = TRUE car on travaille sur la log-vraisemblance LL=sum(L) # Le log transforme le produit des probabilit\u00e9s en somme return(LL) # renvoie la Log-vraisemblance associ\u00e9e au jeu de param\u00e8tres theta } En plus des param\u00e8tres \\beta et \\kappa , nous souhaitons estimer la date initiale de l'\u00e9pid\u00e9mie, t_0 , telle que I(t_0)=I_0=1 . Comme t_0 est un entier, nous le traitons s\u00e9par\u00e9ment via une boucle d'optimisation qui parcours tous les t_0 possibles du 2 janvier au 1er f\u00e9vrier. V=-1e6 # Valeur initiale de la vraisemblance (\u00e0 maximiser) for (t0 in 1:31){ # Boucle d'optimisation sur les t0 t=t0:lt # Vecteur temps : dates sur lesquelles on simule le mod\u00e8le theta0=c(beta,kappa) # Vecteur des parametres a estimer (estimations initiales) opt=optim(theta0,logLike,control=list(fnscale=-1)); # Part d'un point de depart theta0 et suit la plus forte pente (le gradient de la log-vraisemblance en fonction de theta) jusqu'\u00e0 maximiser la log-vraisemblance (localement) # Selon le point theta0 de d\u00e9part que l'on donne le maximum local renvoy\u00e9 peut varier if (opt$value>V){ #Si le t0 consid\u00e9r\u00e9 augmente la vraisemblance, V=opt$value #on sauvegarde la vraisemblance ainsi que t0, beta et gamma. t0opt=t0 beta=opt$par[1] kappa=opt$par[2] } } On affiche les param\u00e8tres optimaux obtenus : print(t0opt) print(kappa) print(beta) On trouve t_0 = 22 jours (soit le 23 janvier), \\kappa \\approx .0004 , \\beta \\approx 0.3 , ce qui permet d'estimer la reproductivit\u00e9 du virus ( \\mathcal{R}_0 ), d\u00e9finie comme le nombre d'infections secondaires g\u00e9n\u00e9r\u00e9es par un individu infect\u00e9 dans une population initialement na\u00efve : \\mathcal{R}_0 = \\frac{\\beta}{\\alpha+\\gamma}\\approx \\frac{\\beta}{\\gamma} \\approx 3\\,, \u200b puisque \\gamma=0.1 par jour. Ces estimations sont coh\u00e9rentes avec celles obtenues par Roques et al 2020 . t=t0opt:lt # nouveau vecteur temps X=ode(X0,t,SIR,beta) # simulation du mod\u00e8le SIR La proportion th\u00e9orique de tests quotidiens positifs est : p=sigma*X[,3]/(X[,3]+kappa*X[,2]) # p(t) = sigma I(t)/(I(t) + kappa S(t)) Les tests positifs cumul\u00e9s observ\u00e9s sont : Sigma1=cumsum(tp[t]) # on reprend les notations de l'article Roques et al (2020) Tests positifs cumul\u00e9s th\u00e9oriques sont : Sigma2=cumsum(tt[t]*p) # on reprend les notations de l'article Roques et al (2020) On d\u00e9finit la premi\u00e8re flamb\u00e9e entre le 22 janvier et le 17 mars 2020 : temps3=seq.Date(from=as.Date(\"2020-01-23\"), to=as.Date(\"2020-03-17\"), by=\"days\") On affiche le nombre de tests positifs cumul\u00e9s en fonction du temps : plot(temps3,Sigma1,xlab=\"Date (Annee 2020)\",ylab=\"Nombre de tests positifs cumules\",col=\"black\") lines(temps3,Sigma2, col='red') legend(\"topleft\",c(\"D'apres les donnees\",\"D'apres le modele\"),fill=c('black','red')) title(\"Comparaison des tests positifs cumules des donnees et du modele\") On retrouve le graphe de l\u2019article Roques et al 2020 (Fig. 1) donc l\u2019article est bien reproductible. On affiche le nombre de cas infectieux I(t) et infect\u00e9s (N-S(t)) en fonction du temps : plot(temps3,N-X[,2],col=\"red\",type=\"l\",xlab=\"Date (Annee 2020)\",ylab=\"Nombre de personnes\") lines(temps3,X[,3],col=\"purple\") lines(temps3,Sigma2) points(temps3,Sigma1) legend(\"topleft\",c(\"Nombre de personnes infectees\",\"Nombre de personnes infectieuses\",\"Nombre de personnes testees positives d'apres les donnees (points)\",\"d'apres le modele (courbe)\"),fill=c('red','purple','black','black'),cex=0.8) title(\"Evolution de la pandemie en France lors de la premiere flambee\") On retrouve approximativement la Figure 2 de l\u2019article Roques et al 2020 . On affiche le taux de positivit\u00e9 quotidien : plot(temps3,pp[t],xlab=\"Date (Ann\u00e9e 2020)\",ylab=\"Proportion de tests quotidiens positifs\") lines(temps3,p) legend(\"topleft\",c(\"D'apr\u00e8s les donn\u00e9es (points)\",\"D'apr\u00e8s le mod\u00e8le (courbe)\"),) title(\"Evolution de la proportion de tests positifs dans le temps\") Estimation du taux de l\u00e9talit\u00e9 Le taux de l\u00e9talit\u00e9 moyen (IFR pour infection fatality ratio ) est la proportion de morts parmi les personnes infect\u00e9es ou la probabilit\u00e9 de mourir des suites de l'infection : \\mbox{IFR}(t)=\\frac{\\alpha(t)}{\\alpha(t)+\\gamma}\\,. Nous ne supposons pas qu'il est constant au cours de l'\u00e9pid\u00e9mie. On estime \\alpha(t) (le taux de mortalit\u00e9 due \u00e0 la maladie) via la relation suivante : \\alpha(t)=\\frac{1}{I(t)}\\frac{\\mathrm{d} D(t)}{\\mathrm{d} t}\\,, o\u00f9 \\mathrm{d}D(t)/\\mathrm{d}t est le nombre de d\u00e9c\u00e8s quotidien. dc=dc[-(1:(t0opt-1))] # toncation des donn\u00e9es de d\u00e9c\u00e8s \u00e0 partir de t0 alpha=dc/X[,3] # estimation de alpha(t) = [dD(t)/dt]/I(t) IFR=alpha/(gamma+alpha) # taux de l\u00e9talit\u00e9 (infection fatality ratio) On affiche le taux de l\u00e9talit\u00e9 (IFR) brut : plot(temps3, IFR, type =\"l\", xlab=\"Date (Annee 2020)\", ylab=\"IFR\") On r\u00e9alise une moyenne de l\u2019IFR sur les valeurs non nulles : w=which(IFR!=0) print(mean(IFR[w])) On obtient un IFR de 0.67%. Cette valeur est comparable \u00e0 celles estim\u00e9es par Roques et al 2020 . On lisse la sortie en faisant une moyenne mobile sur 5 jours : IFRlisse <- rollmean(IFR, k=5, fill=NA) #fill=NA remplit les valeurs manquantes en raison de la fonction rollmean par des NA plot(temps3, IFRlisse, type =\"l\", xlab=\"Date (Ann\u00e9e 2020)\", ylab=\"IFR\",ylim=c(0,0.01)) points(temps3, IFR ) title(\"Evolution de l'IFR (ratio de l\u00e9talit\u00e9) lors de la premi\u00e8re flamb\u00e9e\") legend(\"topleft\",c(\"D'apr\u00e8s l'IFR brut (points)\",\"D'apr\u00e8s IFR liss\u00e9 (courbe)\")) Nous obtenons des valeurs d\u2019IFR du m\u00eame ordre de grandeur (0.8%) et de tendance comparable \u00e0 l'article de Roques et al 2020 .","title":"TD2 (Janvier-Mars 2020)"},{"location":"TD2/#introduction-a-la-modelisation-en-epidemiologie-covid-19-1ere-flambee-estimation-du-taux-de-letalite","text":"Marie Joigneau, Sabine Lobligeois, Louise Belamy, Maimouna Diarra (M1 Agro Rennes), le 14 mars 2021. Edit\u00e9 par Fr\u00e9d\u00e9ric Hamelin et Marine Dorand (M1 MODE), le 23 avril 2021. On se base sur l\u2019\u00e9tude de l\u2019article suivant : Roques et al. (2020) Using Early Data to Estimate the Actual Infection Fatality Ratio from COVID-19 in France . Le but de notre \u00e9tude est de reproduire les r\u00e9sultats de l\u2019article avec les donn\u00e9es de morts actualis\u00e9es et publi\u00e9es par Sant\u00e9 Publique France .","title":"Introduction \u00e0 la mod\u00e9lisation en \u00e9pid\u00e9miologie : COVID-19 - 1\u00e8re flamb\u00e9e - estimation du taux de l\u00e9talit\u00e9"},{"location":"TD2/#modele-epidemiologique","text":"Dans ce TD, nous allons mod\u00e9liser la croissance initiale de l'\u00e9pid\u00e9mie de COVID19 en France sur la base des donn\u00e9es de tests dans un premier temps. Les donn\u00e9es concernant les d\u00e9c\u00e8s seront utilis\u00e9es dans un second temps pour estimer le taux de l\u00e9talit\u00e9 de la maladie au d\u00e9but de l'ann\u00e9e 2020 en France. Les variables du mod\u00e8le sont : S(t) : le nombre de personnes sensibles au temps t , I(t) : le nombre de personnes infect\u00e9es et infectieuses, R(t) : le nombre de personnes r\u00e9tablies ou gu\u00e9ries, D(t) : le nombre de personnes d\u00e9c\u00e9d\u00e9es. La taille de la population est N=S+I+R . Les param\u00e8tres du mod\u00e8les sont \\beta : le taux de transmission de la maladie, \\gamma : le taux de gu\u00e9rison, \\alpha : le taux de mortalit\u00e9 due \u00e0 la maladie. Ce sont des \"taux\" par unit\u00e9 de temps. Le mod\u00e8le s'\u00e9crit : \\begin{eqnarray} \\frac{\\mathrm{d}S}{\\mathrm{d}t}&=&-\\beta \\frac{I}{N}S\\,,\\\\ \\frac{\\mathrm{d}I}{\\mathrm{d}t}&=&\\beta \\frac{I}{N}S - (\\alpha+\\gamma)I\\,,\\\\ \\frac{\\mathrm{d}R}{\\mathrm{d}t}&=&\\gamma I\\,,\\\\ \\frac{\\mathrm{d}D}{\\mathrm{d}t}&=&\\alpha I\\,. \\end{eqnarray} Pour simplifier l'\u00e9tude, nous faisons l'hypoth\u00e8se que le taux de mortalit\u00e9 due \u00e0 la maladie est tr\u00e8s faible et n\u00e9gligeable d'un point de vue \u00e9pid\u00e9miologique devant le taux de gu\u00e9rison (\\alpha\\ll \\gamma) . Cela permet de d\u00e9composer le mod\u00e8le en deux parties, la premi\u00e8re \u00e9tant ind\u00e9pendante des d\u00e9c\u00e8s : \\begin{eqnarray} \\frac{\\mathrm{d}S}{\\mathrm{d}t}&=&-\\beta \\frac{I}{N}S\\,,\\\\ \\frac{\\mathrm{d}I}{\\mathrm{d}t}&\\approx&\\beta \\frac{I}{N}S -\\gamma I\\,,\\\\ \\frac{\\mathrm{d}R}{\\mathrm{d}t}&=&\\gamma I\\,. \\end{eqnarray} Elle sera ajust\u00e9e aux donn\u00e9es de tests. La seconde partie du mod\u00e8le sera ajust\u00e9e aux donn\u00e9es de d\u00e9c\u00e8s : \\begin{eqnarray} \\frac{\\mathrm{d}D}{\\mathrm{d}t}&=&\\alpha I\\,. \\end{eqnarray}","title":"Mod\u00e8le \u00e9pid\u00e9miologique"},{"location":"TD2/#modele-dobservation","text":"L'ajustement du mod\u00e8le se fera par maximisation de la vraisemblance. Cette m\u00e9thode consiste \u00e0 maximiser la probabilit\u00e9 des observations sachant les param\u00e8tres. Le mod\u00e8le d'observation d\u00e9finit la probabilit\u00e9 qu'un test soit positif au temps t\u200b d'apr\u00e8s le mod\u00e8le \u00e9pid\u00e9miologique : p(t)=\\frac{\\sigma I(t)}{I(t)+\\kappa S(t)}\\,, o\u00f9 \\sigma \u200b est la sensibilit\u00e9 des tests PCR (suppos\u00e9e connue) et \\kappa est probabilit\u00e9 relative pour les individus sensibles de se faire tester comparativement aux infect\u00e9s (\u00e0 estimer). Aussi, le nombre de tests positifs le jour t peut \u00eatre mod\u00e9lis\u00e9 comme un tirage dans une loi Binomiale de param\u00e8tres p(t) et n(t) (le nombre de tests r\u00e9alis\u00e9s le jour t ) : le nombre de nouveaux cas observ\u00e9s le jour t est c(t)\\sim \\mbox{Binomial}(n(t),p(t)) En admettant que les observations sont ind\u00e9pendantes conditionnellement au mod\u00e8le, la vraisemblance ( likelihood en anglais) s'\u00e9crit : \\mbox{Like}(\\theta)=\\prod_{t=0}^{T} \\mbox{Prob}(\\mbox{observe }c(t)|\\mbox{ model predicts }p(t))\\,. Soit \\theta = \\{ \\beta, \\kappa \\} le vecteur des param\u00e8tres \u00e0 estimer. Rechercher les valeurs de \\theta qui maximisent la vraisemblance est \u00e9quivalent \u00e0 rechercher les valeurs de \\theta qui maximisent la log-vraisemblance, qui transforme le produit en somme : \\mbox{logLike}(\\theta)=\\log(\\mbox{Like}(\\theta))=\\sum_{t=0}^T \\log\\left (\\mbox{Prob}(\\mbox{observe }c(t)|\\mbox{ model predicts } p(t) )\\right)\\,. Nous travaillerons avec la log-vraisemblance.","title":"Mod\u00e8le d'observation"},{"location":"TD2/#traitement-des-donnees","text":"Commen\u00e7ons par nettoyer l'environnement de travail : rm(list=ls()) # Efface les variables cr\u00e9\u00e9es lors des ex\u00e9cutions pr\u00e9c\u00e9dentes graphics.off() # Ferme les fen\u00eatres ouvertes lors des ex\u00e9cutions pr\u00e9c\u00e9dentes On charge les librairies suivantes : library(deSolve) # pour r\u00e9soudre le syst\u00e8me d'\u00e9quations diff\u00e9rentielles (mod\u00e8le SIRD) library(R.matlab) # pour lire les fichiers de donn\u00e9es au format matlab library(downloader) # pour faciliter le t\u00e9l\u00e9chargement des donn\u00e9es library(zoo) # pour la moyenne mobile library(readr) # pour utiliser la fonction read_csv On t\u00e9l\u00e9charge l'archive contenant les donn\u00e9es utilis\u00e9es par Roques et al 2020 : download(\"https://www.mdpi.com/2079-7737/9/5/97/s1\", dest=\"suppMat.zip\", mode=\"wb\") On d\u00e9compresse l'archive : unzip(\"suppMat.zip\", exdir = \"suppMat\") On r\u00e9cup\u00e8re les donn\u00e9es relatives aux tests (du 1er janvier au 17 mars) : dataT = readMat(\"./suppMat/data_smooth5.mat\") TP=as.integer(dataT$DATA[1,]) # nombre de tests positifs cumul\u00e9s TT=as.integer(dataT$DATA[2,]) # nombre total de tests cumul\u00e9s LT=length(TP) # Longueur de la s\u00e9rie temporelle On r\u00e9cup\u00e8re les donn\u00e9es relatives aux d\u00e9c\u00e8s (\u00e0 partir du 2 mars) : dataD <- read_csv(url(\"https://www.data.gouv.fr/fr/datasets/r/d3a98a30-893f-47f7-96c5-2f4bcaaa0d71\")) dataD[is.na(dataD)]=0 # on remplace les donn\u00e9es manquantes par des z\u00e9ros avant de sommer DC=dataD$total_deces_hopital+dataD$total_deces_ehpad # nombre de d\u00e9c\u00e8s cumul\u00e9s On cr\u00e9e un vecteur des d\u00e9c\u00e8s cumul\u00e9s du 1er janvier au 17 mars : # Les donn\u00e9es de d\u00e9c\u00e8s sont disponible \u00e0 partir du 2 mars n=31+29+1 # nombre de jours en janvier + f\u00e9vrier 2020 + 1 mars zeros=rep(0,n) # nombre de z\u00e9ros \u00e0 ajouter pour janvier/f\u00e9vrier m=17-1 # la fen\u00eatre de l'\u00e9tude s'arr\u00eate au 17 mars DC = c(zeros,DC[1:m]) # les d\u00e9c\u00e8s cumul\u00e9s du 1er janvier au 17 mars On cr\u00e9e un vecteur pour le taux de positivit\u00e9 cumul\u00e9 : PP=TP/TT # taux de positivit\u00e9 cumul\u00e9 On cr\u00e9e un vecteur temps : temps=seq.Date(from=as.Date(\"2020-01-01\"), to=as.Date(\"2020-03-17\"), by=\"days\") On affiche les tests cumul\u00e9s en fonction du temps : plot(temps,TT,xlab=\"Date (Annee 2020)\",ylab=\"Nombre de tests\",col=\"black\") points(temps,TP,col=\"red\") legend(\"topleft\",c(\"Nombre de tests positifs\",\"Nombre de tests realises\"), fill=c(\"red\",\"black\")) title(\"Resultats cumules des tests realises de covid 19\") On affiche la proportion de tests positifs en fonction du temps : plot(temps,PP,xlab=\"Date (Annee 2020)\",ylab=\"Proportion de tests positifs\",col=\"purple\") title(\"Proportion de tests positifs en fonction du temps\") On affiche les d\u00e9c\u00e8s cumul\u00e9s en fonction du temps : plot(temps,DC,xlab=\"Date (Annee 2020)\",ylab=\"Nombre de morts\",col=\"orange\") title(\"Morts cumules du covid 19\") On retrouve les donn\u00e9es non-cumul\u00e9es en utilisant la fonction diff : tt=diff(TT) # nombre quotidien de tests r\u00e9alis\u00e9s tp=diff(TP) # nombre quotidien de tests positifs dc=diff(DC) # nombre quotidien de d\u00e9c\u00e8s lt=length(tt) # longueur de la s\u00e9rie temporelle (l=L-1) On utilise donc un intervalle de temps qui commence le 2 janvier 2020 : temps2=seq.Date(from=as.Date(\"2020-01-02\"), to=as.Date(\"2020-03-17\"), by=\"days\") On affiche les tests quotidiens en fonction du temps : plot(temps2,tt,xlab=\"Date (Annee 2020)\",ylab=\"Nombre de tests quotidiens\",col=\"black\") points(temps2,tp,col=\"red\") legend(\"topleft\",c(\"Nombre de tests positifs\",\"Nombre de tests realises\"), fill=c(\"red\",'black')) title(\"Resultats des tests quotidiens realises de covid 19\") On affiche le taux de positivit\u00e9 quotidien : pp=tp/tt # Proportion quotidienne de tests positifs plot(temps2,pp,xlab=\"Date (Annee 2020)\",ylab=\"Proportion de tests quotidiens positifs\",col=\"purple\") title(\"Proportion de tests positifs en fonction du temps\") On affiche les d\u00e9c\u00e8s quotidiens en fonction du temps : plot(temps2,dc,xlab=\"Date (Annee 2020)\",ylab=\"Nombre de morts\",col=\"orange\") title(\"Morts quotidiens du covid 19\")","title":"Traitement des donn\u00e9es"},{"location":"TD2/#ajustement-du-modele-aux-donnees","text":"Les param\u00e8tres du mod\u00e8le sont : N=67e6; # Taille totale de la pop fran\u00e7aise gamma=1/10; # \"taux\" de guerison par jour (1/gamma est la periode infectieuse) R_0=3; # Reproductivite de la maladie beta=gamma*R_0; # R0=beta/alpha (estimation initiale \u00e0 optimiser) sigma=0.7;# Sensibilite des tests PCR # Probabilit\u00e9 relative pour les sensibles de se faire tester comparativement aux infect\u00e9s kappa=5e-3# (estimation initiale \u00e0 optimiser) Les conditions initiales du mod\u00e8le sont : I0=1; # On part d'un individu infect\u00e9. Ceci est fix\u00e9 pour la premiere flamb\u00e9e. R0=0; # On suppose que personne n'est immunis\u00e9 dans la population initialement. S0=N-I0-R0; # Nombre initial de sensibles (tout le monde sauf le premier infect\u00e9) X0=c(S0,I0); # Vecteur d'etat Cr\u00e9ons une fonction qui permet de simuler le mod\u00e8le SIR : SIR = function(t, X, P){ beta=P[1] # beta est le premier et unique \u00e9l\u00e9ment du vecteur des param\u00e8tres P # gamma est un param\u00e8tre dont la valeur est fix\u00e9e de fa\u00e7on globale S=X[1] # S est le premier \u00e9l\u00e9ment du vecteur d'\u00e9tat X I=X[2] # I est le second \u00e9l\u00e9ment du vecteur d'\u00e9tat X y=beta*S*I/N # y est le nombre de nouvelles infections par unit\u00e9 de temps dS = -y # dS/dt : variation du nombre d'individus sains dI = +y - gamma*I # dI/dt : variation du nombre d'individus infect\u00e9s dX=c(dS,dI) return(list(dX)) # la liste dX contient dS et dI les deriv\u00e9es de S et I } Cr\u00e9ons une fonction qui permet de calculer la vraisemblance associ\u00e9e \u00e0 un vecteur de param\u00e8tres \u00e0 optimiser \\theta = \\{ \\beta, \\kappa \\} . logLike = function(theta){ # theta est le vecteur des param\u00e8tres beta=theta[1] # beta est le premier \u00e9l\u00e9ment du vecteur theta kappa=theta[2] # kappa est le second \u00e9l\u00e9ment du vecteur theta X=ode(X0,t,SIR,beta) # la fonction ode renvoie les solutions du modele SIR avec beta pour param\u00e8tre # X0 est le vecteur des conditions initiales # t est le vecteur des dates d'observations # La fonction ode renvoie un matrice X de la forme : # 1\u00e8re colonne : t, 2\u00e8me colonne : S(t), 3\u00e8me colonne : I(t) # Proportion th\u00e9orique de tests quotidiens positifs (information issue du modele) p=sigma*X[,3]/(X[,3]+kappa*X[,2]) # On met des zeros avant t0 (en pratique 1e-12 pour eviter log(0) plus bas) p=c(rep(1e-12,t0-1),p) # Probabilite d observer \"tp\" positifs sachant le nombre de tests \"tt\" # et \"p(t)\" telle que donn\u00e9e par le mod\u00e8le (loi binomiale de parametre \"pt\") L=dbinom(tp, tt, p, log=TRUE) # Vecteur des vraisemblances (likelihood) #Log = TRUE car on travaille sur la log-vraisemblance LL=sum(L) # Le log transforme le produit des probabilit\u00e9s en somme return(LL) # renvoie la Log-vraisemblance associ\u00e9e au jeu de param\u00e8tres theta } En plus des param\u00e8tres \\beta et \\kappa , nous souhaitons estimer la date initiale de l'\u00e9pid\u00e9mie, t_0 , telle que I(t_0)=I_0=1 . Comme t_0 est un entier, nous le traitons s\u00e9par\u00e9ment via une boucle d'optimisation qui parcours tous les t_0 possibles du 2 janvier au 1er f\u00e9vrier. V=-1e6 # Valeur initiale de la vraisemblance (\u00e0 maximiser) for (t0 in 1:31){ # Boucle d'optimisation sur les t0 t=t0:lt # Vecteur temps : dates sur lesquelles on simule le mod\u00e8le theta0=c(beta,kappa) # Vecteur des parametres a estimer (estimations initiales) opt=optim(theta0,logLike,control=list(fnscale=-1)); # Part d'un point de depart theta0 et suit la plus forte pente (le gradient de la log-vraisemblance en fonction de theta) jusqu'\u00e0 maximiser la log-vraisemblance (localement) # Selon le point theta0 de d\u00e9part que l'on donne le maximum local renvoy\u00e9 peut varier if (opt$value>V){ #Si le t0 consid\u00e9r\u00e9 augmente la vraisemblance, V=opt$value #on sauvegarde la vraisemblance ainsi que t0, beta et gamma. t0opt=t0 beta=opt$par[1] kappa=opt$par[2] } } On affiche les param\u00e8tres optimaux obtenus : print(t0opt) print(kappa) print(beta) On trouve t_0 = 22 jours (soit le 23 janvier), \\kappa \\approx .0004 , \\beta \\approx 0.3 , ce qui permet d'estimer la reproductivit\u00e9 du virus ( \\mathcal{R}_0 ), d\u00e9finie comme le nombre d'infections secondaires g\u00e9n\u00e9r\u00e9es par un individu infect\u00e9 dans une population initialement na\u00efve : \\mathcal{R}_0 = \\frac{\\beta}{\\alpha+\\gamma}\\approx \\frac{\\beta}{\\gamma} \\approx 3\\,, \u200b puisque \\gamma=0.1 par jour. Ces estimations sont coh\u00e9rentes avec celles obtenues par Roques et al 2020 . t=t0opt:lt # nouveau vecteur temps X=ode(X0,t,SIR,beta) # simulation du mod\u00e8le SIR La proportion th\u00e9orique de tests quotidiens positifs est : p=sigma*X[,3]/(X[,3]+kappa*X[,2]) # p(t) = sigma I(t)/(I(t) + kappa S(t)) Les tests positifs cumul\u00e9s observ\u00e9s sont : Sigma1=cumsum(tp[t]) # on reprend les notations de l'article Roques et al (2020) Tests positifs cumul\u00e9s th\u00e9oriques sont : Sigma2=cumsum(tt[t]*p) # on reprend les notations de l'article Roques et al (2020) On d\u00e9finit la premi\u00e8re flamb\u00e9e entre le 22 janvier et le 17 mars 2020 : temps3=seq.Date(from=as.Date(\"2020-01-23\"), to=as.Date(\"2020-03-17\"), by=\"days\") On affiche le nombre de tests positifs cumul\u00e9s en fonction du temps : plot(temps3,Sigma1,xlab=\"Date (Annee 2020)\",ylab=\"Nombre de tests positifs cumules\",col=\"black\") lines(temps3,Sigma2, col='red') legend(\"topleft\",c(\"D'apres les donnees\",\"D'apres le modele\"),fill=c('black','red')) title(\"Comparaison des tests positifs cumules des donnees et du modele\") On retrouve le graphe de l\u2019article Roques et al 2020 (Fig. 1) donc l\u2019article est bien reproductible. On affiche le nombre de cas infectieux I(t) et infect\u00e9s (N-S(t)) en fonction du temps : plot(temps3,N-X[,2],col=\"red\",type=\"l\",xlab=\"Date (Annee 2020)\",ylab=\"Nombre de personnes\") lines(temps3,X[,3],col=\"purple\") lines(temps3,Sigma2) points(temps3,Sigma1) legend(\"topleft\",c(\"Nombre de personnes infectees\",\"Nombre de personnes infectieuses\",\"Nombre de personnes testees positives d'apres les donnees (points)\",\"d'apres le modele (courbe)\"),fill=c('red','purple','black','black'),cex=0.8) title(\"Evolution de la pandemie en France lors de la premiere flambee\") On retrouve approximativement la Figure 2 de l\u2019article Roques et al 2020 . On affiche le taux de positivit\u00e9 quotidien : plot(temps3,pp[t],xlab=\"Date (Ann\u00e9e 2020)\",ylab=\"Proportion de tests quotidiens positifs\") lines(temps3,p) legend(\"topleft\",c(\"D'apr\u00e8s les donn\u00e9es (points)\",\"D'apr\u00e8s le mod\u00e8le (courbe)\"),) title(\"Evolution de la proportion de tests positifs dans le temps\")","title":"Ajustement du mod\u00e8le aux donn\u00e9es"},{"location":"TD2/#estimation-du-taux-de-letalite","text":"Le taux de l\u00e9talit\u00e9 moyen (IFR pour infection fatality ratio ) est la proportion de morts parmi les personnes infect\u00e9es ou la probabilit\u00e9 de mourir des suites de l'infection : \\mbox{IFR}(t)=\\frac{\\alpha(t)}{\\alpha(t)+\\gamma}\\,. Nous ne supposons pas qu'il est constant au cours de l'\u00e9pid\u00e9mie. On estime \\alpha(t) (le taux de mortalit\u00e9 due \u00e0 la maladie) via la relation suivante : \\alpha(t)=\\frac{1}{I(t)}\\frac{\\mathrm{d} D(t)}{\\mathrm{d} t}\\,, o\u00f9 \\mathrm{d}D(t)/\\mathrm{d}t est le nombre de d\u00e9c\u00e8s quotidien. dc=dc[-(1:(t0opt-1))] # toncation des donn\u00e9es de d\u00e9c\u00e8s \u00e0 partir de t0 alpha=dc/X[,3] # estimation de alpha(t) = [dD(t)/dt]/I(t) IFR=alpha/(gamma+alpha) # taux de l\u00e9talit\u00e9 (infection fatality ratio) On affiche le taux de l\u00e9talit\u00e9 (IFR) brut : plot(temps3, IFR, type =\"l\", xlab=\"Date (Annee 2020)\", ylab=\"IFR\") On r\u00e9alise une moyenne de l\u2019IFR sur les valeurs non nulles : w=which(IFR!=0) print(mean(IFR[w])) On obtient un IFR de 0.67%. Cette valeur est comparable \u00e0 celles estim\u00e9es par Roques et al 2020 . On lisse la sortie en faisant une moyenne mobile sur 5 jours : IFRlisse <- rollmean(IFR, k=5, fill=NA) #fill=NA remplit les valeurs manquantes en raison de la fonction rollmean par des NA plot(temps3, IFRlisse, type =\"l\", xlab=\"Date (Ann\u00e9e 2020)\", ylab=\"IFR\",ylim=c(0,0.01)) points(temps3, IFR ) title(\"Evolution de l'IFR (ratio de l\u00e9talit\u00e9) lors de la premi\u00e8re flamb\u00e9e\") legend(\"topleft\",c(\"D'apr\u00e8s l'IFR brut (points)\",\"D'apr\u00e8s IFR liss\u00e9 (courbe)\")) Nous obtenons des valeurs d\u2019IFR du m\u00eame ordre de grandeur (0.8%) et de tendance comparable \u00e0 l'article de Roques et al 2020 .","title":"Estimation du taux de l\u00e9talit\u00e9"},{"location":"TD3/","text":"Introduction \u00e0 la mod\u00e9lisation en \u00e9pid\u00e9miologie : COVID-19 - dynamique \u00e9pid\u00e9mique pendant le 1er confinement Fr\u00e9d\u00e9ric Hamelin, le 10 mai 2020. Mis \u00e0 jour le 30 mars 2021 d'apr\u00e8s l' application de Maimouna Diarra (\u00e9l\u00e8ve ing\u00e9nieure M1 Agro Rennes 2021) bas\u00e9e sur la version pr\u00e9c\u00e9dente du TD. Dans l'\u00e9pid\u00e9mie de COVID-19, les individus infect\u00e9s peuvent \u00eatre symptomatiques ou asymptomatiques. Les donn\u00e9es sur le nombre d'individus infect\u00e9s dans la population sont peu fiables car elles d\u00e9pendent des tests \u00e9ventuellement r\u00e9alis\u00e9s. Les individus symptomatiques peuvent faire une forme s\u00e9v\u00e8re de la maladie et \u00eatre hospitalis\u00e9s. Les donn\u00e9es concernant les individus hospitalis\u00e9s sont fiables en principe. Mod\u00e8le \u00e9pid\u00e9miologique Nous ferons un certain nombre d'hypoth\u00e8ses volontairement grossi\u00e8res pour simplifier l'\u00e9tude en premi\u00e8re approximation. Ces hypoth\u00e8ses incluent : la population fran\u00e7aise est spatialement homog\u00e8ne en France m\u00e9tropolitaine, les hommes et les femmes sont \u00e9gaux vis-\u00e0-vis du virus, la structure en \u00e2ge de la population peut \u00eatre ignor\u00e9e pour mod\u00e9liser l'\u00e9pid\u00e9mie, les individus hospitalis\u00e9s ne transmettent plus l'infection, la gu\u00e9rison conf\u00e8re une immunit\u00e9 permanente. Ces hypoth\u00e8ses sont plus que grossi\u00e8res mais permettent n\u00e9anmoins de commencer \u00e0 travailler. Techniquement, cela nous permettra de limiter le nombre de param\u00e8tres \u00e0 estimer. Autrement, le mod\u00e8le risquerait d'\u00eatre sur-param\u00e9tr\u00e9 au regard des donn\u00e9es et des connaissances dont on dispose sur le virus. Nous d\u00e9finissons les variables S(t) : nombre d'individus sensibles au virus (non-infect\u00e9s) \u00e0 la date t\u200b , I(t) : nombre d'individus infect\u00e9s et infectieux non-hospitalis\u00e9s \u00e0 la date t\u200b , H(t)\u200b : nombre d'individus infect\u00e9s hospitalis\u00e9s \u00e0 la date t\u200b , R(t)\u200b : nombre d'individus \"retir\u00e9s\" de l'\u00e9pid\u00e9mie (gu\u00e9ris et immunis\u00e9s ou d\u00e9c\u00e9d\u00e9s) \u00e0 la date t , et les param\u00e8tres \\beta\u200b : taux de transmission par unit\u00e9 de temps (fr\u00e9quence des contacts \u200b \\times\u200b probabilit\u00e9 d'infection), \\rho\u200b : taux de \"gu\u00e9rison\" par unit\u00e9 de temps (inverse du temps moyen avant gu\u00e9rison ou d\u00e9c\u00e8s), \\alpha\u200b : taux d'hospitalisation par unit\u00e9 de temps (inverse du temps moyen avant hospitalisation), \\gamma\u200b : taux de gu\u00e9rison ou d\u00e9c\u00e8s \u00e0 l'h\u00f4pital (inverse du temps moyen avant sortie de l'h\u00f4pital). Nous consid\u00e9rons le mod\u00e8le compartimental suivant : ce qui se traduit math\u00e9matiquement par le syst\u00e8me d'\u00e9quations diff\u00e9rentielles suivant : \\begin{eqnarray*} \\frac{\\mathrm{d} S}{\\mathrm{d} t} &=& -\\beta \\frac{S}{N} I\\,,\\\\ \\frac{\\mathrm{d} I}{\\mathrm{d} t} &=& +\\beta \\frac{S}{N} I - (\\alpha+\\rho) I\\,,\\\\ \\frac{\\mathrm{d} H}{\\mathrm{d} t} &=& \\alpha I - \\gamma H\\,,\\\\ \\frac{\\mathrm{d} R}{\\mathrm{d} t} &=& \\rho I+ \\gamma H\\,. \\end{eqnarray*} ce qui peut se lire comme suit : \\begin{eqnarray*} \\text{variation du nombre d'individus sensibles} &=& - \\text{ nouvelles infections}\\\\ \\text{variation du nombre d'individus infect\u00e9s} &=& + \\text{ nouvelles infections } - \\text{gu\u00e9risons} - \\text{hospitalisations}\\\\ \\text{variation du nombre d'individus hospitalis\u00e9s} &=& + \\text{ hospitalisations } - \\text{sorties suite \u00e0 gu\u00e9risons ou d\u00e9c\u00e8s}\\\\ \\text{variation du nombre d'individus retir\u00e9s} &=& + \\text{ gu\u00e9risons } + \\text{ sorties suite \u00e0 gu\u00e9risons ou d\u00e9c\u00e8s} \\end{eqnarray*} La taille de la population est d\u00e9finie comme N= S+I+H+R=\\mbox{constante}\\,. Chaque individu infect\u00e9 r\u00e9alise un certain nombre de contacts avec d'autres individus par unit\u00e9 de temps (c'est la fr\u00e9quence des contacts). Pour chaque contact, la probabilit\u00e9 de rencontrer un individu sensible est \u00e9gale \u00e0 la proportion que repr\u00e9sentent les individus sensibles dans la population : S/N\u200b . Ainsi le nombre de nouvelles infections par unit\u00e9 de temps est \\beta SI/N . La reproductivit\u00e9 du pathog\u00e8ne est d\u00e9fini comme \\mathcal R_0 = \\frac{\\beta}{\\alpha+\\rho}\\frac{S(0)}{N}\\,. C'est le nombre d'infections secondaires g\u00e9n\u00e9r\u00e9es par un individu infect\u00e9 dans la population initiale : si \\mathcal R_0>1\u200b une vague \u00e9pid\u00e9mique se forme. si \\mathcal R_0<1\u200b l'\u00e9pid\u00e9mie s'\u00e9teint progressivement. La probabilit\u00e9 d'\u00eatre hospitalis\u00e9 suite \u00e0 l'infection est p = \\frac{\\alpha}{\\alpha+\\rho}\\,. Nous allons maintenant tenter d'ajuster ce mod\u00e8le aux donn\u00e9es de COVID-19 en France sous R. Ces donn\u00e9es concernent le nombre de personnes hospitalis\u00e9es \u00e0 la date t\u200b , H(t)\u200b , ainsi que le nombre d'admissions \u00e0 l'h\u00f4pital \u00e0 la date t (par unit\u00e9 de temps) : A(t)=\\alpha I(t)\\,. Le mod\u00e8le \u00e9pid\u00e9miologique est \u00e0 base d'\u00e9quations diff\u00e9rentielles ordinaires ( ordinary differential equations ). Les simulations se baseront sur la fonction ode de la librairie deSolve de R \u00e0 importer en d\u00e9but de script. library(deSolve) # Import de la fonction ode Commen\u00e7ons par nettoyer l'environnement de travail : rm(list=ls()) # Efface les variables cr\u00e9\u00e9es lors des ex\u00e9cutions pr\u00e9c\u00e9dentes graphics.off() # Ferme les fen\u00eatres ouvertes lors des ex\u00e9cutions pr\u00e9c\u00e9dentes T\u00e9l\u00e9chargement et traitement des donn\u00e9es Les donn\u00e9es sont disponibles sur le site suivant : https://www.data.gouv.fr/fr/datasets/donnees-hospitalieres-relatives-a-lepidemie-de-covid-19/ Nous baserons notre travail sur les donn\u00e9es hospitali\u00e8res suivantes (\u00e0 la date du TD) : donnees-hospitalieres-covid19-2020-05-10-19h00.csv donnees-hospitalieres-nouveaux-covid19-2020-05-10-19h00.csv Importons les donn\u00e9es sous R : # Lien permanent vers les donn\u00e9es d'hospitalisations urlH = url(\"https://www.data.gouv.fr/fr/datasets/r/63352e38-d353-4b54-bfd1-f1b3ee1cabd7\") # Lien permanent vers les donn\u00e9es d'admissions urlA = url(\"https://www.data.gouv.fr/fr/datasets/r/6fadff46-9efd-4c53-942a-54aca783c30c\") # Nombre d'individus hospitalis\u00e9s (H) - \u00e0 partir du 19 mars dataH = read.csv2(urlH, header=TRUE, sep=\";\") # Nombre d'admissions (A) \u00e0 l'h\u00f4pital par jour dataA = read.csv2(urlA, header=TRUE, sep=\";\") V\u00e9rification de la nature des variables : str(dataH) # la fonction str () permet de nous renseigner sur la nature de chaque str(dataA) # variable contenue dans les tableaux On remarque que la variable \u201cjour\u201d est consid\u00e9r\u00e9e comme un facteur. Nous allons donc la convertir en date pour faciliter le triage des donn\u00e9es quand on a va d\u00e9finir la fen\u00eatre temporelle d'\u00e9tude. dataH$jour = as.Date(dataH$jour) # conversion de variable jour en date dataA$jour = as.Date(dataA$jour) La deuxi\u00e8me colonne du jeu de donn\u00e9es \"H\" distingue les hommes et les femmes par des 1 et des 2. Comme le mod\u00e8le n'est pas structur\u00e9 selon ces cat\u00e9gories, nous ne conserverons que les lignes 0 qui agr\u00e8gent hommes et femmes : dataH = dataH[dataH$sexe==0,] # pas de distinction entre les hommes et les femmes en selectionnant uniquement les lignes 0 de la colonne \"sexe\" Pour ce qui suit, nous ne conserverons que les informations relatives aux hospitalisations, d\u00e9c\u00e8s et gu\u00e9risons, par d\u00e9partements : dataH = dataH[,c(-2,-6,-7)] # on \u00e9limine les colonnes suivantes: \"sexe\", \"rad\" et \"dc\" dataA = dataA[,c(-4,-5,-6)] # on \u00e9limine \"incid_rea\", \"incid_dc\" et \"incid_rad\" Pour cette \u00e9tape, nous voulons s\u00e9lectionner uniquement les donn\u00e9es qui se trouvent entre le 19/03/2020 et le 11/05/2020 pour les d\u00e9partements m\u00e9tropolitains en excluant la Corse : # on d\u00e9finit notre fen\u00eatre temporelle dataH = dataH[dataH$jour>\"2020-03-19\" & dataH$jour<\"2020-05-11\", ] dataA = dataA[dataA$jour>\"2020-03-19\" & dataA$jour<\"2020-05-11\", ] # s\u00e9lection des d\u00e9partements m\u00e9tropolitains dataH = dataH[(dataH$dep!=\"971\")&(dataH$dep!=\"972\")&(dataH$dep!=\"973\")&(dataH$dep!=\"974\")&(dataH$dep!=\"976\")&(dataH$dep!=\"2A\")&(dataH$dep!=\"2B\"),] dataA = dataA[(dataA$dep!=\"971\")&(dataA$dep!=\"972\")&(dataA$dep!=\"973\")&(dataA$dep!=\"974\")&(dataA$dep!=\"976\")&(dataA$dep!=\"2A\")&(dataA$dep!=\"2B\"),] Agr\u00e9gation des donn\u00e9es \u00e0 l'\u00e9chelle de la France par jour : # on utilise la fonction aggregate pour additionner le nombre d'hospitalis\u00e9s par jour dataHH = aggregate(hosp ~ jour, data = dataH, FUN = sum) dataAA = aggregate(incid_hosp~ jour, data = dataA, FUN = sum) # idem pour les admissions Construction de 2 nouveaux vecteurs qui contiennent uniquement les donn\u00e9es qui nous int\u00e9ressent : H = dataHH[,c(2)] # vecteur des hospitalisations A = dataAA[,c(2)] # vecteur des admissions Construisons un vecteur temps qui va correspondre \u00e0 l'ordonn\u00e9e de nos graphiques : L = length(dataHH$jour) # longueur de la s\u00e9rie temporelle t = seq(0,L-1,1) # vecteur temps allant de 0 \u00e0 L par pas de 1 Affichons le nombre de personnes hospitalis\u00e9es en fonction du temps : plot(t,H,col=\"blue\",xlab=\"Temps \u00e9coul\u00e9 depuis le 19 mars (en jours)\", ylab=\"Nombre de personnes hospitalis\u00e9es\") Affichons les admissions quotidiennes en fonction du temps : plot(t,A,xlab=\"Temps \u00e9coul\u00e9 depuis le 19 mars (en jours)\", ylab=\"Nombre d'admissions \u00e0 l'h\u00f4pital (par jour)\",col=\"red\") Comme le confinement a d\u00e9but\u00e9 le 17 mars, la tendance croissante des deux premi\u00e8res semaines suit probablement une dynamique de transition suite \u00e0 la mise en place du confinement. Comme le mod\u00e8le \u00e9pid\u00e9miologique suppose que les param\u00e8tres \u00e9pid\u00e9miologiques sont constants, en particulier le taux de transmission du virus, nous commencerons les analyses 15 jours apr\u00e8s le d\u00e9but du confinement, soit \u00e0 partir du 1er avril : T0 = 13 # D\u00e9calage du point de d\u00e9part 13 jours apr\u00e8s le 19 mars (le 1er avril) H = H[T0:L];A=A[T0:L] # Troncations des donn\u00e9es L = length(H) # Mise \u00e0 jour de la longueur des s\u00e9ries temporelles t = seq(0,L-1,1) # et du vecteur temps Visualisation des donn\u00e9es tronqu\u00e9es \u00e0 partir du 1er avril : plot(t,H,xlab=\"Temps \u00e9coul\u00e9 depuis le 1er avril (en jours)\", ylab=\"Nombre de personnes hospitalis\u00e9es\",col=\"blue\") plot(t,A,xlab=\"Temps \u00e9coul\u00e9 depuis le 1er avril (en jours)\", ylab=\"Nombre d'admissions \u00e0 l'h\u00f4pital (par jour)\",col=\"red\") Simulations et ajustement du mod\u00e8le aux donn\u00e9es R\u00e9solution num\u00e9rique du mod\u00e8le \u00e9pid\u00e9miologique Commen\u00e7ons par d\u00e9finir les param\u00e8tres du mod\u00e8le \u00e9pid\u00e9miologique. Les valeurs donn\u00e9es aux param\u00e8tres \u00e0 estimer sont de grossi\u00e8res estimations initiales (ordres de grandeurs approximatifs). Pour que le probl\u00e8me d'estimation des param\u00e8tres soit bien pos\u00e9 (c'est-\u00e0-dire pour que le mod\u00e8le ne soit pas sur-param\u00e9tr\u00e9 par rapport aux donn\u00e9es utilis\u00e9es), il faut \u00e0 minima fixer la valeur d'un param\u00e8tre ( H. et al 2021 ). La p\u00e9riode infectieuse a \u00e9t\u00e9 estim\u00e9e \u00e0 10.91 jours en moyenne (avec un \u00e9cart-type de 3.95 jours) en Chine ( You et al 2020 ). Nous retiendrons la valeur moyenne. En pratique cependant, nous ne pourrons estimer que le nombre de personnes retir\u00e9es de la dynamique \u00e9pid\u00e9mique durant le confinement : R(t)-R(0)\u200b . Nous ne pourrons pas estimer la proportion de la population initialement immunis\u00e9e (ou retir\u00e9e) au 1er avril : R(0) . N\u00e9anmoins, les r\u00e9sultats que nous obtiendrons seront ind\u00e9pendants de la valeur initiale donn\u00e9e \u00e0 R(0) , comme vous pourrez le v\u00e9rifier. N = 64e6 # Population hexagonale approximative rho = 1/10 # Temps moyen avant gu\u00e9rison ou d\u00e9c\u00e8s : 10 jours gamma = 1/14 # Dur\u00e9e moyenne de l'hospitalisation : 14 jours R_0 = 1 # Reproductivit\u00e9 du virus en confinement beta = R_0*rho # Taux de transmission (calcul tr\u00e8s approximatif) p = 0.1 # Probabilit\u00e9 d'\u00eatre hospitalis\u00e9 suite \u00e0 l'infection alpha = p*rho/(1-p) # Taux d'hospitalisation P0 = c(beta,alpha,gamma) # Vecteur des param\u00e8tres D\u00e9finissons ensuite les variables du mod\u00e8le et les conditions initiales (au 1er avril) : H0 = H[1] # Le nombre de personnes hospitalis\u00e9es au 1er avril I0 = A[1]/alpha # Les admissions correspondent \u00e0 A(t) = alpha*I(t) R0 = N*0.01 # C'est la grande inconnue : mettons 1% d'immunis\u00e9s S0 = N-I0-H0-R0 # La taille de la population sensible au 1er avril X0 = c(S0,I0,H0)# Vecteur d'\u00e9tat - pas besoin de simuler R=N-(S+I+H) D\u00e9finissons la fonction SIHR qui prend en arguments 3 vecteurs : temps, variables d'\u00e9tats, et param\u00e8tres : SIHR = function(t, X, P){ beta = P[1] # Le taux de transmission alpha = P[2] # Le taux d'hospitalisation gamma = P[3] # Le taux de sortie d'h\u00f4pital S=X[1];I=X[2];H=X[3] # Le vecteur d'\u00e9tat X contient: S, I et H y = beta*S*I/N # Le nombre de nouvelles infections par jour dS = -y # On exprime dS/dt = - beta*S*I dI = y-(alpha+rho)*I # On exprime dI/dt = beta*S*I - (alpha+rho)*I dH = alpha*I -gamma*H # On exprime dH/dt = alpha*I - gamma*H dX=c(dS,dI,dH) # Renvoie dX/dt tel que demand\u00e9 par la fonction ode return(list(dX)) } Nous sommes int\u00e9ress\u00e9s par identifier les param\u00e8tres (\\alpha,\\beta,\\gamma\u200b) et l'\u00e9tat initial du syst\u00e8me (en particulier le nombre d'individus initialement infect\u00e9s I(0) dans la population) qui sont les plus vraisemblables d'apr\u00e8s les donn\u00e9es. La vraisemblance d'un jeu de param\u00e8tres et de conditions initiales \u00e0 estimer est la probabilit\u00e9 d'observer les donn\u00e9es sachant ces param\u00e8tres et conditions initiales. Pour pouvoir calculer cette probabilit\u00e9, il faut mod\u00e9liser le processus d'observation de fa\u00e7on stochastique (avec variables al\u00e9atoires). Mod\u00e8le d'observation Nous consid\u00e9rerons le mod\u00e8le d'observation le plus simple qui soit pour des donn\u00e9es de comptage : un tirage al\u00e9atoire dans une distribution de Poisson . Plus pr\u00e9cis\u00e9ment, nous consid\u00e9rerons que le nombre de nouvelles hospitalisations \u00e0 la date t est une variable al\u00e9atoire discr\u00e8te distribu\u00e9e selon une loi de Poisson de moyenne A(t)\u200b . De la m\u00eame fa\u00e7on, nous consid\u00e9rerons que le nombre de personnes hospitalis\u00e9es \u00e0 la date t \u200b est tir\u00e9 dans une loi de Poisson de moyenne \u200b H(t)\u200b (\u00e0 vrai dire, ce sont plut\u00f4t les sorties d'h\u00f4pital \u200b \\gamma H(t)\u200b qui devraient \u00eatre mod\u00e9lis\u00e9es de la sorte ; nous pourrons \u00e9galement tester cette variante ensuite). Appelons \\theta\u200b le vecteur des param\u00e8tres et conditions initiales \u00e0 estimer : \\theta=\\{\\alpha,\\beta,\\gamma,S(0),I(0),H(0)\\}\\,. Sous l'hypoth\u00e8se (discutable) que les observations sont ind\u00e9pendantes conditionnellement au mod\u00e8le \u00e9pid\u00e9miologique (ce qui veut dire \"sachant la dynamique pr\u00e9dite par le mod\u00e8le th\u00e9orique\"), la vraisemblance ( likelihood ) peut s'\u00e9crire : \\mathcal{L}\\left(\\theta\\right)=\\prod_{t=0}^T \\text{Pr}(\\text{observer A admissions le jour }t| A(t))\\times\\text{Pr}(\\text{observer H hospitalisations le jour }t|H(t))\\,. Comme la fonction logarithme est monotone croissante, trouver le vecteur \\theta\u200b qui maximise \u200b \\mathcal L(\\theta) est \u00e9quivalent \u00e0 trouver le vecteur \u200b \\theta\u200b qui maximise la log-vraisemblance ( log-likelihood ) \u200b \\log\\mathcal{L}(\\theta) qui est plus commun\u00e9ment utilis\u00e9e en pratique. Maximisation de la vraisemblance Construisons une fonction qui calcule la log-vraisemblance d'un jeu de param\u00e8tres et de conditions initiales. Cette fonction prend en argument le vecteur des param\u00e8tres et des conditions initiales \u00e0 estimer : logLike=function(theta){ P = theta[1:3] # Les param\u00e8tres beta, alpha, et gamma X0 = theta[4:6] # Mise \u00e0 jour des conditions initiales X = ode(X0,t,SIHR,P) # R\u00e9solution du syst\u00e8me d'EDO (mod\u00e8le SIHR) h = X[,4] # Hospitalisation th\u00e9oriques : H(t) a = P[2]*X[,3] # Admissions th\u00e9oriques : alpha*I(t) LLH = dpois(H,h,log=T) # Probabilit\u00e9 d'observer H (loi de Poisson) LLA = dpois(A,a,log=T) # Probabilit\u00e9 d'observer A (Poisson) LL = sum(c(LLH,LLA)) # Log transforme produit des probas en somme return(LL) # Renvoie la log-vraisemblance (likelihood) } Avant d'appeler les fonctions ci-dessus, on d\u00e9finit le vecteurs des param\u00e8tres et conditions initiales : theta0 = c(P0,X0) # Concat\u00e8ne param\u00e8tres et conditions initiales Utilisons la fonction optim pour trouver les param\u00e8tres et conditions initiales qui maximisent la vraisemblance du mod\u00e8le. opt = optim(theta0,logLike,control=list(fnscale=-1)) # Maximise logLike R\u00e9sultats On r\u00e9cup\u00e8re les param\u00e8tres et conditions initiales dont la vraisemblance est maximale : # Les param\u00e8tres optimaux beta = opt$par[1]; alpha = opt$par[2]; gamma = opt$par[3] # Les conditions initiales optimales S0 = opt$par[4]; I0=opt$par[5]; H0 = opt$par[6] On met \u00e0 jour les vecteurs des param\u00e8tres et conditions initiales : X0 = c(S0,I0,H0) # Vecteur des conditions initiales P0 = c(beta,alpha,gamma) # Vecteur des param\u00e8tres mis \u00e0 jour On affiche trois quantit\u00e9s importantes : R_0=beta/(alpha+rho)*S0/N # Reproductivit\u00e9 estim\u00e9e print(R_0) p=alpha/(alpha+rho) # Probabilit\u00e9 d'\u00eatre hospitalis\u00e9 print(p) print(1/gamma); # Temps moyen d'hospitalisation On trouve : Nombre de reproduction de base (en confinement) : \\mathcal R_0 \\approx 0.65\u200b Probabilit\u00e9 d'\u00eatre hospitalis\u00e9 suite \u00e0 l'infection : p \\approx 0.07 \u200b Temps moyen d'hospitalisation : \\frac{1}{\\gamma} \\approx 17\u200b jours La valeur de \\mathcal R_0\u200b est globalement coh\u00e9rente avec celles estim\u00e9es par les \u00e9tudes list\u00e9es dans les R\u00e9f\u00e9rences, et n'est pas surprenante en p\u00e9riode de confinement ( \\mathcal R_0<1 ). On calcule la solution du mod\u00e8le pour les param\u00e8tres et conditions initiales estim\u00e9s : T = 120; t = 0:T # Mise \u00e0 jour du vecteur temps X = ode(X0,t,SIHR,P0) # Calcul de la solution optimale On compare visuellement la solution du mod\u00e8le et les observations : # Affiche le nombre d'individus hospitalis\u00e9s (donn\u00e9es et mod\u00e8le) plot(0:(L-1),H,xlab=\"Temps \u00e9coul\u00e9 depuis le 1er avril (en jours)\", ylab=\"Nombre de personnes hospitalis\u00e9es\",col=\"blue\") lines(X[,1],X[,4]) plot(0:(L-1),A,xlab=\"Temps \u00e9coul\u00e9 depuis le 1er avril (en jours)\", ylab=\"Nombre de nouvelles hospitalisations (par jour)\",col=\"red\") lines(X[,1],alpha*X[,3]) Estimation de la fraction de la population infect\u00e9e \"Pr\u00e9dire est un art difficile, surtout en ce qui concerne l'avenir\". N\u00e9anmoins, juste pour prendre du recul sur la dynamique \u00e9pid\u00e9mique, nous pouvons extrapoler les dynamiques pr\u00e9c\u00e9dentes sur un horizon de 4 mois (ce qui correspondrait \u00e0 la dynamique pr\u00e9dite si nous devions rester confin\u00e9s jusque fin juillet) : plot(0:(L-1),H,xlim=c(0,T),ylim=c(0,max(H)),xlab=\"Temps \u00e9coul\u00e9 depuis le 1er avril (en jours)\", ylab=\"Nombre de personnes hospitalis\u00e9es\",col=\"blue\") lines(X[,1],X[,4]) plot(0:(L-1),A,xlim=c(0,T),ylim=c(0,max(A)),xlab=\"Temps \u00e9coul\u00e9 depuis le 1er avril (en jours)\", ylab=\"Nombre d'admissions \u00e0 l'h\u00f4pital (par jour)\",col=\"red\") lines(X[,1],alpha*X[,3]) Enfin, on peut afficher la fraction de la population qui a \u00e9t\u00e9 infect\u00e9e par le virus durant le confinement (depuis le premier avril) et est donc immunis\u00e9e ou en voie de l'\u00eatre le 10 mai (sans d\u00e9compter les d\u00e9c\u00e8s) : F(t)\\approx\\frac{N-S(t)-R(0)}{N}. le10mai=length(H) F=(N-X[,2]-R0)/N # Fraction de la population qui a \u00e9t\u00e9 infect\u00e9e durant le confinement plot(le10mai,F[le10mai],xlim=c(0,T),ylim=c(0,max(F)),xlab=\"Temps \u00e9coul\u00e9 depuis le 1er avril (en jours)\", ylab=\"Fraction de la population infect\u00e9e\"); lines(X[,1],F,col=\"red\") On voit qu'environ 1,5% de la population aurait \u00e9t\u00e9 infect\u00e9e durant le confinement (depuis le 1er avril) selon le mod\u00e8le, soit 960 000 personnes environ. Cela ne dit rien de la proportion d'immunis\u00e9s dans la population, car il faut rajouter les immunis\u00e9s au 1er avril, R(0)\u200b , qui est inaccessible par cette seule \u00e9tude. En comparaison, Roques et al (2020) estiment la proportion de la population infect\u00e9e durant cette m\u00eame p\u00e9riode (du 1er avril au 10 mai) \u00e0 3.7% (95%-CI: 3.0-4.8%), sur la base de jeux de donn\u00e9es diff\u00e9rents (tests et d\u00e9c\u00e8s). Cependant, Salje et al (2020) estiment qu'environ 1% (entre 0,5% et 2%) de la population aurait \u00e9t\u00e9 infect\u00e9e sur la m\u00eame p\u00e9riode (Figure 3 ; panel E).","title":"TD3 (Avril-Mai 2020)"},{"location":"TD3/#introduction-a-la-modelisation-en-epidemiologie-covid-19-dynamique-epidemique-pendant-le-1er-confinement","text":"Fr\u00e9d\u00e9ric Hamelin, le 10 mai 2020. Mis \u00e0 jour le 30 mars 2021 d'apr\u00e8s l' application de Maimouna Diarra (\u00e9l\u00e8ve ing\u00e9nieure M1 Agro Rennes 2021) bas\u00e9e sur la version pr\u00e9c\u00e9dente du TD. Dans l'\u00e9pid\u00e9mie de COVID-19, les individus infect\u00e9s peuvent \u00eatre symptomatiques ou asymptomatiques. Les donn\u00e9es sur le nombre d'individus infect\u00e9s dans la population sont peu fiables car elles d\u00e9pendent des tests \u00e9ventuellement r\u00e9alis\u00e9s. Les individus symptomatiques peuvent faire une forme s\u00e9v\u00e8re de la maladie et \u00eatre hospitalis\u00e9s. Les donn\u00e9es concernant les individus hospitalis\u00e9s sont fiables en principe.","title":"Introduction \u00e0 la mod\u00e9lisation en \u00e9pid\u00e9miologie : COVID-19 - dynamique \u00e9pid\u00e9mique pendant le 1er confinement"},{"location":"TD3/#modele-epidemiologique","text":"Nous ferons un certain nombre d'hypoth\u00e8ses volontairement grossi\u00e8res pour simplifier l'\u00e9tude en premi\u00e8re approximation. Ces hypoth\u00e8ses incluent : la population fran\u00e7aise est spatialement homog\u00e8ne en France m\u00e9tropolitaine, les hommes et les femmes sont \u00e9gaux vis-\u00e0-vis du virus, la structure en \u00e2ge de la population peut \u00eatre ignor\u00e9e pour mod\u00e9liser l'\u00e9pid\u00e9mie, les individus hospitalis\u00e9s ne transmettent plus l'infection, la gu\u00e9rison conf\u00e8re une immunit\u00e9 permanente. Ces hypoth\u00e8ses sont plus que grossi\u00e8res mais permettent n\u00e9anmoins de commencer \u00e0 travailler. Techniquement, cela nous permettra de limiter le nombre de param\u00e8tres \u00e0 estimer. Autrement, le mod\u00e8le risquerait d'\u00eatre sur-param\u00e9tr\u00e9 au regard des donn\u00e9es et des connaissances dont on dispose sur le virus. Nous d\u00e9finissons les variables S(t) : nombre d'individus sensibles au virus (non-infect\u00e9s) \u00e0 la date t\u200b , I(t) : nombre d'individus infect\u00e9s et infectieux non-hospitalis\u00e9s \u00e0 la date t\u200b , H(t)\u200b : nombre d'individus infect\u00e9s hospitalis\u00e9s \u00e0 la date t\u200b , R(t)\u200b : nombre d'individus \"retir\u00e9s\" de l'\u00e9pid\u00e9mie (gu\u00e9ris et immunis\u00e9s ou d\u00e9c\u00e9d\u00e9s) \u00e0 la date t , et les param\u00e8tres \\beta\u200b : taux de transmission par unit\u00e9 de temps (fr\u00e9quence des contacts \u200b \\times\u200b probabilit\u00e9 d'infection), \\rho\u200b : taux de \"gu\u00e9rison\" par unit\u00e9 de temps (inverse du temps moyen avant gu\u00e9rison ou d\u00e9c\u00e8s), \\alpha\u200b : taux d'hospitalisation par unit\u00e9 de temps (inverse du temps moyen avant hospitalisation), \\gamma\u200b : taux de gu\u00e9rison ou d\u00e9c\u00e8s \u00e0 l'h\u00f4pital (inverse du temps moyen avant sortie de l'h\u00f4pital). Nous consid\u00e9rons le mod\u00e8le compartimental suivant : ce qui se traduit math\u00e9matiquement par le syst\u00e8me d'\u00e9quations diff\u00e9rentielles suivant : \\begin{eqnarray*} \\frac{\\mathrm{d} S}{\\mathrm{d} t} &=& -\\beta \\frac{S}{N} I\\,,\\\\ \\frac{\\mathrm{d} I}{\\mathrm{d} t} &=& +\\beta \\frac{S}{N} I - (\\alpha+\\rho) I\\,,\\\\ \\frac{\\mathrm{d} H}{\\mathrm{d} t} &=& \\alpha I - \\gamma H\\,,\\\\ \\frac{\\mathrm{d} R}{\\mathrm{d} t} &=& \\rho I+ \\gamma H\\,. \\end{eqnarray*} ce qui peut se lire comme suit : \\begin{eqnarray*} \\text{variation du nombre d'individus sensibles} &=& - \\text{ nouvelles infections}\\\\ \\text{variation du nombre d'individus infect\u00e9s} &=& + \\text{ nouvelles infections } - \\text{gu\u00e9risons} - \\text{hospitalisations}\\\\ \\text{variation du nombre d'individus hospitalis\u00e9s} &=& + \\text{ hospitalisations } - \\text{sorties suite \u00e0 gu\u00e9risons ou d\u00e9c\u00e8s}\\\\ \\text{variation du nombre d'individus retir\u00e9s} &=& + \\text{ gu\u00e9risons } + \\text{ sorties suite \u00e0 gu\u00e9risons ou d\u00e9c\u00e8s} \\end{eqnarray*} La taille de la population est d\u00e9finie comme N= S+I+H+R=\\mbox{constante}\\,. Chaque individu infect\u00e9 r\u00e9alise un certain nombre de contacts avec d'autres individus par unit\u00e9 de temps (c'est la fr\u00e9quence des contacts). Pour chaque contact, la probabilit\u00e9 de rencontrer un individu sensible est \u00e9gale \u00e0 la proportion que repr\u00e9sentent les individus sensibles dans la population : S/N\u200b . Ainsi le nombre de nouvelles infections par unit\u00e9 de temps est \\beta SI/N . La reproductivit\u00e9 du pathog\u00e8ne est d\u00e9fini comme \\mathcal R_0 = \\frac{\\beta}{\\alpha+\\rho}\\frac{S(0)}{N}\\,. C'est le nombre d'infections secondaires g\u00e9n\u00e9r\u00e9es par un individu infect\u00e9 dans la population initiale : si \\mathcal R_0>1\u200b une vague \u00e9pid\u00e9mique se forme. si \\mathcal R_0<1\u200b l'\u00e9pid\u00e9mie s'\u00e9teint progressivement. La probabilit\u00e9 d'\u00eatre hospitalis\u00e9 suite \u00e0 l'infection est p = \\frac{\\alpha}{\\alpha+\\rho}\\,. Nous allons maintenant tenter d'ajuster ce mod\u00e8le aux donn\u00e9es de COVID-19 en France sous R. Ces donn\u00e9es concernent le nombre de personnes hospitalis\u00e9es \u00e0 la date t\u200b , H(t)\u200b , ainsi que le nombre d'admissions \u00e0 l'h\u00f4pital \u00e0 la date t (par unit\u00e9 de temps) : A(t)=\\alpha I(t)\\,. Le mod\u00e8le \u00e9pid\u00e9miologique est \u00e0 base d'\u00e9quations diff\u00e9rentielles ordinaires ( ordinary differential equations ). Les simulations se baseront sur la fonction ode de la librairie deSolve de R \u00e0 importer en d\u00e9but de script. library(deSolve) # Import de la fonction ode Commen\u00e7ons par nettoyer l'environnement de travail : rm(list=ls()) # Efface les variables cr\u00e9\u00e9es lors des ex\u00e9cutions pr\u00e9c\u00e9dentes graphics.off() # Ferme les fen\u00eatres ouvertes lors des ex\u00e9cutions pr\u00e9c\u00e9dentes","title":"Mod\u00e8le \u00e9pid\u00e9miologique"},{"location":"TD3/#telechargement-et-traitement-des-donnees","text":"Les donn\u00e9es sont disponibles sur le site suivant : https://www.data.gouv.fr/fr/datasets/donnees-hospitalieres-relatives-a-lepidemie-de-covid-19/ Nous baserons notre travail sur les donn\u00e9es hospitali\u00e8res suivantes (\u00e0 la date du TD) : donnees-hospitalieres-covid19-2020-05-10-19h00.csv donnees-hospitalieres-nouveaux-covid19-2020-05-10-19h00.csv Importons les donn\u00e9es sous R : # Lien permanent vers les donn\u00e9es d'hospitalisations urlH = url(\"https://www.data.gouv.fr/fr/datasets/r/63352e38-d353-4b54-bfd1-f1b3ee1cabd7\") # Lien permanent vers les donn\u00e9es d'admissions urlA = url(\"https://www.data.gouv.fr/fr/datasets/r/6fadff46-9efd-4c53-942a-54aca783c30c\") # Nombre d'individus hospitalis\u00e9s (H) - \u00e0 partir du 19 mars dataH = read.csv2(urlH, header=TRUE, sep=\";\") # Nombre d'admissions (A) \u00e0 l'h\u00f4pital par jour dataA = read.csv2(urlA, header=TRUE, sep=\";\") V\u00e9rification de la nature des variables : str(dataH) # la fonction str () permet de nous renseigner sur la nature de chaque str(dataA) # variable contenue dans les tableaux On remarque que la variable \u201cjour\u201d est consid\u00e9r\u00e9e comme un facteur. Nous allons donc la convertir en date pour faciliter le triage des donn\u00e9es quand on a va d\u00e9finir la fen\u00eatre temporelle d'\u00e9tude. dataH$jour = as.Date(dataH$jour) # conversion de variable jour en date dataA$jour = as.Date(dataA$jour) La deuxi\u00e8me colonne du jeu de donn\u00e9es \"H\" distingue les hommes et les femmes par des 1 et des 2. Comme le mod\u00e8le n'est pas structur\u00e9 selon ces cat\u00e9gories, nous ne conserverons que les lignes 0 qui agr\u00e8gent hommes et femmes : dataH = dataH[dataH$sexe==0,] # pas de distinction entre les hommes et les femmes en selectionnant uniquement les lignes 0 de la colonne \"sexe\" Pour ce qui suit, nous ne conserverons que les informations relatives aux hospitalisations, d\u00e9c\u00e8s et gu\u00e9risons, par d\u00e9partements : dataH = dataH[,c(-2,-6,-7)] # on \u00e9limine les colonnes suivantes: \"sexe\", \"rad\" et \"dc\" dataA = dataA[,c(-4,-5,-6)] # on \u00e9limine \"incid_rea\", \"incid_dc\" et \"incid_rad\" Pour cette \u00e9tape, nous voulons s\u00e9lectionner uniquement les donn\u00e9es qui se trouvent entre le 19/03/2020 et le 11/05/2020 pour les d\u00e9partements m\u00e9tropolitains en excluant la Corse : # on d\u00e9finit notre fen\u00eatre temporelle dataH = dataH[dataH$jour>\"2020-03-19\" & dataH$jour<\"2020-05-11\", ] dataA = dataA[dataA$jour>\"2020-03-19\" & dataA$jour<\"2020-05-11\", ] # s\u00e9lection des d\u00e9partements m\u00e9tropolitains dataH = dataH[(dataH$dep!=\"971\")&(dataH$dep!=\"972\")&(dataH$dep!=\"973\")&(dataH$dep!=\"974\")&(dataH$dep!=\"976\")&(dataH$dep!=\"2A\")&(dataH$dep!=\"2B\"),] dataA = dataA[(dataA$dep!=\"971\")&(dataA$dep!=\"972\")&(dataA$dep!=\"973\")&(dataA$dep!=\"974\")&(dataA$dep!=\"976\")&(dataA$dep!=\"2A\")&(dataA$dep!=\"2B\"),] Agr\u00e9gation des donn\u00e9es \u00e0 l'\u00e9chelle de la France par jour : # on utilise la fonction aggregate pour additionner le nombre d'hospitalis\u00e9s par jour dataHH = aggregate(hosp ~ jour, data = dataH, FUN = sum) dataAA = aggregate(incid_hosp~ jour, data = dataA, FUN = sum) # idem pour les admissions Construction de 2 nouveaux vecteurs qui contiennent uniquement les donn\u00e9es qui nous int\u00e9ressent : H = dataHH[,c(2)] # vecteur des hospitalisations A = dataAA[,c(2)] # vecteur des admissions Construisons un vecteur temps qui va correspondre \u00e0 l'ordonn\u00e9e de nos graphiques : L = length(dataHH$jour) # longueur de la s\u00e9rie temporelle t = seq(0,L-1,1) # vecteur temps allant de 0 \u00e0 L par pas de 1 Affichons le nombre de personnes hospitalis\u00e9es en fonction du temps : plot(t,H,col=\"blue\",xlab=\"Temps \u00e9coul\u00e9 depuis le 19 mars (en jours)\", ylab=\"Nombre de personnes hospitalis\u00e9es\") Affichons les admissions quotidiennes en fonction du temps : plot(t,A,xlab=\"Temps \u00e9coul\u00e9 depuis le 19 mars (en jours)\", ylab=\"Nombre d'admissions \u00e0 l'h\u00f4pital (par jour)\",col=\"red\") Comme le confinement a d\u00e9but\u00e9 le 17 mars, la tendance croissante des deux premi\u00e8res semaines suit probablement une dynamique de transition suite \u00e0 la mise en place du confinement. Comme le mod\u00e8le \u00e9pid\u00e9miologique suppose que les param\u00e8tres \u00e9pid\u00e9miologiques sont constants, en particulier le taux de transmission du virus, nous commencerons les analyses 15 jours apr\u00e8s le d\u00e9but du confinement, soit \u00e0 partir du 1er avril : T0 = 13 # D\u00e9calage du point de d\u00e9part 13 jours apr\u00e8s le 19 mars (le 1er avril) H = H[T0:L];A=A[T0:L] # Troncations des donn\u00e9es L = length(H) # Mise \u00e0 jour de la longueur des s\u00e9ries temporelles t = seq(0,L-1,1) # et du vecteur temps Visualisation des donn\u00e9es tronqu\u00e9es \u00e0 partir du 1er avril : plot(t,H,xlab=\"Temps \u00e9coul\u00e9 depuis le 1er avril (en jours)\", ylab=\"Nombre de personnes hospitalis\u00e9es\",col=\"blue\") plot(t,A,xlab=\"Temps \u00e9coul\u00e9 depuis le 1er avril (en jours)\", ylab=\"Nombre d'admissions \u00e0 l'h\u00f4pital (par jour)\",col=\"red\")","title":"T\u00e9l\u00e9chargement et traitement des donn\u00e9es"},{"location":"TD3/#simulations-et-ajustement-du-modele-aux-donnees","text":"","title":"Simulations et ajustement du mod\u00e8le aux donn\u00e9es"},{"location":"TD3/#resolution-numerique-du-modele-epidemiologique","text":"Commen\u00e7ons par d\u00e9finir les param\u00e8tres du mod\u00e8le \u00e9pid\u00e9miologique. Les valeurs donn\u00e9es aux param\u00e8tres \u00e0 estimer sont de grossi\u00e8res estimations initiales (ordres de grandeurs approximatifs). Pour que le probl\u00e8me d'estimation des param\u00e8tres soit bien pos\u00e9 (c'est-\u00e0-dire pour que le mod\u00e8le ne soit pas sur-param\u00e9tr\u00e9 par rapport aux donn\u00e9es utilis\u00e9es), il faut \u00e0 minima fixer la valeur d'un param\u00e8tre ( H. et al 2021 ). La p\u00e9riode infectieuse a \u00e9t\u00e9 estim\u00e9e \u00e0 10.91 jours en moyenne (avec un \u00e9cart-type de 3.95 jours) en Chine ( You et al 2020 ). Nous retiendrons la valeur moyenne. En pratique cependant, nous ne pourrons estimer que le nombre de personnes retir\u00e9es de la dynamique \u00e9pid\u00e9mique durant le confinement : R(t)-R(0)\u200b . Nous ne pourrons pas estimer la proportion de la population initialement immunis\u00e9e (ou retir\u00e9e) au 1er avril : R(0) . N\u00e9anmoins, les r\u00e9sultats que nous obtiendrons seront ind\u00e9pendants de la valeur initiale donn\u00e9e \u00e0 R(0) , comme vous pourrez le v\u00e9rifier. N = 64e6 # Population hexagonale approximative rho = 1/10 # Temps moyen avant gu\u00e9rison ou d\u00e9c\u00e8s : 10 jours gamma = 1/14 # Dur\u00e9e moyenne de l'hospitalisation : 14 jours R_0 = 1 # Reproductivit\u00e9 du virus en confinement beta = R_0*rho # Taux de transmission (calcul tr\u00e8s approximatif) p = 0.1 # Probabilit\u00e9 d'\u00eatre hospitalis\u00e9 suite \u00e0 l'infection alpha = p*rho/(1-p) # Taux d'hospitalisation P0 = c(beta,alpha,gamma) # Vecteur des param\u00e8tres D\u00e9finissons ensuite les variables du mod\u00e8le et les conditions initiales (au 1er avril) : H0 = H[1] # Le nombre de personnes hospitalis\u00e9es au 1er avril I0 = A[1]/alpha # Les admissions correspondent \u00e0 A(t) = alpha*I(t) R0 = N*0.01 # C'est la grande inconnue : mettons 1% d'immunis\u00e9s S0 = N-I0-H0-R0 # La taille de la population sensible au 1er avril X0 = c(S0,I0,H0)# Vecteur d'\u00e9tat - pas besoin de simuler R=N-(S+I+H) D\u00e9finissons la fonction SIHR qui prend en arguments 3 vecteurs : temps, variables d'\u00e9tats, et param\u00e8tres : SIHR = function(t, X, P){ beta = P[1] # Le taux de transmission alpha = P[2] # Le taux d'hospitalisation gamma = P[3] # Le taux de sortie d'h\u00f4pital S=X[1];I=X[2];H=X[3] # Le vecteur d'\u00e9tat X contient: S, I et H y = beta*S*I/N # Le nombre de nouvelles infections par jour dS = -y # On exprime dS/dt = - beta*S*I dI = y-(alpha+rho)*I # On exprime dI/dt = beta*S*I - (alpha+rho)*I dH = alpha*I -gamma*H # On exprime dH/dt = alpha*I - gamma*H dX=c(dS,dI,dH) # Renvoie dX/dt tel que demand\u00e9 par la fonction ode return(list(dX)) } Nous sommes int\u00e9ress\u00e9s par identifier les param\u00e8tres (\\alpha,\\beta,\\gamma\u200b) et l'\u00e9tat initial du syst\u00e8me (en particulier le nombre d'individus initialement infect\u00e9s I(0) dans la population) qui sont les plus vraisemblables d'apr\u00e8s les donn\u00e9es. La vraisemblance d'un jeu de param\u00e8tres et de conditions initiales \u00e0 estimer est la probabilit\u00e9 d'observer les donn\u00e9es sachant ces param\u00e8tres et conditions initiales. Pour pouvoir calculer cette probabilit\u00e9, il faut mod\u00e9liser le processus d'observation de fa\u00e7on stochastique (avec variables al\u00e9atoires).","title":"R\u00e9solution num\u00e9rique du mod\u00e8le \u00e9pid\u00e9miologique"},{"location":"TD3/#modele-dobservation","text":"Nous consid\u00e9rerons le mod\u00e8le d'observation le plus simple qui soit pour des donn\u00e9es de comptage : un tirage al\u00e9atoire dans une distribution de Poisson . Plus pr\u00e9cis\u00e9ment, nous consid\u00e9rerons que le nombre de nouvelles hospitalisations \u00e0 la date t est une variable al\u00e9atoire discr\u00e8te distribu\u00e9e selon une loi de Poisson de moyenne A(t)\u200b . De la m\u00eame fa\u00e7on, nous consid\u00e9rerons que le nombre de personnes hospitalis\u00e9es \u00e0 la date t \u200b est tir\u00e9 dans une loi de Poisson de moyenne \u200b H(t)\u200b (\u00e0 vrai dire, ce sont plut\u00f4t les sorties d'h\u00f4pital \u200b \\gamma H(t)\u200b qui devraient \u00eatre mod\u00e9lis\u00e9es de la sorte ; nous pourrons \u00e9galement tester cette variante ensuite). Appelons \\theta\u200b le vecteur des param\u00e8tres et conditions initiales \u00e0 estimer : \\theta=\\{\\alpha,\\beta,\\gamma,S(0),I(0),H(0)\\}\\,. Sous l'hypoth\u00e8se (discutable) que les observations sont ind\u00e9pendantes conditionnellement au mod\u00e8le \u00e9pid\u00e9miologique (ce qui veut dire \"sachant la dynamique pr\u00e9dite par le mod\u00e8le th\u00e9orique\"), la vraisemblance ( likelihood ) peut s'\u00e9crire : \\mathcal{L}\\left(\\theta\\right)=\\prod_{t=0}^T \\text{Pr}(\\text{observer A admissions le jour }t| A(t))\\times\\text{Pr}(\\text{observer H hospitalisations le jour }t|H(t))\\,. Comme la fonction logarithme est monotone croissante, trouver le vecteur \\theta\u200b qui maximise \u200b \\mathcal L(\\theta) est \u00e9quivalent \u00e0 trouver le vecteur \u200b \\theta\u200b qui maximise la log-vraisemblance ( log-likelihood ) \u200b \\log\\mathcal{L}(\\theta) qui est plus commun\u00e9ment utilis\u00e9e en pratique.","title":"Mod\u00e8le d'observation"},{"location":"TD3/#maximisation-de-la-vraisemblance","text":"Construisons une fonction qui calcule la log-vraisemblance d'un jeu de param\u00e8tres et de conditions initiales. Cette fonction prend en argument le vecteur des param\u00e8tres et des conditions initiales \u00e0 estimer : logLike=function(theta){ P = theta[1:3] # Les param\u00e8tres beta, alpha, et gamma X0 = theta[4:6] # Mise \u00e0 jour des conditions initiales X = ode(X0,t,SIHR,P) # R\u00e9solution du syst\u00e8me d'EDO (mod\u00e8le SIHR) h = X[,4] # Hospitalisation th\u00e9oriques : H(t) a = P[2]*X[,3] # Admissions th\u00e9oriques : alpha*I(t) LLH = dpois(H,h,log=T) # Probabilit\u00e9 d'observer H (loi de Poisson) LLA = dpois(A,a,log=T) # Probabilit\u00e9 d'observer A (Poisson) LL = sum(c(LLH,LLA)) # Log transforme produit des probas en somme return(LL) # Renvoie la log-vraisemblance (likelihood) } Avant d'appeler les fonctions ci-dessus, on d\u00e9finit le vecteurs des param\u00e8tres et conditions initiales : theta0 = c(P0,X0) # Concat\u00e8ne param\u00e8tres et conditions initiales Utilisons la fonction optim pour trouver les param\u00e8tres et conditions initiales qui maximisent la vraisemblance du mod\u00e8le. opt = optim(theta0,logLike,control=list(fnscale=-1)) # Maximise logLike","title":"Maximisation de la vraisemblance"},{"location":"TD3/#resultats","text":"On r\u00e9cup\u00e8re les param\u00e8tres et conditions initiales dont la vraisemblance est maximale : # Les param\u00e8tres optimaux beta = opt$par[1]; alpha = opt$par[2]; gamma = opt$par[3] # Les conditions initiales optimales S0 = opt$par[4]; I0=opt$par[5]; H0 = opt$par[6] On met \u00e0 jour les vecteurs des param\u00e8tres et conditions initiales : X0 = c(S0,I0,H0) # Vecteur des conditions initiales P0 = c(beta,alpha,gamma) # Vecteur des param\u00e8tres mis \u00e0 jour On affiche trois quantit\u00e9s importantes : R_0=beta/(alpha+rho)*S0/N # Reproductivit\u00e9 estim\u00e9e print(R_0) p=alpha/(alpha+rho) # Probabilit\u00e9 d'\u00eatre hospitalis\u00e9 print(p) print(1/gamma); # Temps moyen d'hospitalisation On trouve : Nombre de reproduction de base (en confinement) : \\mathcal R_0 \\approx 0.65\u200b Probabilit\u00e9 d'\u00eatre hospitalis\u00e9 suite \u00e0 l'infection : p \\approx 0.07 \u200b Temps moyen d'hospitalisation : \\frac{1}{\\gamma} \\approx 17\u200b jours La valeur de \\mathcal R_0\u200b est globalement coh\u00e9rente avec celles estim\u00e9es par les \u00e9tudes list\u00e9es dans les R\u00e9f\u00e9rences, et n'est pas surprenante en p\u00e9riode de confinement ( \\mathcal R_0<1 ). On calcule la solution du mod\u00e8le pour les param\u00e8tres et conditions initiales estim\u00e9s : T = 120; t = 0:T # Mise \u00e0 jour du vecteur temps X = ode(X0,t,SIHR,P0) # Calcul de la solution optimale On compare visuellement la solution du mod\u00e8le et les observations : # Affiche le nombre d'individus hospitalis\u00e9s (donn\u00e9es et mod\u00e8le) plot(0:(L-1),H,xlab=\"Temps \u00e9coul\u00e9 depuis le 1er avril (en jours)\", ylab=\"Nombre de personnes hospitalis\u00e9es\",col=\"blue\") lines(X[,1],X[,4]) plot(0:(L-1),A,xlab=\"Temps \u00e9coul\u00e9 depuis le 1er avril (en jours)\", ylab=\"Nombre de nouvelles hospitalisations (par jour)\",col=\"red\") lines(X[,1],alpha*X[,3])","title":"R\u00e9sultats"},{"location":"TD3/#estimation-de-la-fraction-de-la-population-infectee","text":"\"Pr\u00e9dire est un art difficile, surtout en ce qui concerne l'avenir\". N\u00e9anmoins, juste pour prendre du recul sur la dynamique \u00e9pid\u00e9mique, nous pouvons extrapoler les dynamiques pr\u00e9c\u00e9dentes sur un horizon de 4 mois (ce qui correspondrait \u00e0 la dynamique pr\u00e9dite si nous devions rester confin\u00e9s jusque fin juillet) : plot(0:(L-1),H,xlim=c(0,T),ylim=c(0,max(H)),xlab=\"Temps \u00e9coul\u00e9 depuis le 1er avril (en jours)\", ylab=\"Nombre de personnes hospitalis\u00e9es\",col=\"blue\") lines(X[,1],X[,4]) plot(0:(L-1),A,xlim=c(0,T),ylim=c(0,max(A)),xlab=\"Temps \u00e9coul\u00e9 depuis le 1er avril (en jours)\", ylab=\"Nombre d'admissions \u00e0 l'h\u00f4pital (par jour)\",col=\"red\") lines(X[,1],alpha*X[,3]) Enfin, on peut afficher la fraction de la population qui a \u00e9t\u00e9 infect\u00e9e par le virus durant le confinement (depuis le premier avril) et est donc immunis\u00e9e ou en voie de l'\u00eatre le 10 mai (sans d\u00e9compter les d\u00e9c\u00e8s) : F(t)\\approx\\frac{N-S(t)-R(0)}{N}. le10mai=length(H) F=(N-X[,2]-R0)/N # Fraction de la population qui a \u00e9t\u00e9 infect\u00e9e durant le confinement plot(le10mai,F[le10mai],xlim=c(0,T),ylim=c(0,max(F)),xlab=\"Temps \u00e9coul\u00e9 depuis le 1er avril (en jours)\", ylab=\"Fraction de la population infect\u00e9e\"); lines(X[,1],F,col=\"red\") On voit qu'environ 1,5% de la population aurait \u00e9t\u00e9 infect\u00e9e durant le confinement (depuis le 1er avril) selon le mod\u00e8le, soit 960 000 personnes environ. Cela ne dit rien de la proportion d'immunis\u00e9s dans la population, car il faut rajouter les immunis\u00e9s au 1er avril, R(0)\u200b , qui est inaccessible par cette seule \u00e9tude. En comparaison, Roques et al (2020) estiment la proportion de la population infect\u00e9e durant cette m\u00eame p\u00e9riode (du 1er avril au 10 mai) \u00e0 3.7% (95%-CI: 3.0-4.8%), sur la base de jeux de donn\u00e9es diff\u00e9rents (tests et d\u00e9c\u00e8s). Cependant, Salje et al (2020) estiment qu'environ 1% (entre 0,5% et 2%) de la population aurait \u00e9t\u00e9 infect\u00e9e sur la m\u00eame p\u00e9riode (Figure 3 ; panel E).","title":"Estimation de la fraction de la population infect\u00e9e"},{"location":"TD4/","text":"Introduction \u00e0 la mod\u00e9lisation en \u00e9pid\u00e9miologie : COVID19 - 1er confinement - estimation de la reproductivit\u00e9 du virus C\u00e9cile Berthelot, Aliz\u00e9e Delarue, Agla\u00e9 Thieffry, Am\u00e9lie Picchiottino (M1 Agro Rennes), le 15 mars 2021. Edit\u00e9 par Fr\u00e9d\u00e9ric Hamelin et Marine Dorand (M1 MODE), le 28 avril 2021. Introduction Nous nous sommes int\u00e9ress\u00e9es au cours de ce projet \u00e0 la mod\u00e9lisation de l'\u00e9pid\u00e9mie de Covid-19 lors du premier confinement, \u00e0 partir du 19 mars (par manque de donn\u00e9es les jours pr\u00e9c\u00e9dents). Pour cela, nous avons r\u00e9colt\u00e9 des bases de donn\u00e9es sur data.gouv.fr . Nous avons utilis\u00e9 des donn\u00e9es portant sur le nombre de tests r\u00e9alis\u00e9s en laboratoire de ville, le nombre de tests positifs, le nombre de d\u00e9c\u00e8s \u00e0 l'h\u00f4pital, le nombre de gu\u00e9risons apr\u00e8s hospitalisation. Nous n\u2019avons pas utilis\u00e9 de donn\u00e9es sur les gu\u00e9risons et les d\u00e9c\u00e8s \u00e0 domicile. Les donn\u00e9es sont cumul\u00e9es \u00e0 partir du 19 mars. Sources des donn\u00e9es : https://www.data.gouv.fr/fr/datasets/donnees-hospitalieres-relatives-a-lepidemie-de-covid-19/ https://www.data.gouv.fr/fr/datasets/donnees-relatives-aux-tests-de-depistage-de-covid-19-realises-en-laboratoire-de-ville/ Notre \u00e9tude s\u2019appuie sur les travaux sur le confinement pr\u00e9sent\u00e9s dans cet article : Roques L, Klein EK, Papa\u00efx J, Sar A, and Soubeyrand S (2020) Impact of Lockdown on the Epidemic Dynamics of COVID-19 in France. Front. Med. 7:274. Mod\u00e8le \u00e9pid\u00e9miologique Les variables du mod\u00e8le sont : S(t) : le nombre de personnes sensibles au temps t , I(t) : le nombre de personnes infect\u00e9es et infectieuses, R(t) : le nombre de personnes r\u00e9tablies ou gu\u00e9ries, D(t) : le nombre de personnes d\u00e9c\u00e9d\u00e9es. La taille de la population est N=S+I+R . Les param\u00e8tres du mod\u00e8les sont \\beta : le taux de transmission de la maladie, \\gamma : le taux de gu\u00e9rison, \\alpha : le taux de mortalit\u00e9 due \u00e0 la maladie. Ce sont des \"taux\" par unit\u00e9 de temps. Le mod\u00e8le s'\u00e9crit : \\begin{eqnarray} \\frac{\\mathrm{d}S}{\\mathrm{d}t}&=&-\\beta \\frac{I}{N}S\\,,\\\\ \\frac{\\mathrm{d}I}{\\mathrm{d}t}&=&\\beta \\frac{I}{N}S - (\\alpha+\\gamma)I\\,,\\\\ \\frac{\\mathrm{d}R}{\\mathrm{d}t}&=&\\gamma I\\,,\\\\ \\frac{\\mathrm{d}D}{\\mathrm{d}t}&=&\\alpha I\\,. \\end{eqnarray} Mod\u00e8le d'observation L'ajustement du mod\u00e8le se fera par maximisation de la vraisemblance ( likelihood en anglais). Cette m\u00e9thode consiste \u00e0 maximiser la probabilit\u00e9 des observations sachant les param\u00e8tres. Le mod\u00e8le d'observation d\u00e9finit la probabilit\u00e9 qu'un test soit positif au temps t\u200b d'apr\u00e8s le mod\u00e8le \u00e9pid\u00e9miologique : p(t)=\\frac{\\sigma I(t)}{I(t)+\\kappa S(t)}\\,, o\u00f9 \\sigma \u200b est la sensibilit\u00e9 des tests PCR (suppos\u00e9e connue) et \\kappa est probabilit\u00e9 relative pour les individus sensibles de se faire tester comparativement aux infect\u00e9s (\u00e0 estimer). Aussi, le nombre de tests positifs le jour t peut \u00eatre mod\u00e9lis\u00e9 comme un tirage dans une loi Binomiale de param\u00e8tres p(t) et n(t) (le nombre de tests r\u00e9alis\u00e9s le jour t ) : le nombre de nouveaux cas observ\u00e9s le jour t est c(t)\\sim \\mbox{Binomial}(n(t),p(t)) Nous faisons l'hypoth\u00e8se que le nombre de d\u00e9c\u00e8s cumul\u00e9s observ\u00e9 au jour t est tir\u00e9 dans une loi de Poisson de moyenne D(t) telle que donn\u00e9 par le mod\u00e8le : D_{\\small\\mbox{data}}(t)\\sim \\mbox{Poisson}\\left(D_{\\small\\mbox{model}}(t)\\right) En admettant que les observations sont ind\u00e9pendantes conditionnellement au mod\u00e8le, la vraisemblance s'\u00e9crit : \\mbox{Like}(\\theta)=\\prod_{t=0}^{T} \\mbox{Prob}(\\mbox{observe }c(t)|\\mbox{ model predicts }p(t))\\times \\mbox{Prob}(\\mbox{observe }D_{\\small\\mbox{data}}(t)|D_{\\small\\mbox{model}}(t))\\,. Soit \\theta = \\{ \\beta, \\kappa, \\alpha \\} le vecteur des param\u00e8tres \u00e0 estimer. Rechercher les valeurs de \\theta qui maximisent la vraisemblance est \u00e9quivalent \u00e0 rechercher les valeurs de \\theta qui maximisent la log-vraisemblance, qui transforme le produit en somme : \\mbox{logLike}(\\theta)=\\sum_{t=0}^T \\log\\left(\\mbox{Prob}(\\mbox{observe }c(t)|\\mbox{ model predicts }p(t))\\times \\mbox{Prob}(\\mbox{observe }D_{\\small\\mbox{data}}(t)|D_{\\small\\mbox{model}}(t))\\right)\\,. Nous travaillerons avec la log-vraisemblance. Traitement des donn\u00e9es Tout d\u2019abord, nous pouvons nettoyer l\u2019environnement de travail en effa\u00e7ant les anciennes variables : rm(list=ls()) # Efface les variables cr\u00e9\u00e9es lors des ex\u00e9cutions pr\u00e9c\u00e9dentes graphics.off() # Ferme les fen\u00eatres ouvertes lors des ex\u00e9cutions pr\u00e9c\u00e9dentes Nous importons les librairies n\u00e9cessaires au projet : library(deSolve) # pour la fonction ode (ordinary differential equation) Nous baserons notre travail sur les donn\u00e9es hospitali\u00e8res suivantes : donnees-tests-covid19-labo-quotidien-2020-05-29-19h00.csv donnees-hospitalieres-nouveaux-covid19-2020-05-10-19h00.csv Importons les donn\u00e9es sous R : # Lien permanent vers les donn\u00e9es de tests urltest = url(\"https://www.data.gouv.fr/fr/datasets/r/b4ea7b4b-b7d1-4885-a099-71852291ff20\") # Lien permanent vers les donn\u00e9es d'hospitalisations urlhosp = url(\"https://www.data.gouv.fr/fr/datasets/r/6fadff46-9efd-4c53-942a-54aca783c30c\") # Tableau li\u00e9 aux donn\u00e9es de tests datatest = read.csv2(urltest, header=TRUE, sep=\";\") # Tableau li\u00e9 aux donn\u00e9es d'hospitalisation datahosp = read.csv2(urlhosp, header=TRUE, sep=\";\") Pour les donn\u00e9es li\u00e9es aux tests, on gardera les donn\u00e9es pour toutes les classes d\u2019\u00e2ges. On conserve seulement les lignes avec clage\\_covid=0 : datatest=datatest[datatest$clage_covid == 0,] Agr\u00e9gation des donn\u00e9es \u00e0 l\u2019\u00e9chelle de la France (tous les d\u00e9partements fran\u00e7ais) par jour : # Nombre de tests par jour nb_test = aggregate(nb_test ~ jour, data = datatest, FUN = sum) # Nombre de tests positifs par jour nb_pos = aggregate(nb_pos ~ jour, data = datatest, FUN = sum) # Nombre de d\u00e9c\u00e8s par jour nb_deces = aggregate(incid_dc~ jour, data=datahosp, FUN = sum) # Nombre quotidien de nouveaux retours \u00e0 domicile nb_gueris= aggregate (incid_rad~ jour, data=datahosp, FUN = sum) Le premier confinement s\u2019est d\u00e9roul\u00e9 du 17 mars au 11 mai 2020. Mais les donn\u00e9es d\u2019hospitalisations commencent seulement le 19 mars. On s\u00e9lectionne les donn\u00e9es du 19 mars au 11 mai 2020 : nb_test=nb_test[nb_test$jour>\"2020-03-18\" & nb_test$jour<\"2020-05-12\", ] nb_pos=nb_pos[nb_pos$jour>\"2020-03-18\" & nb_pos$jour<\"2020-05-12\", ] nb_deces = nb_deces[ nb_deces$jour<\"2020-05-12\", ] nb_gueris = nb_gueris[ nb_gueris$jour<\"2020-05-12\", ] Construction de vecteurs qui contiennent uniquement les donn\u00e9es qui nous int\u00e9ressent : nb_test=nb_test[,2] # Nombre de tests nb_pos=nb_pos[,2] # Nombre de tests positifs nb_deces=nb_deces[,2] # Nombre de d\u00e9c\u00e8s nb_gueris=nb_gueris[,2] # Nombre de gu\u00e9ris (nb quotidien de nouveaux retours \u00e0 domicile) Construction de vecteurs avec les donn\u00e9es cumul\u00e9es avec la fonction cumsum : TT=cumsum(nb_test) # Nombre de tests cumul\u00e9s PT=cumsum(nb_pos) # Nombre de tests positifs cumul\u00e9s DN=cumsum(nb_deces) # Nombre de d\u00e9c\u00e8s cumul\u00e9s GN=cumsum(nb_gueris) # Nombre de gu\u00e9ris cumul\u00e9s LP = length(PT) LT = length(TT) LD = length(DN) LG = length(GN) Construction d\u2019un vecteur du nombre de jours \u00e9coul\u00e9 depuis le 19 mars jusqu\u2019au 11mai : temps = seq(from=1,to=54, by=1) Nous avons repr\u00e9sent\u00e9 ci-dessous l\u2019\u00e9volution du nombre de tests r\u00e9alis\u00e9s (courbe noire) et celle du nombre de tests positifs (courbe bleue) au cours du premier confinement. plot(temps,TT,xlab=\"Temps \u00e9coul\u00e9 depuis le 19 mars (en jours)\",ylab=\"Nombre cumul\u00e9 de tests\",pch=16, col=\"black\",main=\"Evolution des nombres de tests r\u00e9alis\u00e9s et de tests positifs au cours du premier confinement\") points(temps,PT,xlab=\"Temps \u00e9coul\u00e9 depuis le 19 mars (en jours)\",ylab=\"Nombre de tests positifs\",pch=16, col=\"blue\") legend(\"topleft\",legend=c(\"Nombre cumul\u00e9 de tests r\u00e9alis\u00e9s\",\"Nombre cumul\u00e9 de tests positifs\"),pch=16,col=c(\"black\",\"blue\"),bty=\"n\") Nous avons repr\u00e9sent\u00e9 ci-dessous l\u2019\u00e9volution du nombre de patients gu\u00e9ris (courbe verte) et celle du nombre de d\u00e9c\u00e8s (courbe rouge) au cours du premier confinement. plot(temps,GN,xlab=\"Temps \u00e9coul\u00e9 depuis le 19 mars (en jours)\",ylab=\"Nombre cumul\u00e9 de cas\",pch=16, col=\"dark green\",main=\"Evolution des nombres de patients test\u00e9s positifs, gu\u00e9ris ou d\u00e9c\u00e9d\u00e9s au cours du premier confinement\") points(temps,DN,xlab=\"Temps \u00e9coul\u00e9 depuis le 19 mars (en jours)\",ylab=\"Nombre de d\u00e9c\u00e8s\",pch=16,col=\"red\") points(temps,PT,xlab=\"Temps \u00e9coul\u00e9 depuis le 19 mars (en jours)\",ylab=\"Nombre de tests positifs\",pch=16, col=\"blue\") legend(\"topleft\",legend=c(\"Nombre cumul\u00e9 de patients gu\u00e9ris\",\"Nombre cumul\u00e9 de patients d\u00e9c\u00e9d\u00e9s\",\"Nombre cumul\u00e9 de tests positifs\"),pch=16,col=c(\"dark green\",\"red\",\"blue\"),bty=\"n\") Nous avons repr\u00e9sent\u00e9 ci-dessous la proportion du nombre cumul\u00e9 de tests positifs sur le nombre cumul\u00e9 de tests r\u00e9alis\u00e9s (courbe bleue) au cours du premier confinement. PP = PT/TT # proportion de tests positifs plot(temps,PP,xlab=\"Temps \u00e9coul\u00e9 depuis le 19 mars (en jours)\",ylab=\"Proportion de tests positifs\",pch=16, col=\"blue\", main=\"Proportion du nombre de tests positifs sur le nombre de tests r\u00e9alis\u00e9s au cours du premier confinement\") Afin de pouvoir \u00e9tudier l\u2019\u00e9volution du nombre de d\u00e9c\u00e8s durant le confinement, nous commen\u00e7ons notre \u00e9tude \u00e0 la date du 1er avril (13 jours apr\u00e8s le 19 mars), car les d\u00e9c\u00e8s sont retard\u00e9s d\u2019environ 2 semaines par rapport aux infections. tau = 13 # Pour commencer le 1er avril PT = PT[tau:LP] TT = TT[tau:LT] DN = DN[tau:LD] GN = GN[tau:LG] PP = PP[tau:length(PP)] Nous nous int\u00e9ressons maintenant au nombre de tests quotidiens effectu\u00e9s depuis le 1er avril : pt = nb_pos[tau:LP] # Nombre de tests positifs quotidiens depuis le 1er avril tt = nb_test[tau:LT] # Nombre de tests quotidiens depuis le 1er avril dn = nb_deces[tau:LD] # Nombre de d\u00e9c\u00e8s quotidiens depuis le 1er avril lt = length(tt) lp = length(pt) ld = length(dn) On red\u00e9fini un vecteur temps du nombre de jours \u00e9coul\u00e9 depuis le 1er avril jusqu\u2019au 11 mai : temps = seq(from=1,to=42, by=1) Nous repr\u00e9sentons ci-dessous l\u2019\u00e9volution quotidienne des nombres de tests r\u00e9alis\u00e9s (courbe noire) et de tests positifs (courbe bleue). plot(temps,tt,xlab=\"Temps \u00e9coul\u00e9 depuis le 1er avril (en jours)\",ylab=\"Nombre de tests quotidiens\",pch=16, col=\"black\",main = \"Evolution quotidienne des nombres de tests r\u00e9alis\u00e9s et de tests positifs\") points(temps,pt,xlab=\"Temps \u00e9coul\u00e9 depuis le 1er avril (en jours)\",ylab=\"Nombre de tests quotidiens positifs\",pch=16, col=\"blue\") legend(x=24, y=6000,legend=c(\"Nombre de tests quotidiens r\u00e9alis\u00e9s\",\"Nombre de tests positifs quotidiens\"),pch=16,col=c(\"black\",\"blue\")) Nous repr\u00e9sentons ci-dessous l\u2019\u00e9volution quotidienne du nombre de patients positifs (courbe bleue) et de patients d\u00e9c\u00e9d\u00e9s (courbe rouge). plot(temps,pt,xlab=\"Temps \u00e9coul\u00e9 depuis le 1er avril (en jours)\",ylab=\"Nombre de cas quotidiens\",pch=16,col=\"blue\",main= \"Evolution quotidienne des nombres de patients positifs et de patients d\u00e9c\u00e9d\u00e9s\") points(temps,dn,xlab=\"Temps \u00e9coul\u00e9 depuis le 1er avril (en jours)\",ylab=\"Nombre quotidien de d\u00e9c\u00e8s\",pch=16, col=\"red\") legend(\"topright\",legend=c(\"Nombre de tests quotidiens positifs\",\"Nombre quotidien de patients d\u00e9c\u00e9d\u00e9s\"),pch=16,col=c(\"blue\",\"red\"),bty=\"n\") Nous avons repr\u00e9sent\u00e9 ci-dessous la proportion de tests positifs quotidiens sur le nombre de tests r\u00e9alis\u00e9s quotidien (courbe bleue) au cours du premier confinement. pp = pt/tt # proportion de tests positifs quotidiens plot(temps,pp,xlab=\"Temps \u00e9coul\u00e9 depuis le 1er avril (en jours)\",ylab=\"Proportion de tests quotidiens positifs\",pch=16, col=\"blue\",main=\"Proportion de tests positifs quotidiens au cours du premier confinement\") Ajustement du mod\u00e8le aux donn\u00e9es Nous d\u00e9finissons les param\u00e8tres de notre mod\u00e8le : N = 67e6 # Taille totale de la population gamma = 1/10 # Taux de gu\u00e9rison (par jour) R_0 = 3 # Reproductivit\u00e9 du virus beta = gamma*R_0 # R0 = beta/gamma sigma = 0.7 # Sensibilit\u00e9 des tests PCR kappa = 5e-3 # Biais d'observation alpha = 0.01 # Taux de mortalit\u00e9 t0 = 1 # Correspond au 1er avril, la date du d\u00e9but de l'\u00e9tude theta0 = c(beta,kappa,alpha) # Vecteur des param\u00e8tres \u00e0 estimer Nous d\u00e9finissons les conditions initiales du mod\u00e8le : I0 = 1.5e6 # On fixe le nombre initial d'infect\u00e9s d'apr\u00e8s Roques et al 2020 R0 = N*0.01 # Inconnue : on suppose qu'au 1er avril il y avait 1% d'immunis\u00e9s D0 = DN[1] # On se sert de la donn\u00e9e initiale S0 = N-I0-R0-D0 X0 = c(S0,I0,D0) # Vecteur d'\u00e9tat Le temps est d\u00e9fini ci-dessous : t = t0:lt La fonction du mod\u00e8le SIRD : SIRD = function(t, X, P){ # X : vecteur d'\u00e9tat; P : param\u00e8tres du mod\u00e8le beta = P[1] ; alpha = P[2] S = X[1] ; I = X[2] ; D = X[3] y = beta*S*I/N # Nombre de nouvelles infections par jour dS = -y dI = +y - gamma*I - alpha*I dD = +alpha*I dX = c(dS,dI,dD) # Variations de S, I et D mises \u00e0 jour return(list(dX)) } La fonction qui calcule la vraisemblance des param\u00e8tres est d\u00e9finie ci-dessous : logLike = function(theta){ # theta : vecteur des param\u00e8tres \u00e0 estimer beta = theta[1] kappa = theta[2] alpha = theta[3] P = c(beta,alpha) X = ode(X0,t,SIRD,P) # X : vecteur des solutions du mod\u00e8le SIRD # Proportion th\u00e9orique de tests quotidiens positifs d'apr\u00e8s le mod\u00e8le p1 = sigma*X[,3]/(X[,3]+kappa*X[,2]) # Vraisemblance : calcule la probabilit\u00e9 d'observer pt en connaissant la probabilit\u00e9 th\u00e9orique p1 qu'un test soit positif (loi binomiale) et d'observer dn en connaissant la quantit\u00e9 th\u00e9orique quotidienne de d\u00e9c\u00e8s bas\u00e9e sur le taux de mortalit\u00e9 alpha (loi de poisson) L = dbinom(pt, tt, p1, log=TRUE) + dpois(dn, alpha*X[,3], log=TRUE) LL = sum(L) return(LL) } Nous cherchons ensuite \u00e0 estimer et optimiser le jeu de param\u00e8tres \\theta = \\{\\beta, \\kappa, \\alpha\\} de notre mod\u00e8le \u00e0 partir des estimations initiales \\theta_0 = \\{\\beta_0, \\kappa_0, \\alpha_0\\} \u00e0 l\u2019aide d\u2019une fonction optimisant la vraisemblance ( logLike ) : opt = optim(theta0,logLike,control=list(fnscale=-1)) beta = opt$par[1] # On extrait les param\u00e8tres optimis\u00e9s par notre mod\u00e8le kappa = opt$par[2] alpha = opt$par[3] P = c(beta,alpha) # P est le vecteur des param\u00e8tres utilis\u00e9s pour la r\u00e9solution des \u00e9quations diff\u00e9rentielles print(paste(\"beta =\",beta,\"; alpha =\",alpha,\"; kappa =\",kappa)) Nous trouvons \\beta \\approx 0.04 , \\alpha \\approx 5.84\\times 10^{-4} , et \\kappa \\approx 0.05 . Nous utilisons ensuite nos param\u00e8tres optimis\u00e9s pour r\u00e9soudre notre syst\u00e8me d\u2019\u00e9quations diff\u00e9rentielles. t = t0:42 # X : vecteur des solutions du mod\u00e8le SIRD avec les param\u00e8tres optimis\u00e9s X = ode(X0,t,SIRD,P) Nous repr\u00e9sentons ensuite sur un graphique les \u00e9volutions du nombre de tests positifs observ\u00e9es (courbe bleue) et th\u00e9oriques (courbe noire) calcul\u00e9es \u00e0 partir du mod\u00e8le afin de v\u00e9rifier la qualit\u00e9 de l\u2019ajustement du mod\u00e8le : p1 = sigma*X[,3]/(X[,3]+kappa*X[,2]) # Proportion th\u00e9orique de tests quotidiens positifs Sigma1 = cumsum(pt[t]) # Somme cumul\u00e9e du nombre de tests positifs observ\u00e9s Sigma2 = cumsum(tt[t]*p1) # Proportion de cas positifs cumul\u00e9e issue du mod\u00e8le plot(t, Sigma1, xlab = \"Temps \u00e9coul\u00e9 depuis le 1er avril (en jours)\", ylab = \"Nombres de tests positifs th\u00e9oriques et observ\u00e9s\", main= \"Evolutions du nombre de tests positifs observ\u00e9es et th\u00e9oriques\",pch=16, col = \"blue\") lines(t,Sigma2) legend(\"topleft\",legend=\"Nombre de tests positifs observ\u00e9\",pch=16,col=\"blue\",bty=\"n\") legend(x=0, y=24000,legend=\"Nombre de tests positifs th\u00e9orique\",lty=1,col=\"black\",bty=\"n\") Nous comparons \u00e9galement \u00e0 l\u2019aide du graphique ci-dessous les \u00e9volutions des proportions th\u00e9oriques (courbe noire) et observ\u00e9es (courbe bleue) des tests positifs quotidiens. plot(t,pp[t],xlab=\"Temps \u00e9coul\u00e9 depuis le 1er avril (en jours)\",ylab=\"Proportions de tests quotidiens positifs th\u00e9oriques et observ\u00e9es\", main=\"Evolutions des proportions th\u00e9oriques et observ\u00e9es des tests positifs quotidiens\",pch=16, col=\"blue\") lines(t,p1) # p1 : Proportion de tests positifs th\u00e9oriques legend(\"topright\",legend=\"Proportion de tests positifs observ\u00e9e\",pch=16,col=\"blue\",bty=\"n\") legend(x=21, y=0.30,legend=\"Proportion de tests positifs th\u00e9orique\",lty=1,col=\"black\",bty=\"n\") Les graphiques suivant repr\u00e9sentent les \u00e9volutions th\u00e9oriques du nombre de personnes infect\u00e9es au cours du temps, du nombre de personne saines et du nombre de personnes ayant \u00e9t\u00e9 infect\u00e9es depuis le d\u00e9but de l\u2019\u00e9pid\u00e9mie. plot(t,X[,3],col=\"blue\",xlab=\"Temps \u00e9coul\u00e9 depuis le 1er avril (en jours)\",ylab=\"Nombre de personnes infect\u00e9es\",pch=16, main=\"Evolution th\u00e9orique du nombre de personnes infect\u00e9es\") plot(t,X[,2],col=\"purple\",xlab=\"Temps \u00e9coul\u00e9 depuis le 1er avril (en jours)\",ylab=\"Nombre de personnes saines\",pch=16, main=\"Evolution du nombre th\u00e9orique de personnes saines\") plot(t,N-X[,2],xlab=\"Temps \u00e9coul\u00e9 depuis le 1er avril (en jours)\",ylab=\"Nombre de personnes ayant \u00e9t\u00e9 infect\u00e9es\",pch=16, main=\"Evolution du nombre th\u00e9orique de personnes ayant \u00e9t\u00e9 infect\u00e9es\") Nous repr\u00e9sentons les \u00e9volutions du nombre de d\u00e9c\u00e8s cumul\u00e9s th\u00e9oriques (courbe noire) et observ\u00e9es (courbe rouge). plot(temps,DN,col=\"red\",xlab=\"Temps \u00e9coul\u00e9 depuis le 1er avril (en jours)\",ylab=\"Nombre de d\u00e9c\u00e8s cumul\u00e9s\",pch=16,main=\"Evolutions du nombre de d\u00e9c\u00e8s cumul\u00e9s th\u00e9oriques et observ\u00e9es\") lines(t,X[,4]) legend(\"topleft\",legend=\"Nombre de d\u00e9c\u00e8s observ\u00e9s\",pch=16,col=\"red\",bty=\"n\") legend(x=-1, y=17000,legend=\"Nombre de d\u00e9c\u00e8s th\u00e9oriques\",lty=1,col=\"black\",bty=\"n\") Nous repr\u00e9sentons les \u00e9volutions du nombre de d\u00e9c\u00e8s quotidiens th\u00e9oriques (courbe noire) et observ\u00e9es (courbe rouge). plot(temps,dn,col=\"red\",xlab=\"Temps \u00e9coul\u00e9 depuis le 1er avril (en jours)\",ylab=\"Nombre de d\u00e9c\u00e8s quotidiens\",pch=16, main=\"Evolutions du nombre de d\u00e9c\u00e8s quotidiens th\u00e9oriques et observ\u00e9es\") lines(t,alpha*X[,3]) legend(\"bottomleft\",legend=\"Nombre de d\u00e9c\u00e8s quotidiens observ\u00e9\",pch=16,col=\"red\",bty=\"n\") legend(x=-1, y=200,legend=\"Nombre de d\u00e9c\u00e8s quotidiens th\u00e9orique\",lty=1,col=\"black\",bty=\"n\") Estimation de la reproductivit\u00e9 du virus A l\u2019aide de nos param\u00e8tres estim\u00e9s, nous sommes en mesure de calculer le nombre de reproduction effectif du virus au cours du confinement : \\mathcal R_e = \\frac{\\beta}{\\gamma+\\alpha}\\frac{S(t_0)}{N}\\,. R_e = beta/(gamma+alpha)*(S0/N) # Re : nombre de reproduction effectif du virus print(paste(\"R_e=\",R_e)) Nous trouvons \\mathcal R_e \\approx 0.42 , ce qui est coh\u00e9rent avec l'article de Roques et al 2020 . Nous pouvons \u00e9galement estimer le taux de l\u00e9talit\u00e9 (IFR) du virus durant le 1er confinement : IFR = alpha/(alpha+gamma) # Infection Fatality Ratio print(paste(\"IFR=\",IFR)) Nous trouvons un IFR de 0.58% , ce qui est comparable avec la valeur obtenue lors de la premi\u00e8re flamb\u00e9e, voir par exemple le pr\u00e9c\u00e9dent article des m\u00eames auteurs : Roques, L., Klein, E. K., Papaix, J., Sar, A., & Soubeyrand, S. (2020). Using early data to estimate the actual infection fatality ratio from COVID-19 in France. Biology, 9(5), 97.","title":"TD4 (Avril-Mai 2020)"},{"location":"TD4/#introduction-a-la-modelisation-en-epidemiologie-covid19-1er-confinement-estimation-de-la-reproductivite-du-virus","text":"C\u00e9cile Berthelot, Aliz\u00e9e Delarue, Agla\u00e9 Thieffry, Am\u00e9lie Picchiottino (M1 Agro Rennes), le 15 mars 2021. Edit\u00e9 par Fr\u00e9d\u00e9ric Hamelin et Marine Dorand (M1 MODE), le 28 avril 2021.","title":"Introduction \u00e0 la mod\u00e9lisation en \u00e9pid\u00e9miologie : COVID19 - 1er confinement - estimation de la reproductivit\u00e9 du virus"},{"location":"TD4/#introduction","text":"Nous nous sommes int\u00e9ress\u00e9es au cours de ce projet \u00e0 la mod\u00e9lisation de l'\u00e9pid\u00e9mie de Covid-19 lors du premier confinement, \u00e0 partir du 19 mars (par manque de donn\u00e9es les jours pr\u00e9c\u00e9dents). Pour cela, nous avons r\u00e9colt\u00e9 des bases de donn\u00e9es sur data.gouv.fr . Nous avons utilis\u00e9 des donn\u00e9es portant sur le nombre de tests r\u00e9alis\u00e9s en laboratoire de ville, le nombre de tests positifs, le nombre de d\u00e9c\u00e8s \u00e0 l'h\u00f4pital, le nombre de gu\u00e9risons apr\u00e8s hospitalisation. Nous n\u2019avons pas utilis\u00e9 de donn\u00e9es sur les gu\u00e9risons et les d\u00e9c\u00e8s \u00e0 domicile. Les donn\u00e9es sont cumul\u00e9es \u00e0 partir du 19 mars. Sources des donn\u00e9es : https://www.data.gouv.fr/fr/datasets/donnees-hospitalieres-relatives-a-lepidemie-de-covid-19/ https://www.data.gouv.fr/fr/datasets/donnees-relatives-aux-tests-de-depistage-de-covid-19-realises-en-laboratoire-de-ville/ Notre \u00e9tude s\u2019appuie sur les travaux sur le confinement pr\u00e9sent\u00e9s dans cet article : Roques L, Klein EK, Papa\u00efx J, Sar A, and Soubeyrand S (2020) Impact of Lockdown on the Epidemic Dynamics of COVID-19 in France. Front. Med. 7:274.","title":"Introduction"},{"location":"TD4/#modele-epidemiologique","text":"Les variables du mod\u00e8le sont : S(t) : le nombre de personnes sensibles au temps t , I(t) : le nombre de personnes infect\u00e9es et infectieuses, R(t) : le nombre de personnes r\u00e9tablies ou gu\u00e9ries, D(t) : le nombre de personnes d\u00e9c\u00e9d\u00e9es. La taille de la population est N=S+I+R . Les param\u00e8tres du mod\u00e8les sont \\beta : le taux de transmission de la maladie, \\gamma : le taux de gu\u00e9rison, \\alpha : le taux de mortalit\u00e9 due \u00e0 la maladie. Ce sont des \"taux\" par unit\u00e9 de temps. Le mod\u00e8le s'\u00e9crit : \\begin{eqnarray} \\frac{\\mathrm{d}S}{\\mathrm{d}t}&=&-\\beta \\frac{I}{N}S\\,,\\\\ \\frac{\\mathrm{d}I}{\\mathrm{d}t}&=&\\beta \\frac{I}{N}S - (\\alpha+\\gamma)I\\,,\\\\ \\frac{\\mathrm{d}R}{\\mathrm{d}t}&=&\\gamma I\\,,\\\\ \\frac{\\mathrm{d}D}{\\mathrm{d}t}&=&\\alpha I\\,. \\end{eqnarray}","title":"Mod\u00e8le \u00e9pid\u00e9miologique"},{"location":"TD4/#modele-dobservation","text":"L'ajustement du mod\u00e8le se fera par maximisation de la vraisemblance ( likelihood en anglais). Cette m\u00e9thode consiste \u00e0 maximiser la probabilit\u00e9 des observations sachant les param\u00e8tres. Le mod\u00e8le d'observation d\u00e9finit la probabilit\u00e9 qu'un test soit positif au temps t\u200b d'apr\u00e8s le mod\u00e8le \u00e9pid\u00e9miologique : p(t)=\\frac{\\sigma I(t)}{I(t)+\\kappa S(t)}\\,, o\u00f9 \\sigma \u200b est la sensibilit\u00e9 des tests PCR (suppos\u00e9e connue) et \\kappa est probabilit\u00e9 relative pour les individus sensibles de se faire tester comparativement aux infect\u00e9s (\u00e0 estimer). Aussi, le nombre de tests positifs le jour t peut \u00eatre mod\u00e9lis\u00e9 comme un tirage dans une loi Binomiale de param\u00e8tres p(t) et n(t) (le nombre de tests r\u00e9alis\u00e9s le jour t ) : le nombre de nouveaux cas observ\u00e9s le jour t est c(t)\\sim \\mbox{Binomial}(n(t),p(t)) Nous faisons l'hypoth\u00e8se que le nombre de d\u00e9c\u00e8s cumul\u00e9s observ\u00e9 au jour t est tir\u00e9 dans une loi de Poisson de moyenne D(t) telle que donn\u00e9 par le mod\u00e8le : D_{\\small\\mbox{data}}(t)\\sim \\mbox{Poisson}\\left(D_{\\small\\mbox{model}}(t)\\right) En admettant que les observations sont ind\u00e9pendantes conditionnellement au mod\u00e8le, la vraisemblance s'\u00e9crit : \\mbox{Like}(\\theta)=\\prod_{t=0}^{T} \\mbox{Prob}(\\mbox{observe }c(t)|\\mbox{ model predicts }p(t))\\times \\mbox{Prob}(\\mbox{observe }D_{\\small\\mbox{data}}(t)|D_{\\small\\mbox{model}}(t))\\,. Soit \\theta = \\{ \\beta, \\kappa, \\alpha \\} le vecteur des param\u00e8tres \u00e0 estimer. Rechercher les valeurs de \\theta qui maximisent la vraisemblance est \u00e9quivalent \u00e0 rechercher les valeurs de \\theta qui maximisent la log-vraisemblance, qui transforme le produit en somme : \\mbox{logLike}(\\theta)=\\sum_{t=0}^T \\log\\left(\\mbox{Prob}(\\mbox{observe }c(t)|\\mbox{ model predicts }p(t))\\times \\mbox{Prob}(\\mbox{observe }D_{\\small\\mbox{data}}(t)|D_{\\small\\mbox{model}}(t))\\right)\\,. Nous travaillerons avec la log-vraisemblance.","title":"Mod\u00e8le d'observation"},{"location":"TD4/#traitement-des-donnees","text":"Tout d\u2019abord, nous pouvons nettoyer l\u2019environnement de travail en effa\u00e7ant les anciennes variables : rm(list=ls()) # Efface les variables cr\u00e9\u00e9es lors des ex\u00e9cutions pr\u00e9c\u00e9dentes graphics.off() # Ferme les fen\u00eatres ouvertes lors des ex\u00e9cutions pr\u00e9c\u00e9dentes Nous importons les librairies n\u00e9cessaires au projet : library(deSolve) # pour la fonction ode (ordinary differential equation) Nous baserons notre travail sur les donn\u00e9es hospitali\u00e8res suivantes : donnees-tests-covid19-labo-quotidien-2020-05-29-19h00.csv donnees-hospitalieres-nouveaux-covid19-2020-05-10-19h00.csv Importons les donn\u00e9es sous R : # Lien permanent vers les donn\u00e9es de tests urltest = url(\"https://www.data.gouv.fr/fr/datasets/r/b4ea7b4b-b7d1-4885-a099-71852291ff20\") # Lien permanent vers les donn\u00e9es d'hospitalisations urlhosp = url(\"https://www.data.gouv.fr/fr/datasets/r/6fadff46-9efd-4c53-942a-54aca783c30c\") # Tableau li\u00e9 aux donn\u00e9es de tests datatest = read.csv2(urltest, header=TRUE, sep=\";\") # Tableau li\u00e9 aux donn\u00e9es d'hospitalisation datahosp = read.csv2(urlhosp, header=TRUE, sep=\";\") Pour les donn\u00e9es li\u00e9es aux tests, on gardera les donn\u00e9es pour toutes les classes d\u2019\u00e2ges. On conserve seulement les lignes avec clage\\_covid=0 : datatest=datatest[datatest$clage_covid == 0,] Agr\u00e9gation des donn\u00e9es \u00e0 l\u2019\u00e9chelle de la France (tous les d\u00e9partements fran\u00e7ais) par jour : # Nombre de tests par jour nb_test = aggregate(nb_test ~ jour, data = datatest, FUN = sum) # Nombre de tests positifs par jour nb_pos = aggregate(nb_pos ~ jour, data = datatest, FUN = sum) # Nombre de d\u00e9c\u00e8s par jour nb_deces = aggregate(incid_dc~ jour, data=datahosp, FUN = sum) # Nombre quotidien de nouveaux retours \u00e0 domicile nb_gueris= aggregate (incid_rad~ jour, data=datahosp, FUN = sum) Le premier confinement s\u2019est d\u00e9roul\u00e9 du 17 mars au 11 mai 2020. Mais les donn\u00e9es d\u2019hospitalisations commencent seulement le 19 mars. On s\u00e9lectionne les donn\u00e9es du 19 mars au 11 mai 2020 : nb_test=nb_test[nb_test$jour>\"2020-03-18\" & nb_test$jour<\"2020-05-12\", ] nb_pos=nb_pos[nb_pos$jour>\"2020-03-18\" & nb_pos$jour<\"2020-05-12\", ] nb_deces = nb_deces[ nb_deces$jour<\"2020-05-12\", ] nb_gueris = nb_gueris[ nb_gueris$jour<\"2020-05-12\", ] Construction de vecteurs qui contiennent uniquement les donn\u00e9es qui nous int\u00e9ressent : nb_test=nb_test[,2] # Nombre de tests nb_pos=nb_pos[,2] # Nombre de tests positifs nb_deces=nb_deces[,2] # Nombre de d\u00e9c\u00e8s nb_gueris=nb_gueris[,2] # Nombre de gu\u00e9ris (nb quotidien de nouveaux retours \u00e0 domicile) Construction de vecteurs avec les donn\u00e9es cumul\u00e9es avec la fonction cumsum : TT=cumsum(nb_test) # Nombre de tests cumul\u00e9s PT=cumsum(nb_pos) # Nombre de tests positifs cumul\u00e9s DN=cumsum(nb_deces) # Nombre de d\u00e9c\u00e8s cumul\u00e9s GN=cumsum(nb_gueris) # Nombre de gu\u00e9ris cumul\u00e9s LP = length(PT) LT = length(TT) LD = length(DN) LG = length(GN) Construction d\u2019un vecteur du nombre de jours \u00e9coul\u00e9 depuis le 19 mars jusqu\u2019au 11mai : temps = seq(from=1,to=54, by=1) Nous avons repr\u00e9sent\u00e9 ci-dessous l\u2019\u00e9volution du nombre de tests r\u00e9alis\u00e9s (courbe noire) et celle du nombre de tests positifs (courbe bleue) au cours du premier confinement. plot(temps,TT,xlab=\"Temps \u00e9coul\u00e9 depuis le 19 mars (en jours)\",ylab=\"Nombre cumul\u00e9 de tests\",pch=16, col=\"black\",main=\"Evolution des nombres de tests r\u00e9alis\u00e9s et de tests positifs au cours du premier confinement\") points(temps,PT,xlab=\"Temps \u00e9coul\u00e9 depuis le 19 mars (en jours)\",ylab=\"Nombre de tests positifs\",pch=16, col=\"blue\") legend(\"topleft\",legend=c(\"Nombre cumul\u00e9 de tests r\u00e9alis\u00e9s\",\"Nombre cumul\u00e9 de tests positifs\"),pch=16,col=c(\"black\",\"blue\"),bty=\"n\") Nous avons repr\u00e9sent\u00e9 ci-dessous l\u2019\u00e9volution du nombre de patients gu\u00e9ris (courbe verte) et celle du nombre de d\u00e9c\u00e8s (courbe rouge) au cours du premier confinement. plot(temps,GN,xlab=\"Temps \u00e9coul\u00e9 depuis le 19 mars (en jours)\",ylab=\"Nombre cumul\u00e9 de cas\",pch=16, col=\"dark green\",main=\"Evolution des nombres de patients test\u00e9s positifs, gu\u00e9ris ou d\u00e9c\u00e9d\u00e9s au cours du premier confinement\") points(temps,DN,xlab=\"Temps \u00e9coul\u00e9 depuis le 19 mars (en jours)\",ylab=\"Nombre de d\u00e9c\u00e8s\",pch=16,col=\"red\") points(temps,PT,xlab=\"Temps \u00e9coul\u00e9 depuis le 19 mars (en jours)\",ylab=\"Nombre de tests positifs\",pch=16, col=\"blue\") legend(\"topleft\",legend=c(\"Nombre cumul\u00e9 de patients gu\u00e9ris\",\"Nombre cumul\u00e9 de patients d\u00e9c\u00e9d\u00e9s\",\"Nombre cumul\u00e9 de tests positifs\"),pch=16,col=c(\"dark green\",\"red\",\"blue\"),bty=\"n\") Nous avons repr\u00e9sent\u00e9 ci-dessous la proportion du nombre cumul\u00e9 de tests positifs sur le nombre cumul\u00e9 de tests r\u00e9alis\u00e9s (courbe bleue) au cours du premier confinement. PP = PT/TT # proportion de tests positifs plot(temps,PP,xlab=\"Temps \u00e9coul\u00e9 depuis le 19 mars (en jours)\",ylab=\"Proportion de tests positifs\",pch=16, col=\"blue\", main=\"Proportion du nombre de tests positifs sur le nombre de tests r\u00e9alis\u00e9s au cours du premier confinement\") Afin de pouvoir \u00e9tudier l\u2019\u00e9volution du nombre de d\u00e9c\u00e8s durant le confinement, nous commen\u00e7ons notre \u00e9tude \u00e0 la date du 1er avril (13 jours apr\u00e8s le 19 mars), car les d\u00e9c\u00e8s sont retard\u00e9s d\u2019environ 2 semaines par rapport aux infections. tau = 13 # Pour commencer le 1er avril PT = PT[tau:LP] TT = TT[tau:LT] DN = DN[tau:LD] GN = GN[tau:LG] PP = PP[tau:length(PP)] Nous nous int\u00e9ressons maintenant au nombre de tests quotidiens effectu\u00e9s depuis le 1er avril : pt = nb_pos[tau:LP] # Nombre de tests positifs quotidiens depuis le 1er avril tt = nb_test[tau:LT] # Nombre de tests quotidiens depuis le 1er avril dn = nb_deces[tau:LD] # Nombre de d\u00e9c\u00e8s quotidiens depuis le 1er avril lt = length(tt) lp = length(pt) ld = length(dn) On red\u00e9fini un vecteur temps du nombre de jours \u00e9coul\u00e9 depuis le 1er avril jusqu\u2019au 11 mai : temps = seq(from=1,to=42, by=1) Nous repr\u00e9sentons ci-dessous l\u2019\u00e9volution quotidienne des nombres de tests r\u00e9alis\u00e9s (courbe noire) et de tests positifs (courbe bleue). plot(temps,tt,xlab=\"Temps \u00e9coul\u00e9 depuis le 1er avril (en jours)\",ylab=\"Nombre de tests quotidiens\",pch=16, col=\"black\",main = \"Evolution quotidienne des nombres de tests r\u00e9alis\u00e9s et de tests positifs\") points(temps,pt,xlab=\"Temps \u00e9coul\u00e9 depuis le 1er avril (en jours)\",ylab=\"Nombre de tests quotidiens positifs\",pch=16, col=\"blue\") legend(x=24, y=6000,legend=c(\"Nombre de tests quotidiens r\u00e9alis\u00e9s\",\"Nombre de tests positifs quotidiens\"),pch=16,col=c(\"black\",\"blue\")) Nous repr\u00e9sentons ci-dessous l\u2019\u00e9volution quotidienne du nombre de patients positifs (courbe bleue) et de patients d\u00e9c\u00e9d\u00e9s (courbe rouge). plot(temps,pt,xlab=\"Temps \u00e9coul\u00e9 depuis le 1er avril (en jours)\",ylab=\"Nombre de cas quotidiens\",pch=16,col=\"blue\",main= \"Evolution quotidienne des nombres de patients positifs et de patients d\u00e9c\u00e9d\u00e9s\") points(temps,dn,xlab=\"Temps \u00e9coul\u00e9 depuis le 1er avril (en jours)\",ylab=\"Nombre quotidien de d\u00e9c\u00e8s\",pch=16, col=\"red\") legend(\"topright\",legend=c(\"Nombre de tests quotidiens positifs\",\"Nombre quotidien de patients d\u00e9c\u00e9d\u00e9s\"),pch=16,col=c(\"blue\",\"red\"),bty=\"n\") Nous avons repr\u00e9sent\u00e9 ci-dessous la proportion de tests positifs quotidiens sur le nombre de tests r\u00e9alis\u00e9s quotidien (courbe bleue) au cours du premier confinement. pp = pt/tt # proportion de tests positifs quotidiens plot(temps,pp,xlab=\"Temps \u00e9coul\u00e9 depuis le 1er avril (en jours)\",ylab=\"Proportion de tests quotidiens positifs\",pch=16, col=\"blue\",main=\"Proportion de tests positifs quotidiens au cours du premier confinement\")","title":"Traitement des donn\u00e9es"},{"location":"TD4/#ajustement-du-modele-aux-donnees","text":"Nous d\u00e9finissons les param\u00e8tres de notre mod\u00e8le : N = 67e6 # Taille totale de la population gamma = 1/10 # Taux de gu\u00e9rison (par jour) R_0 = 3 # Reproductivit\u00e9 du virus beta = gamma*R_0 # R0 = beta/gamma sigma = 0.7 # Sensibilit\u00e9 des tests PCR kappa = 5e-3 # Biais d'observation alpha = 0.01 # Taux de mortalit\u00e9 t0 = 1 # Correspond au 1er avril, la date du d\u00e9but de l'\u00e9tude theta0 = c(beta,kappa,alpha) # Vecteur des param\u00e8tres \u00e0 estimer Nous d\u00e9finissons les conditions initiales du mod\u00e8le : I0 = 1.5e6 # On fixe le nombre initial d'infect\u00e9s d'apr\u00e8s Roques et al 2020 R0 = N*0.01 # Inconnue : on suppose qu'au 1er avril il y avait 1% d'immunis\u00e9s D0 = DN[1] # On se sert de la donn\u00e9e initiale S0 = N-I0-R0-D0 X0 = c(S0,I0,D0) # Vecteur d'\u00e9tat Le temps est d\u00e9fini ci-dessous : t = t0:lt La fonction du mod\u00e8le SIRD : SIRD = function(t, X, P){ # X : vecteur d'\u00e9tat; P : param\u00e8tres du mod\u00e8le beta = P[1] ; alpha = P[2] S = X[1] ; I = X[2] ; D = X[3] y = beta*S*I/N # Nombre de nouvelles infections par jour dS = -y dI = +y - gamma*I - alpha*I dD = +alpha*I dX = c(dS,dI,dD) # Variations de S, I et D mises \u00e0 jour return(list(dX)) } La fonction qui calcule la vraisemblance des param\u00e8tres est d\u00e9finie ci-dessous : logLike = function(theta){ # theta : vecteur des param\u00e8tres \u00e0 estimer beta = theta[1] kappa = theta[2] alpha = theta[3] P = c(beta,alpha) X = ode(X0,t,SIRD,P) # X : vecteur des solutions du mod\u00e8le SIRD # Proportion th\u00e9orique de tests quotidiens positifs d'apr\u00e8s le mod\u00e8le p1 = sigma*X[,3]/(X[,3]+kappa*X[,2]) # Vraisemblance : calcule la probabilit\u00e9 d'observer pt en connaissant la probabilit\u00e9 th\u00e9orique p1 qu'un test soit positif (loi binomiale) et d'observer dn en connaissant la quantit\u00e9 th\u00e9orique quotidienne de d\u00e9c\u00e8s bas\u00e9e sur le taux de mortalit\u00e9 alpha (loi de poisson) L = dbinom(pt, tt, p1, log=TRUE) + dpois(dn, alpha*X[,3], log=TRUE) LL = sum(L) return(LL) } Nous cherchons ensuite \u00e0 estimer et optimiser le jeu de param\u00e8tres \\theta = \\{\\beta, \\kappa, \\alpha\\} de notre mod\u00e8le \u00e0 partir des estimations initiales \\theta_0 = \\{\\beta_0, \\kappa_0, \\alpha_0\\} \u00e0 l\u2019aide d\u2019une fonction optimisant la vraisemblance ( logLike ) : opt = optim(theta0,logLike,control=list(fnscale=-1)) beta = opt$par[1] # On extrait les param\u00e8tres optimis\u00e9s par notre mod\u00e8le kappa = opt$par[2] alpha = opt$par[3] P = c(beta,alpha) # P est le vecteur des param\u00e8tres utilis\u00e9s pour la r\u00e9solution des \u00e9quations diff\u00e9rentielles print(paste(\"beta =\",beta,\"; alpha =\",alpha,\"; kappa =\",kappa)) Nous trouvons \\beta \\approx 0.04 , \\alpha \\approx 5.84\\times 10^{-4} , et \\kappa \\approx 0.05 . Nous utilisons ensuite nos param\u00e8tres optimis\u00e9s pour r\u00e9soudre notre syst\u00e8me d\u2019\u00e9quations diff\u00e9rentielles. t = t0:42 # X : vecteur des solutions du mod\u00e8le SIRD avec les param\u00e8tres optimis\u00e9s X = ode(X0,t,SIRD,P) Nous repr\u00e9sentons ensuite sur un graphique les \u00e9volutions du nombre de tests positifs observ\u00e9es (courbe bleue) et th\u00e9oriques (courbe noire) calcul\u00e9es \u00e0 partir du mod\u00e8le afin de v\u00e9rifier la qualit\u00e9 de l\u2019ajustement du mod\u00e8le : p1 = sigma*X[,3]/(X[,3]+kappa*X[,2]) # Proportion th\u00e9orique de tests quotidiens positifs Sigma1 = cumsum(pt[t]) # Somme cumul\u00e9e du nombre de tests positifs observ\u00e9s Sigma2 = cumsum(tt[t]*p1) # Proportion de cas positifs cumul\u00e9e issue du mod\u00e8le plot(t, Sigma1, xlab = \"Temps \u00e9coul\u00e9 depuis le 1er avril (en jours)\", ylab = \"Nombres de tests positifs th\u00e9oriques et observ\u00e9s\", main= \"Evolutions du nombre de tests positifs observ\u00e9es et th\u00e9oriques\",pch=16, col = \"blue\") lines(t,Sigma2) legend(\"topleft\",legend=\"Nombre de tests positifs observ\u00e9\",pch=16,col=\"blue\",bty=\"n\") legend(x=0, y=24000,legend=\"Nombre de tests positifs th\u00e9orique\",lty=1,col=\"black\",bty=\"n\") Nous comparons \u00e9galement \u00e0 l\u2019aide du graphique ci-dessous les \u00e9volutions des proportions th\u00e9oriques (courbe noire) et observ\u00e9es (courbe bleue) des tests positifs quotidiens. plot(t,pp[t],xlab=\"Temps \u00e9coul\u00e9 depuis le 1er avril (en jours)\",ylab=\"Proportions de tests quotidiens positifs th\u00e9oriques et observ\u00e9es\", main=\"Evolutions des proportions th\u00e9oriques et observ\u00e9es des tests positifs quotidiens\",pch=16, col=\"blue\") lines(t,p1) # p1 : Proportion de tests positifs th\u00e9oriques legend(\"topright\",legend=\"Proportion de tests positifs observ\u00e9e\",pch=16,col=\"blue\",bty=\"n\") legend(x=21, y=0.30,legend=\"Proportion de tests positifs th\u00e9orique\",lty=1,col=\"black\",bty=\"n\") Les graphiques suivant repr\u00e9sentent les \u00e9volutions th\u00e9oriques du nombre de personnes infect\u00e9es au cours du temps, du nombre de personne saines et du nombre de personnes ayant \u00e9t\u00e9 infect\u00e9es depuis le d\u00e9but de l\u2019\u00e9pid\u00e9mie. plot(t,X[,3],col=\"blue\",xlab=\"Temps \u00e9coul\u00e9 depuis le 1er avril (en jours)\",ylab=\"Nombre de personnes infect\u00e9es\",pch=16, main=\"Evolution th\u00e9orique du nombre de personnes infect\u00e9es\") plot(t,X[,2],col=\"purple\",xlab=\"Temps \u00e9coul\u00e9 depuis le 1er avril (en jours)\",ylab=\"Nombre de personnes saines\",pch=16, main=\"Evolution du nombre th\u00e9orique de personnes saines\") plot(t,N-X[,2],xlab=\"Temps \u00e9coul\u00e9 depuis le 1er avril (en jours)\",ylab=\"Nombre de personnes ayant \u00e9t\u00e9 infect\u00e9es\",pch=16, main=\"Evolution du nombre th\u00e9orique de personnes ayant \u00e9t\u00e9 infect\u00e9es\") Nous repr\u00e9sentons les \u00e9volutions du nombre de d\u00e9c\u00e8s cumul\u00e9s th\u00e9oriques (courbe noire) et observ\u00e9es (courbe rouge). plot(temps,DN,col=\"red\",xlab=\"Temps \u00e9coul\u00e9 depuis le 1er avril (en jours)\",ylab=\"Nombre de d\u00e9c\u00e8s cumul\u00e9s\",pch=16,main=\"Evolutions du nombre de d\u00e9c\u00e8s cumul\u00e9s th\u00e9oriques et observ\u00e9es\") lines(t,X[,4]) legend(\"topleft\",legend=\"Nombre de d\u00e9c\u00e8s observ\u00e9s\",pch=16,col=\"red\",bty=\"n\") legend(x=-1, y=17000,legend=\"Nombre de d\u00e9c\u00e8s th\u00e9oriques\",lty=1,col=\"black\",bty=\"n\") Nous repr\u00e9sentons les \u00e9volutions du nombre de d\u00e9c\u00e8s quotidiens th\u00e9oriques (courbe noire) et observ\u00e9es (courbe rouge). plot(temps,dn,col=\"red\",xlab=\"Temps \u00e9coul\u00e9 depuis le 1er avril (en jours)\",ylab=\"Nombre de d\u00e9c\u00e8s quotidiens\",pch=16, main=\"Evolutions du nombre de d\u00e9c\u00e8s quotidiens th\u00e9oriques et observ\u00e9es\") lines(t,alpha*X[,3]) legend(\"bottomleft\",legend=\"Nombre de d\u00e9c\u00e8s quotidiens observ\u00e9\",pch=16,col=\"red\",bty=\"n\") legend(x=-1, y=200,legend=\"Nombre de d\u00e9c\u00e8s quotidiens th\u00e9orique\",lty=1,col=\"black\",bty=\"n\")","title":"Ajustement du mod\u00e8le aux donn\u00e9es"},{"location":"TD4/#estimation-de-la-reproductivite-du-virus","text":"A l\u2019aide de nos param\u00e8tres estim\u00e9s, nous sommes en mesure de calculer le nombre de reproduction effectif du virus au cours du confinement : \\mathcal R_e = \\frac{\\beta}{\\gamma+\\alpha}\\frac{S(t_0)}{N}\\,. R_e = beta/(gamma+alpha)*(S0/N) # Re : nombre de reproduction effectif du virus print(paste(\"R_e=\",R_e)) Nous trouvons \\mathcal R_e \\approx 0.42 , ce qui est coh\u00e9rent avec l'article de Roques et al 2020 . Nous pouvons \u00e9galement estimer le taux de l\u00e9talit\u00e9 (IFR) du virus durant le 1er confinement : IFR = alpha/(alpha+gamma) # Infection Fatality Ratio print(paste(\"IFR=\",IFR)) Nous trouvons un IFR de 0.58% , ce qui est comparable avec la valeur obtenue lors de la premi\u00e8re flamb\u00e9e, voir par exemple le pr\u00e9c\u00e9dent article des m\u00eames auteurs : Roques, L., Klein, E. K., Papaix, J., Sar, A., & Soubeyrand, S. (2020). Using early data to estimate the actual infection fatality ratio from COVID-19 in France. Biology, 9(5), 97.","title":"Estimation de la reproductivit\u00e9 du virus"},{"location":"TD5/","text":"Introduction \u00e0 la mod\u00e9lisation en \u00e9pid\u00e9miologie : COVID-19 - 2\u00e8me flamb\u00e9e Claire Gillier, Clara Gueguen, Sarah Lejosne, Louise Malot (M1 Agro Rennes), le 17 mars 2021. Edit\u00e9 par Fr\u00e9d\u00e9ric Hamelin et Marine Dorand (M1 MODE), le 12 mai 2021. Dans le cadre du projet de mod\u00e9lisation, nous avons travaill\u00e9 sur la deuxi\u00e8me flamb\u00e9e de l\u2019\u00e9pid\u00e9mie de COVID19 en France. C\u2019est-\u00e0-dire sur la p\u00e9riode s'\u00e9talant du 1er Septembre 2020 au 31 octobre 2020. Ce travail pr\u00e9sente l\u2019ajustement du mod\u00e8le SIR utilis\u00e9 dans l\u2019\u00e9tude des \u00e9pid\u00e9mies. Nous avons travaill\u00e9 avec R . Mod\u00e8le \u00e9pid\u00e9miologique Le mod\u00e8le SIR est compos\u00e9 de 3 compartiments S , I et R . On les d\u00e9finit de cette fa\u00e7on : S(t) : les individus susceptibles d\u2019\u00eatre infect\u00e9s \u00e0 la date t I(t) : les individus infect\u00e9s \u00e0 la date t R(t) : les individus remis \u00e0 la date t Le mod\u00e8le SIR a pour \u00e9quations: \\begin{eqnarray*} \\frac{\\mathrm{d} S(t)}{\\mathrm{d} t}&=& -\\frac{\\beta}{N} S(t)I(t)\\,,\\\\ \\frac{\\mathrm{d} I(t)}{\\mathrm{d} t}&=& \\frac{\\beta}{N}S(t)I(t) - \\gamma I(t)\\,,\\\\ \\frac{\\mathrm{d} R(t)}{\\mathrm{d} t}&=&\u2004\\gamma I(t)\\,. \\end{eqnarray*} avec les param\u00e8tres suivants : N : la taille de la population \\gamma : le taux de gu\u00e9rison \\beta : le taux d\u2019infection Ce sont des \"taux\" par unit\u00e9 de temps. Mod\u00e8le d'observation L'ajustement du mod\u00e8le se fera par maximisation de la vraisemblance ( likelihood en anglais). Cette m\u00e9thode consiste \u00e0 maximiser la probabilit\u00e9 des observations sachant les param\u00e8tres. Le mod\u00e8le d'observation d\u00e9finit la probabilit\u00e9 qu'un test soit positif au temps t\u200b d'apr\u00e8s le mod\u00e8le \u00e9pid\u00e9miologique : p(t)=\\frac{\\sigma I(t)}{I(t)+\\kappa S(t)}\\,, o\u00f9 \\sigma \u200b est la sensibilit\u00e9 des tests PCR (suppos\u00e9e connue) et \\kappa est probabilit\u00e9 relative pour les individus sensibles de se faire tester comparativement aux infect\u00e9s (\u00e0 estimer). Aussi, le nombre de tests positifs le jour t peut \u00eatre mod\u00e9lis\u00e9 comme un tirage dans une loi Binomiale de param\u00e8tres p(t) et n(t) (le nombre de tests r\u00e9alis\u00e9s le jour t ) : le nombre de nouveaux cas observ\u00e9s le jour t est c(t)\\sim \\mbox{Binomial}(n(t),p(t)) En admettant que les observations sont ind\u00e9pendantes conditionnellement au mod\u00e8le, la vraisemblance s'\u00e9crit : \\mbox{Like}(\\theta)=\\prod_{t=0}^{T} \\mbox{Prob}(\\mbox{observe }c(t)|\\mbox{ model predicts }p(t))\\,. Soit \\theta = \\{ \\beta, \\kappa \\} le vecteur des param\u00e8tres \u00e0 estimer. Rechercher les valeurs de \\theta qui maximisent la vraisemblance est \u00e9quivalent \u00e0 rechercher les valeurs de \\theta qui maximisent la log-vraisemblance, qui transforme le produit en somme : \\mbox{logLike}(\\theta)=\\log(\\mbox{Like}(\\theta))=\\sum_{t=0}^T \\log\\left (\\mbox{Prob}(\\mbox{observe }c(t)|\\mbox{ model predicts } p(t) )\\right)\\,. Nous travaillerons avec la log-vraisemblance. Traitement des donn\u00e9es Dans un premier temps, on s\u2019assure que l\u2019environnement de travail est vide. Les commandes suivantes effacent les variables ainsi que les fen\u00eatres cr\u00e9\u00e9es lors des ex\u00e9cutions pr\u00e9c\u00e9dentes. rm(list=ls()) graphics.off() Installation et chargement des packages : library(dplyr) # Permet de manipuler les donn\u00e9es library(deSolve) # Permet de r\u00e9soudre des \u00e9quations diff\u00e9rentielles ordinaires (EDO) Le package deSolve sera utilis\u00e9 pour simuler le mod\u00e8le SIR. Importation des donn\u00e9es Les donn\u00e9es de tests ont \u00e9t\u00e9 t\u00e9l\u00e9charg\u00e9es depuis le site suivant : Donn\u00e9es relatives aux r\u00e9sultats des tests virologiques COVID-19 | SI-DEP . La commande read.csv2 permet d\u2019importer un ficher csv de donn\u00e9es dans R . Il faut pr\u00e9ciser si la premi\u00e8re ligne header correspond aux noms de colonnes et quel est le s\u00e9parateur sep des donn\u00e9es. urldata = url(\"https://www.data.gouv.fr/fr/datasets/r/dd0de5d9-b5a5-4503-930a-7b08dc0adc7c\") data1 = read.csv2(urldata, header=TRUE, sep=\";\") Les commandes select et filter permettent ensuite de s\u00e9lectionner les colonnes souhait\u00e9es du tableau de donn\u00e9es et les valeurs. Dans le tableau de donn\u00e9es, on s\u00e9lectionne les colonnes jour pour les dates des tests, la colonne P correspond au nombre de tests positifs et la colonne test T correspond au nombre de tests totaux. Les lignes cl_age90 =0 indiquent les lignes o\u00f9 se trouvent les sommes des tests positifs (colonne P ) et la somme des tests r\u00e9alis\u00e9s (colonne T ) au jour t pour chaque jour et tout \u00e2ge confondu. data2<-data1 %>% select(jour,P,T,cl_age90) %>% filter(cl_age90==\"0\") Ensuite, on s\u00e9lectionne la p\u00e9riode sur laquelle on souhaite travailler. On s\u00e9lectionne la p\u00e9riode du 1er septembre 2020 au 31 octobre 2020 dans le but de mod\u00e9liser uniquement la flamb\u00e9e (qui sera suivie par un confinement). data<-filter(data2, jour>= \"2020-09-01\",jour<= \"2020-10-31\" ) # S\u00e9lection des dates PT=as.integer(as.character(data[,2])) # Tests positifs TT=as.integer(as.character(data[,3])) # Test totaux LP=length(PT) # Permet de conna\u00eetre la longueur du vecteur et donc de savoir combien de jours constituent la p\u00e9riode de la deuxi\u00e8me flamb\u00e9e LT=length(TT) Visualisation des donn\u00e9es Les graphiques suivants repr\u00e9sentent l\u2019\u00e9volution du nombre de tests (r\u00e9alis\u00e9s ou positifs) au cours du temps. plot(1:LT,TT,xlab=\"Temps \u00e9coul\u00e9 depuis le 1er septembre (en jours)\",ylab=\"Nombre de tests r\u00e9alis\u00e9s\",col=\"#AB0049\",pch=16, main=\"Evolution du nombre de tests r\u00e9alis\u00e9s et du nombre de tests positifs\") points(1:LP,PT,xlab=\"Temps \u00e9coul\u00e9 depuis le 1er septembre (en jours)\",ylab=\"Nombre de tests positifs\",col=\"#19796A\",pch=16) legend(1, 4e+05, c(\"Nombre total de tests\", \"Nombre de tests positifs\"),col=c(\"#AB0049\", \"#19796A\"), lty=1, cex = 0.8,lwd=2) Le graphique suivant montre l\u2019\u00e9volution de la proportion de test positifs dans le temps. On calcule PP qui correspond \u00e0 la proportion de tests positifs observ\u00e9s. PP=PT/TT plot(1:LP,PP,xlab=\"Temps \u00e9coul\u00e9 depuis le 1er septembre (en jours)\",ylab=\"Proportion de tests positifs\",col=\"#19796A\", pch=16, main=\"Evolution de la proportion de tests positifs\") legend(1, 0.15,c(\"Nombre de tests positifs\"),col=c(\"#19796A\"), lty=1, cex = 0.8, lwd=2) Ajustement du mod\u00e8le aux donn\u00e9es Initialisation du mod\u00e8le Valeurs initiales des param\u00e8tres : N=67e6 # Taille de la population fran\u00e7aise gamma=1/10 # Taux de gu\u00e9rison (inverse du temps moyen avant gu\u00e9rison) R_0=3 # Reproductivit\u00e9 du virus beta = gamma*R_0 # Taux de transmission du virus sigma = 0.7 # Sensibilit\u00e9 des tests kappa = 5e-3 # Biais d'observation En t\u2004=\u2004t_0 , les conditions initiales pour le mod\u00e8le SIR sont les suivantes : I_0 = I (t_0) : le nombre de personnes infect\u00e9es \u00e0 t= t_0 R_0 = R(t_0) = 5\\% \\times N : nombre d\u2019individus remis au d\u00e9but de la flamb\u00e9e S(t_0)\u2004=\u2004N\u2005\u2212\u2005I_0\u2005\u2212\u2005R_0 : nombre d\u2019individus susceptibles d\u2019\u00eatre infect\u00e9s On initialise \u00e9galement : X_0 =\u2004\\{ S_0, I_0 \\} : vecteur d\u2019\u00e9tat P_0\u2004=\u2004\\{ \\beta ,\u2006\\kappa \\} : vecteur des param\u00e8tres \u00e0 estimer Les conditions initiales sont : t0 = 1 # Date de d\u00e9part de la 2\u00e8me flambl\u00e9e : le 1er septembre I0 = 100000 # Nombre de personnes infectieuses le 1er septembre (estimation grossi\u00e8re) R0 = (5/100)*N # Nombre de personnes immunis\u00e9es au 1er septembre (estimation grossi\u00e8re) S0 = N-I0-R0 # Nombre de personnes susceptible d'\u00eatre infect\u00e9es X0 = c(S0,I0) # Vecteur d'\u00e9tat P0=c(beta,kappa) # Vecteur des param\u00e8tres a estimer t=t0:LT # Vecteur temps Il est difficile de trouver une estimation pr\u00e9cise de I_0 . Au 1er Septembre 2020, le nombre d\u2019individus infect\u00e9s et hospitalis\u00e9s est d\u2019environ 22 000, ce qui nous permet de prendre un I_0 \u00e9lev\u00e9. Apr\u00e8s diff\u00e9rents essais, il appara\u00eet que quel que soit I_0 appartenant \u00e0 un large intervalle, l'ajustement du mod\u00e8le est inchang\u00e9. Cet exercice ne permet pas d'estimer I_0 . On a donc fix\u00e9 I_0 a 100 000 individus. De la m\u00eame fa\u00e7on, nous avons donn\u00e9 une valeur arbitraire mais raisonnable \u00e0 R_0 . Cr\u00e9ation d\u2019une fonction SIR de fa\u00e7on \u00e0 simuler le mod\u00e8le SIR avec la fonction ode plus tard. La fonction ode est une fonction pr\u00e9d\u00e9finie dans R qui permet de r\u00e9soudre des \u00e9quations diff\u00e9rentielles ordinaires. SIR = function(t, X, P){ beta=P[1] S=X[1] I=X[2] y=beta*S*I/N # Nombre de nouvelles infections/jour dS = -y dI = +y - gamma*I dX=c(dS,dI) return(list(dX)) } Fonction de Vraisemblance La fonction logLike est une fonction qui calcule la vraisemblance des param\u00e8tres \\beta et \\gamma d'apr\u00e8s le mod\u00e8le : logLike=function(theta){ P=theta[1:2] # Vecteur des param\u00e8tres \u00e0 estimer beta=P[1] kappa=P[2] S0=N-I0-R0 X0=c(S0,I0) X=ode(X0,t,SIR,P) # La fonction \"ode\" permet de r\u00e9soudre des \u00e9quations diff\u00e9rentielles p=sigma*X[,3]/(X[,3]+kappa*X[,2]) # Probabilit\u00e9 qu'un test soit positif L=dbinom(PT, TT, p, log=TRUE) # dbinom = distribution binomiale LL=sum(L) # Log-vraisemblance return(LL) } Avec p la proportion th\u00e9orique des tests quotidiens positifs et L la probabilit\u00e9 d\u2019observer un nombre de tests positifs sachant le nombre total de tests r\u00e9alis\u00e9s. Maximisation de la vraisemblance La fonction d\u2019optimisation optim est une fonction pr\u00e9d\u00e9finie par R . Elle prend en arguments d'entr\u00e9e les valeurs initiales des param\u00e8tres pass\u00e9s en arguments dans la fonction logLike , la fonction logLike elle-m\u00eame ainsi qu\u2019un troisi\u00e8me argument : control=list(fnscale=-1) . Ce 3\u00e8me argument sert \u00e0 maximiser la quantit\u00e9 \u00e0 optimiser qui, par d\u00e9faut, est minimis\u00e9e. Nous appelons opt le r\u00e9sultat de l'optimisation. opt=optim(P0,logLike,control=list(fnscale=-1)) # Param\u00e8tres optimis\u00e9s beta=opt$par[1] kappa=opt$par[2] Les valeurs des param\u00e8tres optimis\u00e9s (qui maximisent la vraisemblance) sont les suivantes : \\beta\u2004\\approx\u20040.13 : taux d\u2019infection \\kappa \\approx 0.02 : probabilit\u00e9 qu\u2019une personne sensible se fasse tester relative \u00e0 une personne infect\u00e9e Dynamique \u00e9pid\u00e9mique avec les param\u00e8tres optimis\u00e9s On simule \u00e0 nouveau la dynamique \u00e9pid\u00e9mique avec les param\u00e8tres optimis\u00e9s ci-dessus \u00e0 l\u2019aide de la fonction pr\u00e9d\u00e9finie ode . Ensuite, on calcule p : la proportion th\u00e9orique de tests quotidiens positifs. X=ode(X0,t,SIR,beta) p=sigma*X[,3]/(X[,3]+kappa*X[,2]) On r\u00e9alise ensuite un graphe repr\u00e9sentant l\u2019\u00e9volution de la proportion de tests positifs observ\u00e9s, PP , et de la proportion th\u00e9orique de tests positifs calcul\u00e9s, p . plot(t,PP[t],pch=16,col=\"#A162A6\", xlab=\"Temps \u00e9coule depuis le 1er Septembre 2020 (en jours)\", ylab=\"Proportion de tests positifs quotidiens\", main=\"Proportions de tests positifs observ\u00e9s et th\u00e9oriques\") lines(t,p, lwd=2, col=\"#9CE06F\") legend(1, 0.15, legend=c(\"Tests positifs observ\u00e9s\", \"Tests positifs th\u00e9oriques\"),col=c(\"#A162A6\", \"#9CE06F\"), lty=1, cex = 0.8,lwd=2) Puis on compare \\sigma_1 (somme cumul\u00e9e des tests positifs observ\u00e9s) avec \\sigma_2 (somme cumul\u00e9e des tests positifs observ\u00e9s). On fait ensuite un graphique des sommes cumul\u00e9es ( cumsum ) des tests positifs th\u00e9oriques et observ\u00e9s. sigma1=cumsum(PT[t]) #nombre total de tests r\u00e9alis\u00e9s * proportion de tests positifs th\u00e9oriques sigma2=cumsum(TT[t]*p) plot(t,sigma1,pch=16,xlab=\"Temps \u00e9coule depuis le 1er septembre 2020 (en jours)\",ylab=\"Somme cumul\u00e9e des tests positifs\",col=\"#A162A6\", main = \"Comparaison des sommes cumul\u00e9es des tests positifs\") lines(t,sigma2,lwd=2, col = \"#9CE06F\" ) legend(1, 900000, legend=c(\"Tests positifs observ\u00e9s\", \"Tests positifs th\u00e9oriques\"), col=c(\"#A162A6\", \"#9CE06F\"), lty=1, cex = 0.8, lwd=2) En r\u00e9alisant un graphique des sommes cumul\u00e9es des tests positifs th\u00e9oriques et des tests positifs observ\u00e9s, on peut v\u00e9rifier que l'ajustement du mod\u00e8le aux donn\u00e9es semble tr\u00e8s bon. Estimation de la Reproductivit\u00e9 du virus Le mod\u00e8le est bien ajust\u00e9 et optimis\u00e9 aux donn\u00e9es \u00e9pid\u00e9miologiques. Cependant, ce mod\u00e8le ne prend pas en compte les d\u00e9c\u00e8s. L\u2019ajout d\u2019un compartiment d\u00e9c\u00e8s au mod\u00e8le permettrait d'estimer le taux de l\u00e9talit\u00e9 du virus lors de la deuxi\u00e8me flamb\u00e9e. On peut n\u00e9anmoins estimer la reproductivit\u00e9 du virus : \\mathcal R_e = \\frac{\\beta}{\\gamma}\\frac{S(t_0)}{N}\\,. R_e1 = (beta/gamma)*(S0/N) print(paste(\"R_e=\",R_e1)) On trouve une reproductivit\u00e9 \\mathcal R_e \\approx 1.30 . Pour aller plus loin : prise en compte des d\u00e9c\u00e8s Cette extension a \u00e9t\u00e9 r\u00e9alis\u00e9e par Marine Dorand dans le cadre d'un stage de M1 MODE en avril-mai 2021. Mod\u00e8le \u00e9pid\u00e9miologique On consid\u00e8re maintenant un mod\u00e8le de type SIRD : o\u00f9 \\alpha est le taux de mortalit\u00e9 induit par le virus (que nous avions n\u00e9glig\u00e9 jusqu'ici). Le mod\u00e8le s'\u00e9crit : \\begin{eqnarray} \\frac{\\mathrm{d}S}{\\mathrm{d}t}&=&-\\beta \\frac{I}{N}S\\,,\\\\ \\frac{\\mathrm{d}I}{\\mathrm{d}t}&=&\\beta \\frac{I}{N}S - (\\alpha+\\gamma)I\\,,\\\\ \\frac{\\mathrm{d}R}{\\mathrm{d}t}&=&\\gamma I\\,,\\\\ \\frac{\\mathrm{d}D}{\\mathrm{d}t}&=&\\alpha I\\,. \\end{eqnarray} Mod\u00e8le d'observation Nous faisons l'hypoth\u00e8se que le nombre de d\u00e9c\u00e8s cumul\u00e9s observ\u00e9 au jour t est tir\u00e9 dans une loi de Poisson de moyenne D(t) telle que donn\u00e9 par le mod\u00e8le : D_{\\small\\mbox{data}}(t)\\sim \\mbox{Poisson}\\left(D_{\\small\\mbox{model}}(t)\\right) En admettant que les observations sont ind\u00e9pendantes conditionnellement au mod\u00e8le, la vraisemblance s'\u00e9crit : \\mbox{Like}(\\theta)=\\prod_{t=0}^{T} \\mbox{Prob}(\\mbox{observe }c(t)|\\mbox{ model predicts }p(t))\\times \\mbox{Prob}(\\mbox{observe }D_{\\small\\mbox{data}}(t)|D_{\\small\\mbox{model}}(t))\\,. Soit \\theta = \\{ \\beta, \\kappa, \\alpha \\} le vecteur des param\u00e8tres \u00e0 estimer. Rechercher les valeurs de \\theta qui maximisent la vraisemblance est \u00e9quivalent \u00e0 rechercher les valeurs de \\theta qui maximisent la log-vraisemblance, qui transforme le produit en somme : \\mbox{logLike}(\\theta)=\\sum_{t=0}^T \\log\\left(\\mbox{Prob}(\\mbox{observe }c(t)|\\mbox{ model predicts }p(t))\\times \\mbox{Prob}(\\mbox{observe }D_{\\small\\mbox{data}}(t)|D_{\\small\\mbox{model}}(t))\\right)\\,. Nous travaillerons avec la log-vraisemblance. Traitement des donn\u00e9es On importe les donn\u00e9es de d\u00e9c\u00e8s : # Lien permanent vers les donn\u00e9es d'hospitalisations urlhosp = url(\"https://www.data.gouv.fr/fr/datasets/r/6fadff46-9efd-4c53-942a-54aca783c30c\") # Tableau li\u00e9 aux donn\u00e9es d'hospitalisations datahosp = read.csv2(urlhosp, header=TRUE, sep=\";\") Agr\u00e9gation des donn\u00e9es \u00e0 l\u2019\u00e9chelle de la France (tous les d\u00e9partements fran\u00e7ais) par jour : # Nombre de d\u00e9c\u00e8s par jour nb_deces = aggregate(incid_dc~ jour, data=datahosp, FUN = sum) On s\u00e9lectionne les donn\u00e9es du 1er septembre au 31 octobre : nb_deces <-filter(nb_deces, jour>= \"2020-09-01\",jour<= \"2020-10-31\" ) Construction du vecteur qui contient uniquement les donn\u00e9es de d\u00e9c\u00e8s : dc=nb_deces[,2] # Nombre de d\u00e9c\u00e8s dccum=cumsum(dc)-dc[1] # Nombre de d\u00e9c\u00e8s cumul\u00e9s depuis le 1er septembre LD=length(dc) On repr\u00e9sente l\u2019\u00e9volution du nombre de patients d\u00e9c\u00e9d\u00e9s cumul\u00e9s dans les h\u00f4pitaux depuis le 1er septembre : plot(1:LD,dccum,xlab=\"Temps \u00e9coul\u00e9 depuis le 1 septembre (en jours)\",ylab=\"Nombre cumul\u00e9 de d\u00e9c\u00e8s\",pch=16, col=\"dark green\",main=\"Evolution du nombre de patients d\u00e9c\u00e9d\u00e9s au cours de la deuxi\u00e8me flamb\u00e9e\") On repr\u00e9sente l\u2019\u00e9volution du nombre de patients d\u00e9c\u00e9d\u00e9s quotidiens dans les h\u00f4pitaux au cours de la deuxi\u00e8me flamb\u00e9e : plot(1:LD,dc,xlab=\"Temps \u00e9coul\u00e9 depuis le 1 septembre (en jours)\",ylab=\"Nombre cumul\u00e9 de d\u00e9c\u00e8s\",pch=16, col=\"dark green\",main=\"Evolution du nombre de patients d\u00e9c\u00e9d\u00e9s quotidiennement au cours de la deuxi\u00e8me flamb\u00e9e\") Ajustement du mod\u00e8le aux donn\u00e9es On initialise les param\u00e8tres du mod\u00e8le SIRD : N = 67e6 # Taille de la population fran\u00e7aise gamma = 1/10 # Taux de gu\u00e9rison (inverse du temps moyen avant gu\u00e9rison) R_0 = 3 # Reproductivit\u00e9 du virus beta = gamma*R_0 # Taux de transmission du virus sigma = 0.7 # Sensibilit\u00e9 des tests kappa = 5e-3 # Biais d'observation alpha = 0.01 # Taux de mortalit\u00e9 due au virus theta0 = c(beta,kappa,alpha) # Vecteur des param\u00e8tres \u00e0 estimer (estimations initiales) On choisit de commencer l'ajustement au 15 septembre pour tenir compte du d\u00e9calage temporel entre les infections et les d\u00e9c\u00e8s. On d\u00e9finit les conditions initiales : t0=15 # On choisit de commencer l'ajustement au 15 septembre t=t0:LD # Vecteur temps I0=100000 # On fixe le nombre initial d'infect\u00e9s \u00e0 100 000 (estimation grossi\u00e8re) R0=5/100*N # On suppose qu'au 1er avril il y a 5% d'immunis\u00e9s (estimation grossi\u00e8re) D0=dccum[t0] # Nombre de d\u00e9c\u00e8s au 1er septembre S0=N-I0-R0-D0 # Nombre de personnes susceptibles d'\u00eatres infect\u00e9es X0=c(S0,I0,D0) # Vecteur d'\u00e9tat (conditions initiales) On cr\u00e9e une fonction qui simule le mod\u00e8le SIRD : SIRD = function(t, X, P){ beta = P[1] ; alpha = P[2] S = X[1] ; I = X[2] ; D = X[3] y = beta*S*I/N # Nouvelles infections par unit\u00e9 de temps dS = -y dI = +y - gamma*I - alpha*I dD = +alpha*I dX = c(dS,dI,dD) return(list(dX)) } On cr\u00e9e une fonction qui calcule la vraisemblance des param\u00e8tres : logLike = function(theta){ beta = theta[1] kappa = theta[2] alpha = theta[3] P = c(beta,alpha) X = ode(X0,t,SIRD,P) # Proportion th\u00e9orique de tests quotidiens positifs d'apr\u00e8s le mod\u00e8le p = sigma*X[,3]/(X[,3]+kappa*X[,2]) dcth = alpha*X[,3] # D\u00e9c\u00e8s th\u00e9oriques LLT = dbinom(PT[t], TT[t], p, log=TRUE) # Pr(observer \"PT\" test positifs au temps t) LLD = dpois(dc[t], dcth, log=TRUE) # Probabilit\u00e9 d'observer \"dc\" d\u00e9c\u00e8s au temps t LL = sum(c(LLT,LLD)) return(LL) } On optimise la vraisemblance donn\u00e9e par la fonction LogLike : opt = optim(theta0,logLike,control=list(fnscale=-1)) On r\u00e9cup\u00e8re les param\u00e8tres optimaux : beta = opt$par[1] kappa = opt$par[2] alpha = opt$par[3] P0 = c(beta,alpha) # Vecteur des param\u00e8tres mis \u00e0 jour On calcule la solution du mod\u00e8le pour les param\u00e8tres estim\u00e9s : X = ode(X0,t,SIRD,P0) p=sigma*X[,3]/(X[,3]+kappa*X[,2]) On repr\u00e9sente les \u00e9volutions du nombre de d\u00e9c\u00e8s cumul\u00e9s th\u00e9oriques (courbe noire) et observ\u00e9s (courbe rouge) : plot(1:LD,dccum,col=\"red\",xlab=\"Temps \u00e9coul\u00e9 depuis le 1er septembre (en jours)\",ylab=\"Nombre de d\u00e9c\u00e8s cumul\u00e9s\",pch=16,main=\"Evolutions du nombre de d\u00e9c\u00e8s cumul\u00e9s th\u00e9oriques et observ\u00e9s\") lines(t,X[,4]) legend(\"topleft\",legend=\"Nombre de d\u00e9c\u00e8s observ\u00e9s\",pch=16,col=\"red\",bty=\"n\") legend(x=-2, y=4700,legend=\"Nombre de d\u00e9c\u00e8s th\u00e9oriques\",lty=1,col=\"black\",bty=\"n\") On repr\u00e9sente l' \u00e9volution du nombre de d\u00e9c\u00e8s quotidiens th\u00e9oriques (courbe noire) et observ\u00e9s (courbe rouge). plot(1:LD,dc,col=\"red\",xlab=\"Temps \u00e9coul\u00e9 depuis le 1er septembre (en jours)\",ylab=\"Nombre de d\u00e9c\u00e8s quotidiens\",pch=16, main=\"Evolutions du nombre de d\u00e9c\u00e8s quotidiens th\u00e9oriques et observ\u00e9s\") lines(t,alpha*X[,3]) legend(\"topleft\",legend=\"Nombre de d\u00e9c\u00e8s quotidiens observ\u00e9s\",pch=16,col=\"red\",bty=\"n\") legend(x=-2, y=280,legend=\"Nombre de d\u00e9c\u00e8s quotidiens th\u00e9oriques\",lty=1,col=\"black\",bty=\"n\") Le mod\u00e8le ne parvient pas \u00e0 capturer l'acc\u00e9l\u00e9ration de l'\u00e9pid\u00e9mie \u00e0 partir de la mi-octobre. On r\u00e9alise de nouveau un graphe repr\u00e9sentant l\u2019\u00e9volution de la proportion de tests positifs observ\u00e9s, PP , et de la proportion th\u00e9orique de tests positifs calcul\u00e9s, p , avec le nouveau mod\u00e8le SIRD. plot(t,PP[t],pch=16,col=\"#A162A6\", xlab=\"Temps \u00e9coule depuis le 1er Septembre 2020 (en jours)\", ylab=\"Proportion de tests positifs quotidiens\", main = \"Proportions de tests positifs observ\u00e9s et th\u00e9oriques\") lines(t,p, lwd=2, col=\"#9CE06F\") legend(15, 0.15, legend=c(\"Tests positifs observ\u00e9s\", \"Tests positifs th\u00e9oriques\"),col=c(\"#A162A6\", \"#9CE06F\"), lty=1, cex = 0.8,lwd=2) Puis, on compare \\sigma_1 (somme cumul\u00e9e des tests positifs observ\u00e9s) avec \\sigma_2 (somme cumul\u00e9e des tests positifs observ\u00e9s) obtenues avec le nouveau mod\u00e8le SIRD. On fait ensuite un graphique des sommes cumul\u00e9es des tests positifs th\u00e9oriques du mod\u00e8le SIRD et observ\u00e9s. sigma1=cumsum(PT[t]) sigma2=cumsum(TT[t]*p) #nombre total de tests r\u00e9alis\u00e9s * proportion de tests positifs th\u00e9oriques plot(t,sigma1,pch=16,xlab=\"Temps \u00e9coule depuis le 1er septembre 2020 (en jour)\",ylab=\"Somme cumul\u00e9e des tests positifs\",col=\"#A162A6\", main = \"Comparaison des sommes cumul\u00e9es des tests positifs\") lines(t,sigma2,lwd=2, col = \"#9CE06F\" ) legend(15, 900000, legend=c(\"Tests positifs observ\u00e9s\", \"Tests positifs th\u00e9oriques\"), col=c(\"#A162A6\", \"#9CE06F\"), lty=1, cex = 0.8, lwd=2) L'ajustement du mod\u00e8le SIRD est tr\u00e8s similaire \u00e0 celui du mod\u00e8le SIR en termes de tests. Estimation de la l\u00e9talit\u00e9 du virus A l\u2019aide de nos param\u00e8tres estim\u00e9s, nous sommes en mesure de calculer le nombre de reproduction effectif du virus au cours de la deuxi\u00e8me flamb\u00e9e : R_e2 = beta/(gamma+alpha)*(S0/N) # Re : nombre de reproduction effectif du virus print(paste(\"R_e=\",R_e2)) On retrouve une reproductivit\u00e9 \\mathcal R_e \\approx 1.3 . Nous pouvons \u00e9galement estimer le taux de l\u00e9talit\u00e9 (IFR) du virus durant la 2eme flamb\u00e9e : IFR = alpha/(alpha+gamma) # Infection Fatality Ratio print(paste(\"IFR=\",IFR)) Nous trouvons un IFR de 0.45%, comparable \u00e0 celui estim\u00e9 lors de la premi\u00e8re flamb\u00e9e.","title":"TD5 (Septembre-Octobre 2020)"},{"location":"TD5/#introduction-a-la-modelisation-en-epidemiologie-covid-19-2eme-flambee","text":"Claire Gillier, Clara Gueguen, Sarah Lejosne, Louise Malot (M1 Agro Rennes), le 17 mars 2021. Edit\u00e9 par Fr\u00e9d\u00e9ric Hamelin et Marine Dorand (M1 MODE), le 12 mai 2021. Dans le cadre du projet de mod\u00e9lisation, nous avons travaill\u00e9 sur la deuxi\u00e8me flamb\u00e9e de l\u2019\u00e9pid\u00e9mie de COVID19 en France. C\u2019est-\u00e0-dire sur la p\u00e9riode s'\u00e9talant du 1er Septembre 2020 au 31 octobre 2020. Ce travail pr\u00e9sente l\u2019ajustement du mod\u00e8le SIR utilis\u00e9 dans l\u2019\u00e9tude des \u00e9pid\u00e9mies. Nous avons travaill\u00e9 avec R .","title":"Introduction \u00e0 la mod\u00e9lisation en \u00e9pid\u00e9miologie : COVID-19 - 2\u00e8me flamb\u00e9e"},{"location":"TD5/#modele-epidemiologique","text":"Le mod\u00e8le SIR est compos\u00e9 de 3 compartiments S , I et R . On les d\u00e9finit de cette fa\u00e7on : S(t) : les individus susceptibles d\u2019\u00eatre infect\u00e9s \u00e0 la date t I(t) : les individus infect\u00e9s \u00e0 la date t R(t) : les individus remis \u00e0 la date t Le mod\u00e8le SIR a pour \u00e9quations: \\begin{eqnarray*} \\frac{\\mathrm{d} S(t)}{\\mathrm{d} t}&=& -\\frac{\\beta}{N} S(t)I(t)\\,,\\\\ \\frac{\\mathrm{d} I(t)}{\\mathrm{d} t}&=& \\frac{\\beta}{N}S(t)I(t) - \\gamma I(t)\\,,\\\\ \\frac{\\mathrm{d} R(t)}{\\mathrm{d} t}&=&\u2004\\gamma I(t)\\,. \\end{eqnarray*} avec les param\u00e8tres suivants : N : la taille de la population \\gamma : le taux de gu\u00e9rison \\beta : le taux d\u2019infection Ce sont des \"taux\" par unit\u00e9 de temps.","title":"Mod\u00e8le \u00e9pid\u00e9miologique"},{"location":"TD5/#modele-dobservation","text":"L'ajustement du mod\u00e8le se fera par maximisation de la vraisemblance ( likelihood en anglais). Cette m\u00e9thode consiste \u00e0 maximiser la probabilit\u00e9 des observations sachant les param\u00e8tres. Le mod\u00e8le d'observation d\u00e9finit la probabilit\u00e9 qu'un test soit positif au temps t\u200b d'apr\u00e8s le mod\u00e8le \u00e9pid\u00e9miologique : p(t)=\\frac{\\sigma I(t)}{I(t)+\\kappa S(t)}\\,, o\u00f9 \\sigma \u200b est la sensibilit\u00e9 des tests PCR (suppos\u00e9e connue) et \\kappa est probabilit\u00e9 relative pour les individus sensibles de se faire tester comparativement aux infect\u00e9s (\u00e0 estimer). Aussi, le nombre de tests positifs le jour t peut \u00eatre mod\u00e9lis\u00e9 comme un tirage dans une loi Binomiale de param\u00e8tres p(t) et n(t) (le nombre de tests r\u00e9alis\u00e9s le jour t ) : le nombre de nouveaux cas observ\u00e9s le jour t est c(t)\\sim \\mbox{Binomial}(n(t),p(t)) En admettant que les observations sont ind\u00e9pendantes conditionnellement au mod\u00e8le, la vraisemblance s'\u00e9crit : \\mbox{Like}(\\theta)=\\prod_{t=0}^{T} \\mbox{Prob}(\\mbox{observe }c(t)|\\mbox{ model predicts }p(t))\\,. Soit \\theta = \\{ \\beta, \\kappa \\} le vecteur des param\u00e8tres \u00e0 estimer. Rechercher les valeurs de \\theta qui maximisent la vraisemblance est \u00e9quivalent \u00e0 rechercher les valeurs de \\theta qui maximisent la log-vraisemblance, qui transforme le produit en somme : \\mbox{logLike}(\\theta)=\\log(\\mbox{Like}(\\theta))=\\sum_{t=0}^T \\log\\left (\\mbox{Prob}(\\mbox{observe }c(t)|\\mbox{ model predicts } p(t) )\\right)\\,. Nous travaillerons avec la log-vraisemblance.","title":"Mod\u00e8le d'observation"},{"location":"TD5/#traitement-des-donnees","text":"Dans un premier temps, on s\u2019assure que l\u2019environnement de travail est vide. Les commandes suivantes effacent les variables ainsi que les fen\u00eatres cr\u00e9\u00e9es lors des ex\u00e9cutions pr\u00e9c\u00e9dentes. rm(list=ls()) graphics.off() Installation et chargement des packages : library(dplyr) # Permet de manipuler les donn\u00e9es library(deSolve) # Permet de r\u00e9soudre des \u00e9quations diff\u00e9rentielles ordinaires (EDO) Le package deSolve sera utilis\u00e9 pour simuler le mod\u00e8le SIR.","title":"Traitement des donn\u00e9es"},{"location":"TD5/#importation-des-donnees","text":"Les donn\u00e9es de tests ont \u00e9t\u00e9 t\u00e9l\u00e9charg\u00e9es depuis le site suivant : Donn\u00e9es relatives aux r\u00e9sultats des tests virologiques COVID-19 | SI-DEP . La commande read.csv2 permet d\u2019importer un ficher csv de donn\u00e9es dans R . Il faut pr\u00e9ciser si la premi\u00e8re ligne header correspond aux noms de colonnes et quel est le s\u00e9parateur sep des donn\u00e9es. urldata = url(\"https://www.data.gouv.fr/fr/datasets/r/dd0de5d9-b5a5-4503-930a-7b08dc0adc7c\") data1 = read.csv2(urldata, header=TRUE, sep=\";\") Les commandes select et filter permettent ensuite de s\u00e9lectionner les colonnes souhait\u00e9es du tableau de donn\u00e9es et les valeurs. Dans le tableau de donn\u00e9es, on s\u00e9lectionne les colonnes jour pour les dates des tests, la colonne P correspond au nombre de tests positifs et la colonne test T correspond au nombre de tests totaux. Les lignes cl_age90 =0 indiquent les lignes o\u00f9 se trouvent les sommes des tests positifs (colonne P ) et la somme des tests r\u00e9alis\u00e9s (colonne T ) au jour t pour chaque jour et tout \u00e2ge confondu. data2<-data1 %>% select(jour,P,T,cl_age90) %>% filter(cl_age90==\"0\") Ensuite, on s\u00e9lectionne la p\u00e9riode sur laquelle on souhaite travailler. On s\u00e9lectionne la p\u00e9riode du 1er septembre 2020 au 31 octobre 2020 dans le but de mod\u00e9liser uniquement la flamb\u00e9e (qui sera suivie par un confinement). data<-filter(data2, jour>= \"2020-09-01\",jour<= \"2020-10-31\" ) # S\u00e9lection des dates PT=as.integer(as.character(data[,2])) # Tests positifs TT=as.integer(as.character(data[,3])) # Test totaux LP=length(PT) # Permet de conna\u00eetre la longueur du vecteur et donc de savoir combien de jours constituent la p\u00e9riode de la deuxi\u00e8me flamb\u00e9e LT=length(TT)","title":"Importation des donn\u00e9es"},{"location":"TD5/#visualisation-des-donnees","text":"Les graphiques suivants repr\u00e9sentent l\u2019\u00e9volution du nombre de tests (r\u00e9alis\u00e9s ou positifs) au cours du temps. plot(1:LT,TT,xlab=\"Temps \u00e9coul\u00e9 depuis le 1er septembre (en jours)\",ylab=\"Nombre de tests r\u00e9alis\u00e9s\",col=\"#AB0049\",pch=16, main=\"Evolution du nombre de tests r\u00e9alis\u00e9s et du nombre de tests positifs\") points(1:LP,PT,xlab=\"Temps \u00e9coul\u00e9 depuis le 1er septembre (en jours)\",ylab=\"Nombre de tests positifs\",col=\"#19796A\",pch=16) legend(1, 4e+05, c(\"Nombre total de tests\", \"Nombre de tests positifs\"),col=c(\"#AB0049\", \"#19796A\"), lty=1, cex = 0.8,lwd=2) Le graphique suivant montre l\u2019\u00e9volution de la proportion de test positifs dans le temps. On calcule PP qui correspond \u00e0 la proportion de tests positifs observ\u00e9s. PP=PT/TT plot(1:LP,PP,xlab=\"Temps \u00e9coul\u00e9 depuis le 1er septembre (en jours)\",ylab=\"Proportion de tests positifs\",col=\"#19796A\", pch=16, main=\"Evolution de la proportion de tests positifs\") legend(1, 0.15,c(\"Nombre de tests positifs\"),col=c(\"#19796A\"), lty=1, cex = 0.8, lwd=2)","title":"Visualisation des donn\u00e9es"},{"location":"TD5/#ajustement-du-modele-aux-donnees","text":"","title":"Ajustement du mod\u00e8le aux donn\u00e9es"},{"location":"TD5/#initialisation-du-modele","text":"Valeurs initiales des param\u00e8tres : N=67e6 # Taille de la population fran\u00e7aise gamma=1/10 # Taux de gu\u00e9rison (inverse du temps moyen avant gu\u00e9rison) R_0=3 # Reproductivit\u00e9 du virus beta = gamma*R_0 # Taux de transmission du virus sigma = 0.7 # Sensibilit\u00e9 des tests kappa = 5e-3 # Biais d'observation En t\u2004=\u2004t_0 , les conditions initiales pour le mod\u00e8le SIR sont les suivantes : I_0 = I (t_0) : le nombre de personnes infect\u00e9es \u00e0 t= t_0 R_0 = R(t_0) = 5\\% \\times N : nombre d\u2019individus remis au d\u00e9but de la flamb\u00e9e S(t_0)\u2004=\u2004N\u2005\u2212\u2005I_0\u2005\u2212\u2005R_0 : nombre d\u2019individus susceptibles d\u2019\u00eatre infect\u00e9s On initialise \u00e9galement : X_0 =\u2004\\{ S_0, I_0 \\} : vecteur d\u2019\u00e9tat P_0\u2004=\u2004\\{ \\beta ,\u2006\\kappa \\} : vecteur des param\u00e8tres \u00e0 estimer Les conditions initiales sont : t0 = 1 # Date de d\u00e9part de la 2\u00e8me flambl\u00e9e : le 1er septembre I0 = 100000 # Nombre de personnes infectieuses le 1er septembre (estimation grossi\u00e8re) R0 = (5/100)*N # Nombre de personnes immunis\u00e9es au 1er septembre (estimation grossi\u00e8re) S0 = N-I0-R0 # Nombre de personnes susceptible d'\u00eatre infect\u00e9es X0 = c(S0,I0) # Vecteur d'\u00e9tat P0=c(beta,kappa) # Vecteur des param\u00e8tres a estimer t=t0:LT # Vecteur temps Il est difficile de trouver une estimation pr\u00e9cise de I_0 . Au 1er Septembre 2020, le nombre d\u2019individus infect\u00e9s et hospitalis\u00e9s est d\u2019environ 22 000, ce qui nous permet de prendre un I_0 \u00e9lev\u00e9. Apr\u00e8s diff\u00e9rents essais, il appara\u00eet que quel que soit I_0 appartenant \u00e0 un large intervalle, l'ajustement du mod\u00e8le est inchang\u00e9. Cet exercice ne permet pas d'estimer I_0 . On a donc fix\u00e9 I_0 a 100 000 individus. De la m\u00eame fa\u00e7on, nous avons donn\u00e9 une valeur arbitraire mais raisonnable \u00e0 R_0 . Cr\u00e9ation d\u2019une fonction SIR de fa\u00e7on \u00e0 simuler le mod\u00e8le SIR avec la fonction ode plus tard. La fonction ode est une fonction pr\u00e9d\u00e9finie dans R qui permet de r\u00e9soudre des \u00e9quations diff\u00e9rentielles ordinaires. SIR = function(t, X, P){ beta=P[1] S=X[1] I=X[2] y=beta*S*I/N # Nombre de nouvelles infections/jour dS = -y dI = +y - gamma*I dX=c(dS,dI) return(list(dX)) }","title":"Initialisation du mod\u00e8le"},{"location":"TD5/#fonction-de-vraisemblance","text":"La fonction logLike est une fonction qui calcule la vraisemblance des param\u00e8tres \\beta et \\gamma d'apr\u00e8s le mod\u00e8le : logLike=function(theta){ P=theta[1:2] # Vecteur des param\u00e8tres \u00e0 estimer beta=P[1] kappa=P[2] S0=N-I0-R0 X0=c(S0,I0) X=ode(X0,t,SIR,P) # La fonction \"ode\" permet de r\u00e9soudre des \u00e9quations diff\u00e9rentielles p=sigma*X[,3]/(X[,3]+kappa*X[,2]) # Probabilit\u00e9 qu'un test soit positif L=dbinom(PT, TT, p, log=TRUE) # dbinom = distribution binomiale LL=sum(L) # Log-vraisemblance return(LL) } Avec p la proportion th\u00e9orique des tests quotidiens positifs et L la probabilit\u00e9 d\u2019observer un nombre de tests positifs sachant le nombre total de tests r\u00e9alis\u00e9s.","title":"Fonction de Vraisemblance"},{"location":"TD5/#maximisation-de-la-vraisemblance","text":"La fonction d\u2019optimisation optim est une fonction pr\u00e9d\u00e9finie par R . Elle prend en arguments d'entr\u00e9e les valeurs initiales des param\u00e8tres pass\u00e9s en arguments dans la fonction logLike , la fonction logLike elle-m\u00eame ainsi qu\u2019un troisi\u00e8me argument : control=list(fnscale=-1) . Ce 3\u00e8me argument sert \u00e0 maximiser la quantit\u00e9 \u00e0 optimiser qui, par d\u00e9faut, est minimis\u00e9e. Nous appelons opt le r\u00e9sultat de l'optimisation. opt=optim(P0,logLike,control=list(fnscale=-1)) # Param\u00e8tres optimis\u00e9s beta=opt$par[1] kappa=opt$par[2] Les valeurs des param\u00e8tres optimis\u00e9s (qui maximisent la vraisemblance) sont les suivantes : \\beta\u2004\\approx\u20040.13 : taux d\u2019infection \\kappa \\approx 0.02 : probabilit\u00e9 qu\u2019une personne sensible se fasse tester relative \u00e0 une personne infect\u00e9e","title":"Maximisation de la vraisemblance"},{"location":"TD5/#dynamique-epidemique-avec-les-parametres-optimises","text":"On simule \u00e0 nouveau la dynamique \u00e9pid\u00e9mique avec les param\u00e8tres optimis\u00e9s ci-dessus \u00e0 l\u2019aide de la fonction pr\u00e9d\u00e9finie ode . Ensuite, on calcule p : la proportion th\u00e9orique de tests quotidiens positifs. X=ode(X0,t,SIR,beta) p=sigma*X[,3]/(X[,3]+kappa*X[,2]) On r\u00e9alise ensuite un graphe repr\u00e9sentant l\u2019\u00e9volution de la proportion de tests positifs observ\u00e9s, PP , et de la proportion th\u00e9orique de tests positifs calcul\u00e9s, p . plot(t,PP[t],pch=16,col=\"#A162A6\", xlab=\"Temps \u00e9coule depuis le 1er Septembre 2020 (en jours)\", ylab=\"Proportion de tests positifs quotidiens\", main=\"Proportions de tests positifs observ\u00e9s et th\u00e9oriques\") lines(t,p, lwd=2, col=\"#9CE06F\") legend(1, 0.15, legend=c(\"Tests positifs observ\u00e9s\", \"Tests positifs th\u00e9oriques\"),col=c(\"#A162A6\", \"#9CE06F\"), lty=1, cex = 0.8,lwd=2) Puis on compare \\sigma_1 (somme cumul\u00e9e des tests positifs observ\u00e9s) avec \\sigma_2 (somme cumul\u00e9e des tests positifs observ\u00e9s). On fait ensuite un graphique des sommes cumul\u00e9es ( cumsum ) des tests positifs th\u00e9oriques et observ\u00e9s. sigma1=cumsum(PT[t]) #nombre total de tests r\u00e9alis\u00e9s * proportion de tests positifs th\u00e9oriques sigma2=cumsum(TT[t]*p) plot(t,sigma1,pch=16,xlab=\"Temps \u00e9coule depuis le 1er septembre 2020 (en jours)\",ylab=\"Somme cumul\u00e9e des tests positifs\",col=\"#A162A6\", main = \"Comparaison des sommes cumul\u00e9es des tests positifs\") lines(t,sigma2,lwd=2, col = \"#9CE06F\" ) legend(1, 900000, legend=c(\"Tests positifs observ\u00e9s\", \"Tests positifs th\u00e9oriques\"), col=c(\"#A162A6\", \"#9CE06F\"), lty=1, cex = 0.8, lwd=2) En r\u00e9alisant un graphique des sommes cumul\u00e9es des tests positifs th\u00e9oriques et des tests positifs observ\u00e9s, on peut v\u00e9rifier que l'ajustement du mod\u00e8le aux donn\u00e9es semble tr\u00e8s bon.","title":"Dynamique \u00e9pid\u00e9mique avec les param\u00e8tres optimis\u00e9s"},{"location":"TD5/#estimation-de-la-reproductivite-du-virus","text":"Le mod\u00e8le est bien ajust\u00e9 et optimis\u00e9 aux donn\u00e9es \u00e9pid\u00e9miologiques. Cependant, ce mod\u00e8le ne prend pas en compte les d\u00e9c\u00e8s. L\u2019ajout d\u2019un compartiment d\u00e9c\u00e8s au mod\u00e8le permettrait d'estimer le taux de l\u00e9talit\u00e9 du virus lors de la deuxi\u00e8me flamb\u00e9e. On peut n\u00e9anmoins estimer la reproductivit\u00e9 du virus : \\mathcal R_e = \\frac{\\beta}{\\gamma}\\frac{S(t_0)}{N}\\,. R_e1 = (beta/gamma)*(S0/N) print(paste(\"R_e=\",R_e1)) On trouve une reproductivit\u00e9 \\mathcal R_e \\approx 1.30 .","title":"Estimation de la Reproductivit\u00e9 du virus"},{"location":"TD5/#pour-aller-plus-loin-prise-en-compte-des-deces","text":"Cette extension a \u00e9t\u00e9 r\u00e9alis\u00e9e par Marine Dorand dans le cadre d'un stage de M1 MODE en avril-mai 2021.","title":"Pour aller plus loin : prise en compte des d\u00e9c\u00e8s"},{"location":"TD5/#modele-epidemiologique_1","text":"On consid\u00e8re maintenant un mod\u00e8le de type SIRD : o\u00f9 \\alpha est le taux de mortalit\u00e9 induit par le virus (que nous avions n\u00e9glig\u00e9 jusqu'ici). Le mod\u00e8le s'\u00e9crit : \\begin{eqnarray} \\frac{\\mathrm{d}S}{\\mathrm{d}t}&=&-\\beta \\frac{I}{N}S\\,,\\\\ \\frac{\\mathrm{d}I}{\\mathrm{d}t}&=&\\beta \\frac{I}{N}S - (\\alpha+\\gamma)I\\,,\\\\ \\frac{\\mathrm{d}R}{\\mathrm{d}t}&=&\\gamma I\\,,\\\\ \\frac{\\mathrm{d}D}{\\mathrm{d}t}&=&\\alpha I\\,. \\end{eqnarray}","title":"Mod\u00e8le \u00e9pid\u00e9miologique"},{"location":"TD5/#modele-dobservation_1","text":"Nous faisons l'hypoth\u00e8se que le nombre de d\u00e9c\u00e8s cumul\u00e9s observ\u00e9 au jour t est tir\u00e9 dans une loi de Poisson de moyenne D(t) telle que donn\u00e9 par le mod\u00e8le : D_{\\small\\mbox{data}}(t)\\sim \\mbox{Poisson}\\left(D_{\\small\\mbox{model}}(t)\\right) En admettant que les observations sont ind\u00e9pendantes conditionnellement au mod\u00e8le, la vraisemblance s'\u00e9crit : \\mbox{Like}(\\theta)=\\prod_{t=0}^{T} \\mbox{Prob}(\\mbox{observe }c(t)|\\mbox{ model predicts }p(t))\\times \\mbox{Prob}(\\mbox{observe }D_{\\small\\mbox{data}}(t)|D_{\\small\\mbox{model}}(t))\\,. Soit \\theta = \\{ \\beta, \\kappa, \\alpha \\} le vecteur des param\u00e8tres \u00e0 estimer. Rechercher les valeurs de \\theta qui maximisent la vraisemblance est \u00e9quivalent \u00e0 rechercher les valeurs de \\theta qui maximisent la log-vraisemblance, qui transforme le produit en somme : \\mbox{logLike}(\\theta)=\\sum_{t=0}^T \\log\\left(\\mbox{Prob}(\\mbox{observe }c(t)|\\mbox{ model predicts }p(t))\\times \\mbox{Prob}(\\mbox{observe }D_{\\small\\mbox{data}}(t)|D_{\\small\\mbox{model}}(t))\\right)\\,. Nous travaillerons avec la log-vraisemblance.","title":"Mod\u00e8le d'observation"},{"location":"TD5/#traitement-des-donnees_1","text":"On importe les donn\u00e9es de d\u00e9c\u00e8s : # Lien permanent vers les donn\u00e9es d'hospitalisations urlhosp = url(\"https://www.data.gouv.fr/fr/datasets/r/6fadff46-9efd-4c53-942a-54aca783c30c\") # Tableau li\u00e9 aux donn\u00e9es d'hospitalisations datahosp = read.csv2(urlhosp, header=TRUE, sep=\";\") Agr\u00e9gation des donn\u00e9es \u00e0 l\u2019\u00e9chelle de la France (tous les d\u00e9partements fran\u00e7ais) par jour : # Nombre de d\u00e9c\u00e8s par jour nb_deces = aggregate(incid_dc~ jour, data=datahosp, FUN = sum) On s\u00e9lectionne les donn\u00e9es du 1er septembre au 31 octobre : nb_deces <-filter(nb_deces, jour>= \"2020-09-01\",jour<= \"2020-10-31\" ) Construction du vecteur qui contient uniquement les donn\u00e9es de d\u00e9c\u00e8s : dc=nb_deces[,2] # Nombre de d\u00e9c\u00e8s dccum=cumsum(dc)-dc[1] # Nombre de d\u00e9c\u00e8s cumul\u00e9s depuis le 1er septembre LD=length(dc) On repr\u00e9sente l\u2019\u00e9volution du nombre de patients d\u00e9c\u00e9d\u00e9s cumul\u00e9s dans les h\u00f4pitaux depuis le 1er septembre : plot(1:LD,dccum,xlab=\"Temps \u00e9coul\u00e9 depuis le 1 septembre (en jours)\",ylab=\"Nombre cumul\u00e9 de d\u00e9c\u00e8s\",pch=16, col=\"dark green\",main=\"Evolution du nombre de patients d\u00e9c\u00e9d\u00e9s au cours de la deuxi\u00e8me flamb\u00e9e\") On repr\u00e9sente l\u2019\u00e9volution du nombre de patients d\u00e9c\u00e9d\u00e9s quotidiens dans les h\u00f4pitaux au cours de la deuxi\u00e8me flamb\u00e9e : plot(1:LD,dc,xlab=\"Temps \u00e9coul\u00e9 depuis le 1 septembre (en jours)\",ylab=\"Nombre cumul\u00e9 de d\u00e9c\u00e8s\",pch=16, col=\"dark green\",main=\"Evolution du nombre de patients d\u00e9c\u00e9d\u00e9s quotidiennement au cours de la deuxi\u00e8me flamb\u00e9e\")","title":"Traitement des donn\u00e9es"},{"location":"TD5/#ajustement-du-modele-aux-donnees_1","text":"On initialise les param\u00e8tres du mod\u00e8le SIRD : N = 67e6 # Taille de la population fran\u00e7aise gamma = 1/10 # Taux de gu\u00e9rison (inverse du temps moyen avant gu\u00e9rison) R_0 = 3 # Reproductivit\u00e9 du virus beta = gamma*R_0 # Taux de transmission du virus sigma = 0.7 # Sensibilit\u00e9 des tests kappa = 5e-3 # Biais d'observation alpha = 0.01 # Taux de mortalit\u00e9 due au virus theta0 = c(beta,kappa,alpha) # Vecteur des param\u00e8tres \u00e0 estimer (estimations initiales) On choisit de commencer l'ajustement au 15 septembre pour tenir compte du d\u00e9calage temporel entre les infections et les d\u00e9c\u00e8s. On d\u00e9finit les conditions initiales : t0=15 # On choisit de commencer l'ajustement au 15 septembre t=t0:LD # Vecteur temps I0=100000 # On fixe le nombre initial d'infect\u00e9s \u00e0 100 000 (estimation grossi\u00e8re) R0=5/100*N # On suppose qu'au 1er avril il y a 5% d'immunis\u00e9s (estimation grossi\u00e8re) D0=dccum[t0] # Nombre de d\u00e9c\u00e8s au 1er septembre S0=N-I0-R0-D0 # Nombre de personnes susceptibles d'\u00eatres infect\u00e9es X0=c(S0,I0,D0) # Vecteur d'\u00e9tat (conditions initiales) On cr\u00e9e une fonction qui simule le mod\u00e8le SIRD : SIRD = function(t, X, P){ beta = P[1] ; alpha = P[2] S = X[1] ; I = X[2] ; D = X[3] y = beta*S*I/N # Nouvelles infections par unit\u00e9 de temps dS = -y dI = +y - gamma*I - alpha*I dD = +alpha*I dX = c(dS,dI,dD) return(list(dX)) } On cr\u00e9e une fonction qui calcule la vraisemblance des param\u00e8tres : logLike = function(theta){ beta = theta[1] kappa = theta[2] alpha = theta[3] P = c(beta,alpha) X = ode(X0,t,SIRD,P) # Proportion th\u00e9orique de tests quotidiens positifs d'apr\u00e8s le mod\u00e8le p = sigma*X[,3]/(X[,3]+kappa*X[,2]) dcth = alpha*X[,3] # D\u00e9c\u00e8s th\u00e9oriques LLT = dbinom(PT[t], TT[t], p, log=TRUE) # Pr(observer \"PT\" test positifs au temps t) LLD = dpois(dc[t], dcth, log=TRUE) # Probabilit\u00e9 d'observer \"dc\" d\u00e9c\u00e8s au temps t LL = sum(c(LLT,LLD)) return(LL) } On optimise la vraisemblance donn\u00e9e par la fonction LogLike : opt = optim(theta0,logLike,control=list(fnscale=-1)) On r\u00e9cup\u00e8re les param\u00e8tres optimaux : beta = opt$par[1] kappa = opt$par[2] alpha = opt$par[3] P0 = c(beta,alpha) # Vecteur des param\u00e8tres mis \u00e0 jour On calcule la solution du mod\u00e8le pour les param\u00e8tres estim\u00e9s : X = ode(X0,t,SIRD,P0) p=sigma*X[,3]/(X[,3]+kappa*X[,2]) On repr\u00e9sente les \u00e9volutions du nombre de d\u00e9c\u00e8s cumul\u00e9s th\u00e9oriques (courbe noire) et observ\u00e9s (courbe rouge) : plot(1:LD,dccum,col=\"red\",xlab=\"Temps \u00e9coul\u00e9 depuis le 1er septembre (en jours)\",ylab=\"Nombre de d\u00e9c\u00e8s cumul\u00e9s\",pch=16,main=\"Evolutions du nombre de d\u00e9c\u00e8s cumul\u00e9s th\u00e9oriques et observ\u00e9s\") lines(t,X[,4]) legend(\"topleft\",legend=\"Nombre de d\u00e9c\u00e8s observ\u00e9s\",pch=16,col=\"red\",bty=\"n\") legend(x=-2, y=4700,legend=\"Nombre de d\u00e9c\u00e8s th\u00e9oriques\",lty=1,col=\"black\",bty=\"n\") On repr\u00e9sente l' \u00e9volution du nombre de d\u00e9c\u00e8s quotidiens th\u00e9oriques (courbe noire) et observ\u00e9s (courbe rouge). plot(1:LD,dc,col=\"red\",xlab=\"Temps \u00e9coul\u00e9 depuis le 1er septembre (en jours)\",ylab=\"Nombre de d\u00e9c\u00e8s quotidiens\",pch=16, main=\"Evolutions du nombre de d\u00e9c\u00e8s quotidiens th\u00e9oriques et observ\u00e9s\") lines(t,alpha*X[,3]) legend(\"topleft\",legend=\"Nombre de d\u00e9c\u00e8s quotidiens observ\u00e9s\",pch=16,col=\"red\",bty=\"n\") legend(x=-2, y=280,legend=\"Nombre de d\u00e9c\u00e8s quotidiens th\u00e9oriques\",lty=1,col=\"black\",bty=\"n\") Le mod\u00e8le ne parvient pas \u00e0 capturer l'acc\u00e9l\u00e9ration de l'\u00e9pid\u00e9mie \u00e0 partir de la mi-octobre. On r\u00e9alise de nouveau un graphe repr\u00e9sentant l\u2019\u00e9volution de la proportion de tests positifs observ\u00e9s, PP , et de la proportion th\u00e9orique de tests positifs calcul\u00e9s, p , avec le nouveau mod\u00e8le SIRD. plot(t,PP[t],pch=16,col=\"#A162A6\", xlab=\"Temps \u00e9coule depuis le 1er Septembre 2020 (en jours)\", ylab=\"Proportion de tests positifs quotidiens\", main = \"Proportions de tests positifs observ\u00e9s et th\u00e9oriques\") lines(t,p, lwd=2, col=\"#9CE06F\") legend(15, 0.15, legend=c(\"Tests positifs observ\u00e9s\", \"Tests positifs th\u00e9oriques\"),col=c(\"#A162A6\", \"#9CE06F\"), lty=1, cex = 0.8,lwd=2) Puis, on compare \\sigma_1 (somme cumul\u00e9e des tests positifs observ\u00e9s) avec \\sigma_2 (somme cumul\u00e9e des tests positifs observ\u00e9s) obtenues avec le nouveau mod\u00e8le SIRD. On fait ensuite un graphique des sommes cumul\u00e9es des tests positifs th\u00e9oriques du mod\u00e8le SIRD et observ\u00e9s. sigma1=cumsum(PT[t]) sigma2=cumsum(TT[t]*p) #nombre total de tests r\u00e9alis\u00e9s * proportion de tests positifs th\u00e9oriques plot(t,sigma1,pch=16,xlab=\"Temps \u00e9coule depuis le 1er septembre 2020 (en jour)\",ylab=\"Somme cumul\u00e9e des tests positifs\",col=\"#A162A6\", main = \"Comparaison des sommes cumul\u00e9es des tests positifs\") lines(t,sigma2,lwd=2, col = \"#9CE06F\" ) legend(15, 900000, legend=c(\"Tests positifs observ\u00e9s\", \"Tests positifs th\u00e9oriques\"), col=c(\"#A162A6\", \"#9CE06F\"), lty=1, cex = 0.8, lwd=2) L'ajustement du mod\u00e8le SIRD est tr\u00e8s similaire \u00e0 celui du mod\u00e8le SIR en termes de tests.","title":"Ajustement du mod\u00e8le aux donn\u00e9es"},{"location":"TD5/#estimation-de-la-letalite-du-virus","text":"A l\u2019aide de nos param\u00e8tres estim\u00e9s, nous sommes en mesure de calculer le nombre de reproduction effectif du virus au cours de la deuxi\u00e8me flamb\u00e9e : R_e2 = beta/(gamma+alpha)*(S0/N) # Re : nombre de reproduction effectif du virus print(paste(\"R_e=\",R_e2)) On retrouve une reproductivit\u00e9 \\mathcal R_e \\approx 1.3 . Nous pouvons \u00e9galement estimer le taux de l\u00e9talit\u00e9 (IFR) du virus durant la 2eme flamb\u00e9e : IFR = alpha/(alpha+gamma) # Infection Fatality Ratio print(paste(\"IFR=\",IFR)) Nous trouvons un IFR de 0.45%, comparable \u00e0 celui estim\u00e9 lors de la premi\u00e8re flamb\u00e9e.","title":"Estimation de la l\u00e9talit\u00e9 du virus"},{"location":"TD6/","text":"Introduction \u00e0 la mod\u00e9lisation en \u00e9pid\u00e9miologie : COVID-19 - 2\u00e8me confinement Victoria Bancel, Elise Hodbert, Nolwenn Paquet (M1 Agro Rennes), le 11 mars 2021. Edit\u00e9 par Fr\u00e9d\u00e9ric Hamelin et Marine Dorand (M1 MODE), le 20 mai 2021. Dynamique \u00e9pid\u00e9mique sur la base des donn\u00e9es de tests Mod\u00e8le \u00e9pid\u00e9miologique Dans ce TD, nous allons mod\u00e9liser la dynamique l'\u00e9pid\u00e9mie de COVID19 en France sur la base des donn\u00e9es de tests dans un premier temps. Les donn\u00e9es concernant les d\u00e9c\u00e8s seront utilis\u00e9es dans un second temps pour estimer le taux de l\u00e9talit\u00e9 de la maladie \u00e0 la fin de l'ann\u00e9e 2020 en France. Les variables du mod\u00e8le sont : S(t) : le nombre de personnes sensibles au temps t , I(t) : le nombre de personnes infect\u00e9es et infectieuses, R(t) : le nombre de personnes r\u00e9tablies ou gu\u00e9ries, D(t) : le nombre de personnes d\u00e9c\u00e9d\u00e9es. La taille de la population est N=S+I+R . Les param\u00e8tres du mod\u00e8les sont \\beta : le taux de transmission de la maladie, \\gamma : le taux de gu\u00e9rison, \\alpha : le taux de mortalit\u00e9 due \u00e0 la maladie. Ce sont des \"taux\" par unit\u00e9 de temps. Le mod\u00e8le SIRD s'\u00e9crit : \\begin{eqnarray} \\frac{\\mathrm{d}S}{\\mathrm{d}t}&=&-\\beta \\frac{I}{N}S\\,,\\\\ \\frac{\\mathrm{d}I}{\\mathrm{d}t}&=&\\beta \\frac{I}{N}S - (\\alpha+\\gamma)I\\,,\\\\ \\frac{\\mathrm{d}R}{\\mathrm{d}t}&=&\\gamma I\\,,\\\\ \\frac{\\mathrm{d}D}{\\mathrm{d}t}&=&\\alpha I\\,. \\end{eqnarray} Pour simplifier l'\u00e9tude, nous faisons l'hypoth\u00e8se que le taux de mortalit\u00e9 due \u00e0 la maladie est tr\u00e8s faible et n\u00e9gligeable d'un point de vue \u00e9pid\u00e9miologique devant le taux de gu\u00e9rison (\\alpha\\ll \\gamma) . Cela permet d'approximer la dynamique \u00e9pid\u00e9mique de fa\u00e7on ind\u00e9pendante des d\u00e9c\u00e8s : \\begin{eqnarray} \\frac{\\mathrm{d}S}{\\mathrm{d}t}&=&-\\beta \\frac{I}{N}S\\,,\\\\ \\frac{\\mathrm{d}I}{\\mathrm{d}t}&\\approx&\\beta \\frac{I}{N}S -\\gamma I\\,,\\\\ \\frac{\\mathrm{d}R}{\\mathrm{d}t}&=&\\gamma I\\,. \\end{eqnarray} Le mod\u00e8le ci-dessus est le c\u00e9l\u00e8bre mod\u00e8le SIR : Nous ajusterons le mod\u00e8le SIR aux donn\u00e9es de tests. Dans un second temps, nous ajusterons le mod\u00e8le SIRD aux donn\u00e9es de tests et de d\u00e9c\u00e8s. Mod\u00e8le d'observation L'ajustement du mod\u00e8le se fera par maximisation de la vraisemblance. Cette m\u00e9thode consiste \u00e0 maximiser la probabilit\u00e9 des observations sachant les param\u00e8tres. Le mod\u00e8le d'observation d\u00e9finit la probabilit\u00e9 qu'un test soit positif au temps t\u200b d'apr\u00e8s le mod\u00e8le \u00e9pid\u00e9miologique : p(t)=\\frac{\\sigma I(t)}{I(t)+\\kappa S(t)}\\,, o\u00f9 \\sigma \u200b est la sensibilit\u00e9 des tests PCR (suppos\u00e9e connue) et \\kappa est probabilit\u00e9 relative pour les individus sensibles de se faire tester comparativement aux infect\u00e9s (\u00e0 estimer). Aussi, le nombre de tests positifs le jour t peut \u00eatre mod\u00e9lis\u00e9 comme un tirage dans une loi Binomiale de param\u00e8tres p(t) et n(t) (le nombre de tests r\u00e9alis\u00e9s le jour t ) : le nombre de nouveaux cas observ\u00e9s le jour t est c(t)\\sim \\mbox{Binomial}(n(t),p(t)) Nous faisons l'hypoth\u00e8se que le nombre de d\u00e9c\u00e8s cumul\u00e9s observ\u00e9 au jour t est tir\u00e9 dans une loi de Poisson de moyenne D(t) telle que donn\u00e9 par le mod\u00e8le : D_{\\small\\mbox{data}}(t)\\sim \\mbox{Poisson}\\left(D_{\\small\\mbox{model}}(t)\\right) En admettant que les observations sont ind\u00e9pendantes conditionnellement au mod\u00e8le, la vraisemblance ( likelihood en anglais) s'\u00e9crit : \\mbox{Like}(\\theta)=\\prod_{t=0}^{T} \\mbox{Prob}(\\mbox{observe }c(t)|\\mbox{ model predicts }p(t))\\times \\mbox{Prob}(\\mbox{observe }D_{\\small\\mbox{data}}(t)|D_{\\small\\mbox{model}}(t))\\,. Soit \\theta = \\{ \\beta, \\kappa, \\alpha \\} le vecteur des param\u00e8tres \u00e0 estimer. Rechercher les valeurs de \\theta qui maximisent la vraisemblance est \u00e9quivalent \u00e0 rechercher les valeurs de \\theta qui maximisent la log-vraisemblance, qui transforme le produit en somme : \\mbox{logLike}(\\theta)=\\sum_{t=0}^T \\log\\left(\\mbox{Prob}(\\mbox{observe }c(t)|\\mbox{ model predicts }p(t))\\times \\mbox{Prob}(\\mbox{observe }D_{\\small\\mbox{data}}(t)|D_{\\small\\mbox{model}}(t))\\right)\\,. Nous travaillerons avec la log-vraisemblance. Traitement des donn\u00e9es Importation du package n\u00e9cessaire au programme : # Importe la fonction ode qui permet de r\u00e9soudre une \u00e9quation diff\u00e9rentielle library(deSolve) library(dplyr) Mise au propre de l\u2019espace de travail : rm(list=ls()) # Efface les variables cr\u00e9\u00e9es lors des ex\u00e9cutions pr\u00e9c\u00e9dentes graphics.off() # Ferme les fen\u00eatres ouvertes lors des ex\u00e9cutions pr\u00e9c\u00e9dentes Importation du jeu de donn\u00e9es sur les tests : # Lien permanent vers les donn\u00e9es de tests urltest = url(\"https://www.data.gouv.fr/fr/datasets/r/dd0de5d9-b5a5-4503-930a-7b08dc0adc7c\") #Tableau li\u00e9 aux donn\u00e9es de tests data1 = read.csv2(urltest, header=TRUE, sep=\";\") #On selectionne les colonnes jour, Tests positifs, tests, et classe d'age data<-data1 %>% select(jour,P,T,cl_age90) %>% filter(cl_age90==\"0\") %>% #Pour les donn\u00e9es li\u00e9es aux tests, on gardera les donn\u00e9es pour toutes les classes d'\u00e2ges. On conserve seulement les lignes avec clage_covid=0 filter(jour>= \"2020-10-30\",jour<= \"2020-12-15\" ) #s\u00e9lection des dates du 2\u00e8me confinement Construction des vecteurs des donn\u00e9es cumul\u00e9es : pt=as.integer(as.character(data[,2])) # Vecteur concernant les tests positifs quotidiens tt=as.integer(as.character(data[,3])) # Vecteur concernant les tests r\u00e9alis\u00e9s quotidiens PT = cumsum(pt) # Tests positifs cumul\u00e9s TT = cumsum (tt) # Tests r\u00e9alis\u00e9s cumul\u00e9s D\u00e9finition de la longueur de notre s\u00e9rie de donn\u00e9es, c\u2019est-\u00e0-dire du nombre de jours d\u2019\u00e9pid\u00e9mie \u00e9tudi\u00e9s : LP = length(PT); LT = length(TT); lt = length(tt); lp = length(pt) Visualisation des donn\u00e9es cumul\u00e9es \u00e0 partir du 30 octobre 2020 : plot(1:LT,TT,xlab=\"Temps \u00e9coul\u00e9 depuis le 30 octobre (en jours)\",ylab=\"Nombre de tests cumul\u00e9s\",col=\"black\", sub = \"Noir : nombre total de tests. Mauve : nombre de tests positifs.\") points(1:LP,PT,col=\"purple\") Visualisation des donn\u00e9es journali\u00e8res \u00e0 partir du 30 octobre 2020 : plot(1:lt,tt,xlab=\"Temps \u00e9coul\u00e9 depuis le 30 octobre (en jours)\",ylab=\"Nombre de tests quotidiens\",col=\"black\", sub = \"Noir : nombre total de tests quotidiens. Mauve : nombre de tests positifs.\") points(1:lp,pt,col=\"purple\") Proportion de tests positifs : pp = pt/tt # Proportion de tests positifs journaliers plot(1:lp,pp,xlab=\"Temps \u00e9coul\u00e9 depuis le 30 octobre (en jours)\",ylab=\"Proportion de tests quotidiens positifs\",col=\"purple\", type = \"l\") Ajustement du mod\u00e8le aux donn\u00e9es Initialisation des param\u00e8tres du mod\u00e8le : N = 64e6 # Taille totale de la population gamma = 1/10 # Taux de gu\u00e9rison par jour, correspond \u00e0 l'inverse de la p\u00e9riode infectieuse (alpha = 1/ periode infectieuse = 1 / 10) R_0 = 1 # Reproductivit\u00e9 du virus beta = gamma*R_0 # R0 = beta/alpha (nombre d'infections secondaires suite \u00e0 l'introduction d'un individu infect\u00e9 au sein d'une population na\u00efve) sigma = 0.7 # Sensibilit\u00e9 des tests PCR kappa = 5e-3 # Biais d'observation Conditions initiales (en t=t_0 ) : t0 = 1 # D\u00e9but du mod\u00e8le qui correspond au d\u00e9but du second confinement P0 = c(beta,kappa) # Vecteur des param\u00e8tres \u00e0 estimer I0 = 1e6 # Nombre d'infect\u00e9s au 30 octobre (estimation grossi\u00e8re bas\u00e9e sur le fait qu'environ 300000 personnes ont \u00e9t\u00e9 test\u00e9es positives du 23 au 30 octobre) R0 = (10/100)*N # Nombre de personnes immunis\u00e9es au 30 octobre (estimation grossi\u00e8re) S0 = N-I0-R0 # Nombre de personnes sensibles au COVID-19, c'est-\u00e0-dire qui n'ont pas encore \u00e9t\u00e9 contamin\u00e9es X0 = c(S0,I0) # Vecteur d'\u00e9tat, on ne prend que S et I car on peut retrouver facilement R avec ces deux valeurs (R=N-S-I) Mod\u00e8le SIR : t=t0:lt # Vecteur temps SIR = function(t, X, P){ beta = P[1] S = X[1] I = X[2] y = beta*S*I/N # Nombre de nouvelles infections par jour dS = -y dI = +y - gamma*I dX=c(dS,dI) return(list(dX)) } Fonction qui calcule la vraisemblance des param\u00e8tres : logLike=function(theta){ P=theta[1:2] beta=P[1] kappa=P[2] X=ode(X0,t,SIR,beta) p=sigma*X[,3]/(X[,3]+kappa*X[,2]) # Proportion th\u00e9orique de tests quotidiens positifs L=dbinom(pt, tt, p, log=TRUE) # Probabilit\u00e9 d'observer \"pt\" positifs sachant le nombre de tests \"tt\" et \"p(t)\" telle que donn\u00e9e par le mod\u00e8le (loi binomiale) LL=sum(L) # Log transforme produit des probas en somme return(LL) } Estimation des param\u00e8tres : theta0 = P0 # estimation initiale opt=optim(theta0,logLike,control=list(fnscale=-1)) beta=opt$par[1] kappa=opt$par[2] t=t0:lt X=ode(X0,t,SIR,beta) p=sigma*X[,3]/(X[,3]+kappa*X[,2])# Proportion th\u00e9orique de tests quotidiens positifs plot(t,p,xlab=\"Temps \u00e9coul\u00e9 depuis le 30 octobre (en jours)\",ylab=\"Proportion th\u00e9orique de tests quotidiens positifs\",type=\"l\",col=\"blue\") Nombres de tests quotidiens positifs observ\u00e9 et th\u00e9orique : Sigma1=(pt[t]) # Nombre de tests quotidiens positifs observ\u00e9 Sigma2=(tt[t]*p) # Nombre de tests quotidiens positifs th\u00e9orique Graphiques des r\u00e9sultats : plot(t,Sigma1,xlab=\"Temps \u00e9coul\u00e9 depuis le 30 octobre (en jours)\",ylab=\"Nombre de tests positifs th\u00e9oriques et observ\u00e9s\",col=\"black\") lines(t,Sigma2) plot(t,pp[t],xlab=\"Temps \u00e9coul\u00e9 depuis le 30 octobre (en jours)\",ylab=\"Proportion de tests quotidiens positifs th\u00e9oriques et observ\u00e9es\") lines(t,p) Estimation de la reproductivit\u00e9 du virus Param\u00e8tres obtenus : R_0 = beta/(gamma)*(S0/N) print(R_0) On obtient une reproductivit\u00e9 \\mathcal R \\approx 0.78 associ\u00e9e au deuxi\u00e8me confinement. Pour aller plus loin : prise en compte des d\u00e9c\u00e8s Cette extension a \u00e9t\u00e9 r\u00e9alis\u00e9e par Marine Dorand dans le cadre d'un stage de M1 MODE en avril-mai 2021. Traitement des donn\u00e9es On importe les donn\u00e9es de d\u00e9c\u00e8s li\u00e9s aux hospitalisations les donn\u00e9es utilis\u00e9es qui viennent de data.gouv.fr : donnees-hospitalieres-nouveaux-covid19-2021-05-12-19h05.csv # Lien permanent vers les donn\u00e9es d'hospitalisations urlhosp = url(\"https://www.data.gouv.fr/fr/datasets/r/6fadff46-9efd-4c53-942a-54aca783c30c\") # Tableau li\u00e9 aux donn\u00e9es d'hospitalisations datahosp = read.csv2(urlhosp, header=TRUE, sep=\";\") Agr\u00e9gation des donn\u00e9es \u00e0 l\u2019\u00e9chelle de la France (tous les d\u00e9partements fran\u00e7ais) par jour : # Nombre de d\u00e9c\u00e8s par jour nb_deces = aggregate(incid_dc~ jour, data=datahosp, FUN = sum) On s\u00e9l\u00e9ctionne les donn\u00e9es du 30 octobre au 15 d\u00e9cembre 2020 : nb_deces <-filter(nb_deces, jour>= \"2020-10-30\",jour<= \"2020-12-15\" ) Construction du vecteur qui contient uniquement les donn\u00e9es de d\u00e9c\u00e8s : dc = nb_deces[,2] # Nombre de d\u00e9c\u00e8s dccum = cumsum(dc) - dc[1] # Nombre de d\u00e9c\u00e8s cumul\u00e9s depuis le 30 octobre LD = length(dc) On repr\u00e9sente l\u2019\u00e9volution du nombre cumul\u00e9 de patients d\u00e9c\u00e9d\u00e9s dans les h\u00f4pitaux depuis le 30 octobre : plot(1:LD,dccum,xlab=\"Temps \u00e9coul\u00e9 depuis le 30 octobre 2020 (en jours)\",ylab=\"Nombre cumul\u00e9 de d\u00e9c\u00e8s\",pch=16, col=\"dark green\",main=\"Evolution du nombre de patients d\u00e9c\u00e9d\u00e9s au cours du deuxi\u00e8me confinement\") On represente l\u2019\u00e9volution du nombre quotidien de patients d\u00e9c\u00e9d\u00e9s dans les hopitaux au cours du deuxi\u00e8me confinement : plot(1:LD,dc,xlab=\"Temps \u00e9coul\u00e9 depuis le 30 octobre (en jours)\",ylab=\"Nombre cumul\u00e9 de d\u00e9c\u00e8s\",pch=16, col=\"dark green\",main=\"Evolution du nombre de patients d\u00e9c\u00e9d\u00e9s quotidiennement au cours de la deuxi\u00e8me flamb\u00e9e\") Ajustement du mod\u00e8le aux donn\u00e9es On d\u00e9finit les param\u00e8tres du mod\u00e8le SIRD N = 67e6 # Taille de la population fran\u00e7aise gamma = 1/10 # Taux de gu\u00e9rison (inverse du temps moyen avant gu\u00e9rison) R_0 = 1 # Reproductivit\u00e9 du virus beta=gamma*R_0 # Taux de transmission du virus sigma = 0.7 # Sensibilit\u00e9 des tests kappa = 5e-3 # Biais d'observation alpha = 0.01 # Taux de mortalit\u00e9 additionnel d\u00fb \u00e0 l'infection theta0 = c(beta,kappa,alpha) # Vecteur des param\u00e8tres \u00e0 estimer On d\u00e9finit les conditions initiales : t0 = 1 # Le 30 octobre t = t0:LD # vecteur temps I0 = 1e6 # On suppose qu'au 30 octobre il y a 1e6 infectieux (estimation grossi\u00e8re) R0 = 10/100*N # On suppose qu'au 30 octobre il y a 10% d'immunis\u00e9s (estimation grossi\u00e8re) D0 = dccum[t0] # Nombre de d\u00e9c\u00e8s au 30 octobre 2020 S0 = N-I0-R0-D0 # Nombre de personnes susceptibles d'\u00eatres infect\u00e9es X0 = c(S0,I0,D0) # Vecteur d'\u00e9tat (conditions initiales) La fonction du mod\u00e8le SIRD : SIRD = function(t, X, P){ beta = P[1] ; alpha = P[2] S = X[1] ; I = X[2] ; D = X[3] y = beta*S*I/N # Nouvelles infections par unit\u00e9 de temps dS = -y dI = +y - gamma*I - alpha*I dD = +alpha*I dX = c(dS,dI,dD) return(list(dX)) } La fonction qui calcule la vraisemblance des param\u00e8tres : logLike = function(theta){ beta = theta[1] kappa = theta[2] alpha = theta[3] P = c(beta,alpha) X = ode(X0,t,SIRD,P) # Proportion th\u00e9orique de tests quotidiens positifs d'apr\u00e8s le mod\u00e8le p = sigma*X[,3]/(X[,3]+kappa*X[,2]) dcth = alpha*X[,3] # D\u00e9c\u00e8s th\u00e9oriques LLT = dbinom(PT[t], TT[t], p, log=TRUE) # Proba d'observer \"PT\" test positifs au tps t LLD = dpois(dc[t], dcth, log=TRUE) # Probabilit\u00e9 d'observer \"dc\" d\u00e9c\u00e8s au temps t LL = sum(c(LLT,LLD)) return(LL) } On optimise la fonction LogLike pour trouver les param\u00e8tres et conditions initiales qui maximisent la vraisemblance du mod\u00e8le : opt = optim(theta0,logLike,control=list(fnscale=-1)) On r\u00e8cup\u00e8re les param\u00e8tres et conditions initiales optimaux : beta = opt$par[1] kappa = opt$par[2] alpha = opt$par[3] P0 = c(beta,alpha) # Vecteur des param\u00e8tres mis \u00e0 jour On calcule la solution du mod\u00e8le pour les param\u00e8tres et les conditions initiales estim\u00e9s : X = ode(X0,t,SIRD,P0) p=sigma*X[,3]/(X[,3]+kappa*X[,2]) On repr\u00e9sente les \u00e9volutions des nombres cumul\u00e9s de d\u00e9c\u00e8s th\u00e9oriques (courbe noire) et observ\u00e9s (courbe rouge) : plot(1:LD,dccum,col=\"red\",xlab=\"Temps \u00e9coul\u00e9 depuis le 30 octobre 2020 (en jours)\",ylab=\"Nombre de d\u00e9c\u00e8s cumul\u00e9s\",pch=16,main=\"Evolutions du nombre de d\u00e9c\u00e8s cumul\u00e9s th\u00e9oriques et observ\u00e9s\") lines(t,X[,4]) legend(\"topleft\",legend=\"Nombre de d\u00e9c\u00e8s observ\u00e9s\",pch=16,col=\"red\",bty=\"n\") legend(x=-2, y=14800,legend=\"Nombre de d\u00e9c\u00e8s th\u00e9oriques\",lty=1,col=\"black\",bty=\"n\") On repr\u00e9sente l'\u00e9volution du nombre de d\u00e9c\u00e8s quotidiens th\u00e9oriques (courbe noire) et observ\u00e9s (courbe rouge) : plot(1:LD,dc,col=\"red\",xlab=\"Temps \u00e9coul\u00e9 depuis le 30 octobre 2020 (en jours)\",ylab=\"Nombre de d\u00e9c\u00e8s quotidiens\",pch=16, main=\"Evolutions du nombre de d\u00e9c\u00e8s quotidiens th\u00e9oriques et observ\u00e9s\") lines(t,alpha*X[,3]) On r\u00e9alise de nouveau un graphe repr\u00e9sentant l\u2019\u00e9volution de la proportion de tests positifs observ\u00e9s, PP , et de la proportion th\u00e9orique de tests positifs calcul\u00e9s, p , apr\u00e8s ajustement du mod\u00e8le SIRD. PP=PT/TT plot(t,PP[t],pch=16,col=\"#A162A6\", xlab=\"Temps \u00e9coule depuis le 30 octobre 2020 (en jours)\", ylab=\"Proportion de tests positifs quotidiens\", main = \"Proportions de tests positifs observ\u00e9s et th\u00e9oriques\") lines(t,p, lwd=2, col=\"#9CE06F\") legend(\"topright\", legend=c(\"Tests positifs observ\u00e9s\", \"Tests positifs th\u00e9oriques\"),col=c(\"#A162A6\", \"#9CE06F\"), lty=1, cex = 0.8,lwd=2) Puis, on compare \\sigma_1 (somme cumul\u00e9e des tests positifs observ\u00e9s) avec \\sigma_2 (somme cumul\u00e9e des tests positifs observ\u00e9s) obtenues avec le nouveau mod\u00e8le SIRD. On fait ensuite un graphique des sommes cumul\u00e9es des tests positifs th\u00e9oriques du mod\u00e8le SIRD et observ\u00e9s. sigma1=cumsum(PT[t]) #nombre total de tests r\u00e9alis\u00e9s * proportion de tests positifs th\u00e9oriques sigma2=cumsum(TT[t]*p) plot(t,sigma1,pch=16,xlab=\"Temps \u00e9coule depuis le 30 octobre 2020 (en jour)\",ylab=\"Somme cumul\u00e9e des tests positifs\",col=\"#A162A6\", main = \"Comparaison des sommes cumul\u00e9es des tests positifs\") lines(t,sigma2,lwd=2, col = \"#9CE06F\" ) legend(\"topleft\", legend=c(\"Tests positifs observ\u00e9s\", \"Tests positifs th\u00e9oriques\"), col=c(\"#A162A6\", \"#9CE06F\"), lty=1, cex = 0.8, lwd=2) Estimation de la reproductivit\u00e9 du virus A l\u2019aide de nos param\u00e8tres estim\u00e9s, nous sommes en mesure de calculer le nombre de reproduction effectif du virus au cours de la deuxi\u00e8me flamb\u00e9e : R_e2 = beta/(gamma+alpha)*(S0/N) # Re : nombre de reproduction effectif du virus print(paste(\"R_e=\",R_e2)) On trouve une reproductivit\u00e9 de \\mathcal R \\approx 0.88 . Nous pouvons \u00e9galement estimer le taux de l\u00e9talit\u00e9 (IFR) du virus durant le deuxi\u00e8me confinement : IFR = alpha/(alpha+gamma) # Infection Fatality Ratio print(paste(\"IFR=\",IFR)) Nous trouvons un IFR de 0.45%, comme pour la deuxi\u00e8me flamb\u00e9e (cf. TD5 ). Dynamique \u00e9pid\u00e9mique sur la base des donn\u00e9es d'hospitalisations Mod\u00e8le \u00e9pid\u00e9miologique Nous d\u00e9finissons les variables S(t) : nombre d'individus sensibles au virus (non-infect\u00e9s) \u00e0 la date t\u200b , I(t) : nombre d'individus infect\u00e9s et infectieux non-hospitalis\u00e9s \u00e0 la date t\u200b , H(t)\u200b : nombre d'individus infect\u00e9s hospitalis\u00e9s \u00e0 la date t\u200b , R(t)\u200b : nombre d'individus \"retir\u00e9s\" de l'\u00e9pid\u00e9mie (gu\u00e9ris et immunis\u00e9s ou d\u00e9c\u00e9d\u00e9s) \u00e0 la date t , et les param\u00e8tres \\beta\u200b : taux de transmission par unit\u00e9 de temps (fr\u00e9quence des contacts \u200b \\times\u200b probabilit\u00e9 d'infection), \\rho\u200b : taux de \"gu\u00e9rison\" par unit\u00e9 de temps (inverse du temps moyen avant gu\u00e9rison ou d\u00e9c\u00e8s), \\alpha\u200b : taux d'hospitalisation par unit\u00e9 de temps (inverse du temps moyen avant hospitalisation), \\gamma\u200b : taux de gu\u00e9rison ou d\u00e9c\u00e8s \u00e0 l'h\u00f4pital (inverse du temps moyen avant sortie de l'h\u00f4pital). Le mod\u00e8le SIHR se traduit math\u00e9matiquement par le syst\u00e8me d'\u00e9quations diff\u00e9rentielles : \\begin{eqnarray*} \\frac{\\mathrm{d} S}{\\mathrm{d} t} &=& -\\beta \\frac{S}{N} I\\,,\\\\ \\frac{\\mathrm{d} I}{\\mathrm{d} t} &=& +\\beta \\frac{S}{N} I - (\\alpha+\\rho) I\\,,\\\\ \\frac{\\mathrm{d} H}{\\mathrm{d} t} &=& \\alpha I - \\gamma H\\,,\\\\ \\frac{\\mathrm{d} R}{\\mathrm{d} t} &=& \\rho I+ \\gamma H\\,. \\end{eqnarray*} La taille de la population est d\u00e9finie comme N= S+I+H+R=\\mbox{constante}\\,. La reproductivit\u00e9 du pathog\u00e8ne est d\u00e9fini comme \\mathcal R_0 = \\frac{\\beta}{\\alpha+\\rho}\\frac{S(t_0)}{N}\\,. C'est le nombre d'infections secondaires g\u00e9n\u00e9r\u00e9es par un individu infect\u00e9 dans la population initiale : si \\mathcal R_0>1\u200b une vague \u00e9pid\u00e9mique se forme. si \\mathcal R_0<1\u200b l'\u00e9pid\u00e9mie s'\u00e9teint progressivement. La probabilit\u00e9 d'\u00eatre hospitalis\u00e9 suite \u00e0 l'infection est p = \\frac{\\alpha}{\\alpha+\\rho}\\,. Nous allons maintenant tenter d'ajuster ce mod\u00e8le aux donn\u00e9es de COVID-19 en France sous R. Ces donn\u00e9es concernent le nombre de personnes hospitalis\u00e9es \u00e0 la date t\u200b , H(t)\u200b , ainsi que le nombre d'admissions \u00e0 l'h\u00f4pital \u00e0 la date t (par unit\u00e9 de temps) : A(t)=\\alpha I(t)\\,. Mod\u00e8le d'observation Nous consid\u00e9rerons que le nombre de nouvelles hospitalisations \u00e0 la date t est une variable al\u00e9atoire discr\u00e8te distribu\u00e9e selon une loi de Poisson de moyenne A(t)\u200b . De la m\u00eame fa\u00e7on, nous consid\u00e9rerons que le nombre de personnes hospitalis\u00e9es \u00e0 la date t \u200b est tir\u00e9 dans une loi de Poisson de moyenne \u200b H(t)\u200b . Appelons \\theta\u200b le vecteur des param\u00e8tres et conditions initiales \u00e0 estimer : \\theta=\\{\\alpha,\\beta,\\gamma,S(0),I(0),H(0)\\}\\,. Sous l'hypoth\u00e8se que les observations sont ind\u00e9pendantes conditionnellement au mod\u00e8le \u00e9pid\u00e9miologique (ce qui veut dire \"sachant la dynamique pr\u00e9dite par le mod\u00e8le th\u00e9orique\"), la vraisemblance ( likelihood ) peut s'\u00e9crire : \\mathcal{L}\\left(\\theta\\right)=\\prod_{t=0}^T \\text{Pr}(\\text{observer A admissions le jour }t| A(t))\\times\\text{Pr}(\\text{observer H hospitalisations le jour }t|H(t))\\,. Comme la fonction logarithme est monotone croissante, trouver le vecteur \\theta\u200b qui maximise \u200b \\mathcal L(\\theta) est \u00e9quivalent \u00e0 trouver le vecteur \u200b \\theta\u200b qui maximise la log-vraisemblance ( log-likelihood ) \u200b \\log\\mathcal{L}(\\theta) qui est plus commun\u00e9ment utilis\u00e9e en pratique. Nous travaillerons avec la log-vraisemblance. Traitement des donn\u00e9es Importation du package n\u00e9cessaire au programme : # Importe la fonction ode qui permet de r\u00e9soudre une \u00e9quation diff\u00e9rentielle library(deSolve) Mise au propre de l\u2019espace de travail : rm(list=ls()) # Efface les variables cr\u00e9\u00e9es lors des ex\u00e9cutions pr\u00e9c\u00e9dentes graphics.off() # Ferme les fen\u00eatres ouvertes lors des ex\u00e9cutions pr\u00e9c\u00e9dentes Importation du jeu de donn\u00e9es sur les hospitalisations : # Lien permanent vers les donn\u00e9es d'hospitalisations urlhosp = url(\"https://www.data.gouv.fr/fr/datasets/r/d3a98a30-893f-47f7-96c5-2f4bcaaa0d71\") # Tableau li\u00e9 aux donn\u00e9es d'hospitalisation data = read.csv2(urlhosp, header=TRUE, sep=\",\") Cr\u00e9ation d\u2019un tableau avec seulement les donn\u00e9es du 2\u00e8me confinement : j2confifi = which(data[]==\"2020-10-30\") # Jour \u00e0 partir duquel commence 2\u00e8me confinement dernierjconfifi = which(data[]==\"2020-12-15\") # Dernier jour du 2\u00e8me confinement newtableau = data[j2confifi:dernierjconfifi,] # Tableau avec que donn\u00e9es 2\u00e8me confinement Vecteurs des donn\u00e9es d\u2019hospitalisations et d\u2019admissions \u00e0 l\u2019h\u00f4pital pendant le 2\u00e8me confinement : # Personnes admises \u00e0 l'hopital depuis le d\u00e9but du deuxi\u00e8me confinement A = c(newtableau[,10]) H = c(newtableau[,8]) # Personnes hospitalis\u00e9es depuis le d\u00e9but du deuxi\u00e8me confinement Visualisation des donn\u00e9es d\u2019hospitalisations et d\u2019admissions \u00e0 l\u2019h\u00f4pital pendant le 2\u00e8me confinement : nj = length(newtableau[,1]) plot(1:nj, A,xlab=\"Temps \u00e9coul\u00e9 depuis le 30 octobre 2020 (en jours)\", ylab=\"Nombre d'admissions \u00e0 l'hopital\", col=\"blue\") plot(1:nj, H,xlab=\"Temps \u00e9coul\u00e9 depuis le 30 octobre 2020 (en jours)\", ylab=\"Nombre de personnes hospitalis\u00e9es\",col=\"blue\") Ajustement du mod\u00e8le aux donn\u00e9es Initialisation du mod\u00e8le (le 30 octobre 2020) : N = 64e6 # Taille de la population rho = 1/10 # Temps moyen avant gu\u00e9rison ou d\u00e9c\u00e8s : 10 jours gamma = 1/14 # Dur\u00e9e moyenne de l'hospitalisation : 14 jours R_0 = 1 # Nombre de reproduction de base en confinement beta = R_0*rho # Approximation du taux de transmission p = 0.1 # Probabilit\u00e9 d'\u00eatre hospitalis\u00e9 suite \u00e0 l'infection alpha = p*rho/(1-p) # Taux d'hospitalisation P0 = c(beta,alpha,gamma) # Vecteur des param\u00e8tres H0 = H[1] # Le nombre de personnes hospitalis\u00e9es au 30 octobre 2020 I0 = A[1]/alpha # Les admissions correspondent \u00e0 A(t) = alpha*I(t) R0 = (10/100)*N # Nombre de personnes immunis\u00e9es au 30 octobre (estimation grossi\u00e8re) S0 = N-I0-R0 # Nombre de personnes susceptibles d'\u00eatre infect\u00e9es S0 = N-I0-H0-R0 # La taille de la population sensible au 30 octobre X0 = c(S0,I0,H0) # Vecteur d'\u00e9tat. Pas besoin de simuler R=N-(S+I+H). Mod\u00e8le SIHR : t=0:nj SIHR = function(t, X, P){ beta = P[1] # Le taux de transmission alpha = P[2] # Le taux d'hospitalisation gamma = P[3] # Le taux de sortie d'h\u00f4pital S = X[1] I = X[2] H = X[3] # Le vecteur d'\u00e9tat X contient: S, I, et H y = beta*S*I/N # Le nombre de nouvelles infections par jour dS = -y # On exprime dS/dt = - beta*S*I dI = y-(alpha+rho)*I # On exprime dI/dt = beta*S*I - (alpha+rho)*I dH = alpha*I -gamma*H # On exprime dH/dt = alpha*I - gamma*H dX=c(dS,dI,dH) # Renvoie dX/dt tel que demand\u00e9 par la fonction ode return(list(dX)) } Fonction de log-vraisemblance : logLike=function(theta){ P = theta[1:3] # Les param\u00e8tres beta, alpha, et gamma X0 = theta[4:6] # Mise \u00e0 jour des conditions initiales X = ode(X0,t,SIHR,P) # R\u00e9solution du syst\u00e8me d'EDO (mod\u00e8le SIHR) h = X[,4] # Hospitalisation th\u00e9oriques : H(t) a = P[2]*X[,3] # Admissions th\u00e9oriques : alpha*I(t) LLH = dpois(H,h,log=T) # Probabilit\u00e9 d'observer H (loi de Poisson) LLA = dpois(A,a,log=T) # Probabilit\u00e9 d'observer A (Poisson) LL = sum(c(LLH,LLA)) # Log transforme produit des probas en somme return(LL) # Renvoie la log-vraisemblance (likelihood) } Arguments d'entr\u00e9e de la fonction de log-vraisemblance : theta0 = c(P0,X0) # Concat\u00e8ne les param\u00e8tres et conditions initiales Maximisation de la log-vraisemblance : opt = optim(theta0,logLike,control=list(fnscale=-1)) # Maximise logLike R\u00e9cup\u00e9ration des valeurs optimales des param\u00e8tres et conditions initiales du mod\u00e8le : #Les param\u00e8tres optimaux beta = opt$par[1] alpha = opt$par[2] gamma = opt$par[3] #Les conditions initiales optimales S0 = opt$par[4] I0 = opt$par[5] H0 = opt$par[6] Mise \u00e0 jour des vecteurs des conditions initiales : X0 = c(S0,I0,H0) # Vecteur des conditions initiales P0 = c(beta,alpha,gamma) # Vecteur des param\u00e8tres mis \u00e0 jour Simulation du mod\u00e8le pour les conditions initiales et param\u00e8tres estim\u00e9s : T = nj ; t0 = 1 ; t = t0:T # Mise \u00e0 jour du vecteur temps X = ode(X0,t,SIHR,P0) # Calcul de la solution optimale Comparaison visuelle de la solution du mod\u00e8le et des observations : # Affiche le nombre d\u2019individus hospitalis\u00e9s (donn\u00e9es et mod\u00e8le) plot(1:nj,H,xlab=\"Temps \u00e9coul\u00e9 depuis le 30 octobre (en jours)\", ylab=\"Nombre de personnes hospitalis\u00e9es\",col=\"blue\") lines(X[,1],X[,4]) plot(1:nj,A,xlab=\"Temps \u00e9coul\u00e9 depuis le 30 octobre (en jours)\", ylab=\"Nombre de nouvelles hospitalisations (par jour)\",col=\"red\"); lines(X[,1],alpha*X[,3]) Estimation de la reproductivit\u00e9 du virus Affichage des valeurs estim\u00e9es des param\u00e8tres : R_0=beta/(alpha+rho)*S0/N # Nombre de reproduction de base estim\u00e9 print(R_0) p=alpha/(alpha+rho) # Probabilit\u00e9 d'\u00eatre hospitalis\u00e9 print(p) print(1/gamma) # Temps moyen d'hospitalisation Nous obtenons les estimations suivantes pour le deuxi\u00e8me confinement : Reproductivit\u00e9 du virus : \\mathcal R \\approx 0.81 , Probabilit\u00e9 d'\u00eatre hospitalis\u00e9 : p \\approx 0.10 , Temps moyen d'hospitalisation : 15 jours.","title":"TD6 (Novembre-D\u00e9cembre 2020)"},{"location":"TD6/#introduction-a-la-modelisation-en-epidemiologie-covid-19-2eme-confinement","text":"Victoria Bancel, Elise Hodbert, Nolwenn Paquet (M1 Agro Rennes), le 11 mars 2021. Edit\u00e9 par Fr\u00e9d\u00e9ric Hamelin et Marine Dorand (M1 MODE), le 20 mai 2021.","title":"Introduction \u00e0 la mod\u00e9lisation en \u00e9pid\u00e9miologie : COVID-19 - 2\u00e8me confinement"},{"location":"TD6/#dynamique-epidemique-sur-la-base-des-donnees-de-tests","text":"","title":"Dynamique \u00e9pid\u00e9mique sur la base des donn\u00e9es de tests"},{"location":"TD6/#modele-epidemiologique","text":"Dans ce TD, nous allons mod\u00e9liser la dynamique l'\u00e9pid\u00e9mie de COVID19 en France sur la base des donn\u00e9es de tests dans un premier temps. Les donn\u00e9es concernant les d\u00e9c\u00e8s seront utilis\u00e9es dans un second temps pour estimer le taux de l\u00e9talit\u00e9 de la maladie \u00e0 la fin de l'ann\u00e9e 2020 en France. Les variables du mod\u00e8le sont : S(t) : le nombre de personnes sensibles au temps t , I(t) : le nombre de personnes infect\u00e9es et infectieuses, R(t) : le nombre de personnes r\u00e9tablies ou gu\u00e9ries, D(t) : le nombre de personnes d\u00e9c\u00e9d\u00e9es. La taille de la population est N=S+I+R . Les param\u00e8tres du mod\u00e8les sont \\beta : le taux de transmission de la maladie, \\gamma : le taux de gu\u00e9rison, \\alpha : le taux de mortalit\u00e9 due \u00e0 la maladie. Ce sont des \"taux\" par unit\u00e9 de temps. Le mod\u00e8le SIRD s'\u00e9crit : \\begin{eqnarray} \\frac{\\mathrm{d}S}{\\mathrm{d}t}&=&-\\beta \\frac{I}{N}S\\,,\\\\ \\frac{\\mathrm{d}I}{\\mathrm{d}t}&=&\\beta \\frac{I}{N}S - (\\alpha+\\gamma)I\\,,\\\\ \\frac{\\mathrm{d}R}{\\mathrm{d}t}&=&\\gamma I\\,,\\\\ \\frac{\\mathrm{d}D}{\\mathrm{d}t}&=&\\alpha I\\,. \\end{eqnarray} Pour simplifier l'\u00e9tude, nous faisons l'hypoth\u00e8se que le taux de mortalit\u00e9 due \u00e0 la maladie est tr\u00e8s faible et n\u00e9gligeable d'un point de vue \u00e9pid\u00e9miologique devant le taux de gu\u00e9rison (\\alpha\\ll \\gamma) . Cela permet d'approximer la dynamique \u00e9pid\u00e9mique de fa\u00e7on ind\u00e9pendante des d\u00e9c\u00e8s : \\begin{eqnarray} \\frac{\\mathrm{d}S}{\\mathrm{d}t}&=&-\\beta \\frac{I}{N}S\\,,\\\\ \\frac{\\mathrm{d}I}{\\mathrm{d}t}&\\approx&\\beta \\frac{I}{N}S -\\gamma I\\,,\\\\ \\frac{\\mathrm{d}R}{\\mathrm{d}t}&=&\\gamma I\\,. \\end{eqnarray} Le mod\u00e8le ci-dessus est le c\u00e9l\u00e8bre mod\u00e8le SIR : Nous ajusterons le mod\u00e8le SIR aux donn\u00e9es de tests. Dans un second temps, nous ajusterons le mod\u00e8le SIRD aux donn\u00e9es de tests et de d\u00e9c\u00e8s.","title":"Mod\u00e8le \u00e9pid\u00e9miologique"},{"location":"TD6/#modele-dobservation","text":"L'ajustement du mod\u00e8le se fera par maximisation de la vraisemblance. Cette m\u00e9thode consiste \u00e0 maximiser la probabilit\u00e9 des observations sachant les param\u00e8tres. Le mod\u00e8le d'observation d\u00e9finit la probabilit\u00e9 qu'un test soit positif au temps t\u200b d'apr\u00e8s le mod\u00e8le \u00e9pid\u00e9miologique : p(t)=\\frac{\\sigma I(t)}{I(t)+\\kappa S(t)}\\,, o\u00f9 \\sigma \u200b est la sensibilit\u00e9 des tests PCR (suppos\u00e9e connue) et \\kappa est probabilit\u00e9 relative pour les individus sensibles de se faire tester comparativement aux infect\u00e9s (\u00e0 estimer). Aussi, le nombre de tests positifs le jour t peut \u00eatre mod\u00e9lis\u00e9 comme un tirage dans une loi Binomiale de param\u00e8tres p(t) et n(t) (le nombre de tests r\u00e9alis\u00e9s le jour t ) : le nombre de nouveaux cas observ\u00e9s le jour t est c(t)\\sim \\mbox{Binomial}(n(t),p(t)) Nous faisons l'hypoth\u00e8se que le nombre de d\u00e9c\u00e8s cumul\u00e9s observ\u00e9 au jour t est tir\u00e9 dans une loi de Poisson de moyenne D(t) telle que donn\u00e9 par le mod\u00e8le : D_{\\small\\mbox{data}}(t)\\sim \\mbox{Poisson}\\left(D_{\\small\\mbox{model}}(t)\\right) En admettant que les observations sont ind\u00e9pendantes conditionnellement au mod\u00e8le, la vraisemblance ( likelihood en anglais) s'\u00e9crit : \\mbox{Like}(\\theta)=\\prod_{t=0}^{T} \\mbox{Prob}(\\mbox{observe }c(t)|\\mbox{ model predicts }p(t))\\times \\mbox{Prob}(\\mbox{observe }D_{\\small\\mbox{data}}(t)|D_{\\small\\mbox{model}}(t))\\,. Soit \\theta = \\{ \\beta, \\kappa, \\alpha \\} le vecteur des param\u00e8tres \u00e0 estimer. Rechercher les valeurs de \\theta qui maximisent la vraisemblance est \u00e9quivalent \u00e0 rechercher les valeurs de \\theta qui maximisent la log-vraisemblance, qui transforme le produit en somme : \\mbox{logLike}(\\theta)=\\sum_{t=0}^T \\log\\left(\\mbox{Prob}(\\mbox{observe }c(t)|\\mbox{ model predicts }p(t))\\times \\mbox{Prob}(\\mbox{observe }D_{\\small\\mbox{data}}(t)|D_{\\small\\mbox{model}}(t))\\right)\\,. Nous travaillerons avec la log-vraisemblance.","title":"Mod\u00e8le d'observation"},{"location":"TD6/#traitement-des-donnees","text":"Importation du package n\u00e9cessaire au programme : # Importe la fonction ode qui permet de r\u00e9soudre une \u00e9quation diff\u00e9rentielle library(deSolve) library(dplyr) Mise au propre de l\u2019espace de travail : rm(list=ls()) # Efface les variables cr\u00e9\u00e9es lors des ex\u00e9cutions pr\u00e9c\u00e9dentes graphics.off() # Ferme les fen\u00eatres ouvertes lors des ex\u00e9cutions pr\u00e9c\u00e9dentes Importation du jeu de donn\u00e9es sur les tests : # Lien permanent vers les donn\u00e9es de tests urltest = url(\"https://www.data.gouv.fr/fr/datasets/r/dd0de5d9-b5a5-4503-930a-7b08dc0adc7c\") #Tableau li\u00e9 aux donn\u00e9es de tests data1 = read.csv2(urltest, header=TRUE, sep=\";\") #On selectionne les colonnes jour, Tests positifs, tests, et classe d'age data<-data1 %>% select(jour,P,T,cl_age90) %>% filter(cl_age90==\"0\") %>% #Pour les donn\u00e9es li\u00e9es aux tests, on gardera les donn\u00e9es pour toutes les classes d'\u00e2ges. On conserve seulement les lignes avec clage_covid=0 filter(jour>= \"2020-10-30\",jour<= \"2020-12-15\" ) #s\u00e9lection des dates du 2\u00e8me confinement Construction des vecteurs des donn\u00e9es cumul\u00e9es : pt=as.integer(as.character(data[,2])) # Vecteur concernant les tests positifs quotidiens tt=as.integer(as.character(data[,3])) # Vecteur concernant les tests r\u00e9alis\u00e9s quotidiens PT = cumsum(pt) # Tests positifs cumul\u00e9s TT = cumsum (tt) # Tests r\u00e9alis\u00e9s cumul\u00e9s D\u00e9finition de la longueur de notre s\u00e9rie de donn\u00e9es, c\u2019est-\u00e0-dire du nombre de jours d\u2019\u00e9pid\u00e9mie \u00e9tudi\u00e9s : LP = length(PT); LT = length(TT); lt = length(tt); lp = length(pt) Visualisation des donn\u00e9es cumul\u00e9es \u00e0 partir du 30 octobre 2020 : plot(1:LT,TT,xlab=\"Temps \u00e9coul\u00e9 depuis le 30 octobre (en jours)\",ylab=\"Nombre de tests cumul\u00e9s\",col=\"black\", sub = \"Noir : nombre total de tests. Mauve : nombre de tests positifs.\") points(1:LP,PT,col=\"purple\") Visualisation des donn\u00e9es journali\u00e8res \u00e0 partir du 30 octobre 2020 : plot(1:lt,tt,xlab=\"Temps \u00e9coul\u00e9 depuis le 30 octobre (en jours)\",ylab=\"Nombre de tests quotidiens\",col=\"black\", sub = \"Noir : nombre total de tests quotidiens. Mauve : nombre de tests positifs.\") points(1:lp,pt,col=\"purple\") Proportion de tests positifs : pp = pt/tt # Proportion de tests positifs journaliers plot(1:lp,pp,xlab=\"Temps \u00e9coul\u00e9 depuis le 30 octobre (en jours)\",ylab=\"Proportion de tests quotidiens positifs\",col=\"purple\", type = \"l\")","title":"Traitement des donn\u00e9es"},{"location":"TD6/#ajustement-du-modele-aux-donnees","text":"Initialisation des param\u00e8tres du mod\u00e8le : N = 64e6 # Taille totale de la population gamma = 1/10 # Taux de gu\u00e9rison par jour, correspond \u00e0 l'inverse de la p\u00e9riode infectieuse (alpha = 1/ periode infectieuse = 1 / 10) R_0 = 1 # Reproductivit\u00e9 du virus beta = gamma*R_0 # R0 = beta/alpha (nombre d'infections secondaires suite \u00e0 l'introduction d'un individu infect\u00e9 au sein d'une population na\u00efve) sigma = 0.7 # Sensibilit\u00e9 des tests PCR kappa = 5e-3 # Biais d'observation Conditions initiales (en t=t_0 ) : t0 = 1 # D\u00e9but du mod\u00e8le qui correspond au d\u00e9but du second confinement P0 = c(beta,kappa) # Vecteur des param\u00e8tres \u00e0 estimer I0 = 1e6 # Nombre d'infect\u00e9s au 30 octobre (estimation grossi\u00e8re bas\u00e9e sur le fait qu'environ 300000 personnes ont \u00e9t\u00e9 test\u00e9es positives du 23 au 30 octobre) R0 = (10/100)*N # Nombre de personnes immunis\u00e9es au 30 octobre (estimation grossi\u00e8re) S0 = N-I0-R0 # Nombre de personnes sensibles au COVID-19, c'est-\u00e0-dire qui n'ont pas encore \u00e9t\u00e9 contamin\u00e9es X0 = c(S0,I0) # Vecteur d'\u00e9tat, on ne prend que S et I car on peut retrouver facilement R avec ces deux valeurs (R=N-S-I) Mod\u00e8le SIR : t=t0:lt # Vecteur temps SIR = function(t, X, P){ beta = P[1] S = X[1] I = X[2] y = beta*S*I/N # Nombre de nouvelles infections par jour dS = -y dI = +y - gamma*I dX=c(dS,dI) return(list(dX)) } Fonction qui calcule la vraisemblance des param\u00e8tres : logLike=function(theta){ P=theta[1:2] beta=P[1] kappa=P[2] X=ode(X0,t,SIR,beta) p=sigma*X[,3]/(X[,3]+kappa*X[,2]) # Proportion th\u00e9orique de tests quotidiens positifs L=dbinom(pt, tt, p, log=TRUE) # Probabilit\u00e9 d'observer \"pt\" positifs sachant le nombre de tests \"tt\" et \"p(t)\" telle que donn\u00e9e par le mod\u00e8le (loi binomiale) LL=sum(L) # Log transforme produit des probas en somme return(LL) } Estimation des param\u00e8tres : theta0 = P0 # estimation initiale opt=optim(theta0,logLike,control=list(fnscale=-1)) beta=opt$par[1] kappa=opt$par[2] t=t0:lt X=ode(X0,t,SIR,beta) p=sigma*X[,3]/(X[,3]+kappa*X[,2])# Proportion th\u00e9orique de tests quotidiens positifs plot(t,p,xlab=\"Temps \u00e9coul\u00e9 depuis le 30 octobre (en jours)\",ylab=\"Proportion th\u00e9orique de tests quotidiens positifs\",type=\"l\",col=\"blue\") Nombres de tests quotidiens positifs observ\u00e9 et th\u00e9orique : Sigma1=(pt[t]) # Nombre de tests quotidiens positifs observ\u00e9 Sigma2=(tt[t]*p) # Nombre de tests quotidiens positifs th\u00e9orique Graphiques des r\u00e9sultats : plot(t,Sigma1,xlab=\"Temps \u00e9coul\u00e9 depuis le 30 octobre (en jours)\",ylab=\"Nombre de tests positifs th\u00e9oriques et observ\u00e9s\",col=\"black\") lines(t,Sigma2) plot(t,pp[t],xlab=\"Temps \u00e9coul\u00e9 depuis le 30 octobre (en jours)\",ylab=\"Proportion de tests quotidiens positifs th\u00e9oriques et observ\u00e9es\") lines(t,p)","title":"Ajustement du mod\u00e8le aux donn\u00e9es"},{"location":"TD6/#estimation-de-la-reproductivite-du-virus","text":"Param\u00e8tres obtenus : R_0 = beta/(gamma)*(S0/N) print(R_0) On obtient une reproductivit\u00e9 \\mathcal R \\approx 0.78 associ\u00e9e au deuxi\u00e8me confinement.","title":"Estimation de la reproductivit\u00e9 du virus"},{"location":"TD6/#pour-aller-plus-loin-prise-en-compte-des-deces","text":"Cette extension a \u00e9t\u00e9 r\u00e9alis\u00e9e par Marine Dorand dans le cadre d'un stage de M1 MODE en avril-mai 2021.","title":"Pour aller plus loin : prise en compte des d\u00e9c\u00e8s"},{"location":"TD6/#traitement-des-donnees_1","text":"On importe les donn\u00e9es de d\u00e9c\u00e8s li\u00e9s aux hospitalisations les donn\u00e9es utilis\u00e9es qui viennent de data.gouv.fr : donnees-hospitalieres-nouveaux-covid19-2021-05-12-19h05.csv # Lien permanent vers les donn\u00e9es d'hospitalisations urlhosp = url(\"https://www.data.gouv.fr/fr/datasets/r/6fadff46-9efd-4c53-942a-54aca783c30c\") # Tableau li\u00e9 aux donn\u00e9es d'hospitalisations datahosp = read.csv2(urlhosp, header=TRUE, sep=\";\") Agr\u00e9gation des donn\u00e9es \u00e0 l\u2019\u00e9chelle de la France (tous les d\u00e9partements fran\u00e7ais) par jour : # Nombre de d\u00e9c\u00e8s par jour nb_deces = aggregate(incid_dc~ jour, data=datahosp, FUN = sum) On s\u00e9l\u00e9ctionne les donn\u00e9es du 30 octobre au 15 d\u00e9cembre 2020 : nb_deces <-filter(nb_deces, jour>= \"2020-10-30\",jour<= \"2020-12-15\" ) Construction du vecteur qui contient uniquement les donn\u00e9es de d\u00e9c\u00e8s : dc = nb_deces[,2] # Nombre de d\u00e9c\u00e8s dccum = cumsum(dc) - dc[1] # Nombre de d\u00e9c\u00e8s cumul\u00e9s depuis le 30 octobre LD = length(dc) On repr\u00e9sente l\u2019\u00e9volution du nombre cumul\u00e9 de patients d\u00e9c\u00e9d\u00e9s dans les h\u00f4pitaux depuis le 30 octobre : plot(1:LD,dccum,xlab=\"Temps \u00e9coul\u00e9 depuis le 30 octobre 2020 (en jours)\",ylab=\"Nombre cumul\u00e9 de d\u00e9c\u00e8s\",pch=16, col=\"dark green\",main=\"Evolution du nombre de patients d\u00e9c\u00e9d\u00e9s au cours du deuxi\u00e8me confinement\") On represente l\u2019\u00e9volution du nombre quotidien de patients d\u00e9c\u00e9d\u00e9s dans les hopitaux au cours du deuxi\u00e8me confinement : plot(1:LD,dc,xlab=\"Temps \u00e9coul\u00e9 depuis le 30 octobre (en jours)\",ylab=\"Nombre cumul\u00e9 de d\u00e9c\u00e8s\",pch=16, col=\"dark green\",main=\"Evolution du nombre de patients d\u00e9c\u00e9d\u00e9s quotidiennement au cours de la deuxi\u00e8me flamb\u00e9e\")","title":"Traitement des donn\u00e9es"},{"location":"TD6/#ajustement-du-modele-aux-donnees_1","text":"On d\u00e9finit les param\u00e8tres du mod\u00e8le SIRD N = 67e6 # Taille de la population fran\u00e7aise gamma = 1/10 # Taux de gu\u00e9rison (inverse du temps moyen avant gu\u00e9rison) R_0 = 1 # Reproductivit\u00e9 du virus beta=gamma*R_0 # Taux de transmission du virus sigma = 0.7 # Sensibilit\u00e9 des tests kappa = 5e-3 # Biais d'observation alpha = 0.01 # Taux de mortalit\u00e9 additionnel d\u00fb \u00e0 l'infection theta0 = c(beta,kappa,alpha) # Vecteur des param\u00e8tres \u00e0 estimer On d\u00e9finit les conditions initiales : t0 = 1 # Le 30 octobre t = t0:LD # vecteur temps I0 = 1e6 # On suppose qu'au 30 octobre il y a 1e6 infectieux (estimation grossi\u00e8re) R0 = 10/100*N # On suppose qu'au 30 octobre il y a 10% d'immunis\u00e9s (estimation grossi\u00e8re) D0 = dccum[t0] # Nombre de d\u00e9c\u00e8s au 30 octobre 2020 S0 = N-I0-R0-D0 # Nombre de personnes susceptibles d'\u00eatres infect\u00e9es X0 = c(S0,I0,D0) # Vecteur d'\u00e9tat (conditions initiales) La fonction du mod\u00e8le SIRD : SIRD = function(t, X, P){ beta = P[1] ; alpha = P[2] S = X[1] ; I = X[2] ; D = X[3] y = beta*S*I/N # Nouvelles infections par unit\u00e9 de temps dS = -y dI = +y - gamma*I - alpha*I dD = +alpha*I dX = c(dS,dI,dD) return(list(dX)) } La fonction qui calcule la vraisemblance des param\u00e8tres : logLike = function(theta){ beta = theta[1] kappa = theta[2] alpha = theta[3] P = c(beta,alpha) X = ode(X0,t,SIRD,P) # Proportion th\u00e9orique de tests quotidiens positifs d'apr\u00e8s le mod\u00e8le p = sigma*X[,3]/(X[,3]+kappa*X[,2]) dcth = alpha*X[,3] # D\u00e9c\u00e8s th\u00e9oriques LLT = dbinom(PT[t], TT[t], p, log=TRUE) # Proba d'observer \"PT\" test positifs au tps t LLD = dpois(dc[t], dcth, log=TRUE) # Probabilit\u00e9 d'observer \"dc\" d\u00e9c\u00e8s au temps t LL = sum(c(LLT,LLD)) return(LL) } On optimise la fonction LogLike pour trouver les param\u00e8tres et conditions initiales qui maximisent la vraisemblance du mod\u00e8le : opt = optim(theta0,logLike,control=list(fnscale=-1)) On r\u00e8cup\u00e8re les param\u00e8tres et conditions initiales optimaux : beta = opt$par[1] kappa = opt$par[2] alpha = opt$par[3] P0 = c(beta,alpha) # Vecteur des param\u00e8tres mis \u00e0 jour On calcule la solution du mod\u00e8le pour les param\u00e8tres et les conditions initiales estim\u00e9s : X = ode(X0,t,SIRD,P0) p=sigma*X[,3]/(X[,3]+kappa*X[,2]) On repr\u00e9sente les \u00e9volutions des nombres cumul\u00e9s de d\u00e9c\u00e8s th\u00e9oriques (courbe noire) et observ\u00e9s (courbe rouge) : plot(1:LD,dccum,col=\"red\",xlab=\"Temps \u00e9coul\u00e9 depuis le 30 octobre 2020 (en jours)\",ylab=\"Nombre de d\u00e9c\u00e8s cumul\u00e9s\",pch=16,main=\"Evolutions du nombre de d\u00e9c\u00e8s cumul\u00e9s th\u00e9oriques et observ\u00e9s\") lines(t,X[,4]) legend(\"topleft\",legend=\"Nombre de d\u00e9c\u00e8s observ\u00e9s\",pch=16,col=\"red\",bty=\"n\") legend(x=-2, y=14800,legend=\"Nombre de d\u00e9c\u00e8s th\u00e9oriques\",lty=1,col=\"black\",bty=\"n\") On repr\u00e9sente l'\u00e9volution du nombre de d\u00e9c\u00e8s quotidiens th\u00e9oriques (courbe noire) et observ\u00e9s (courbe rouge) : plot(1:LD,dc,col=\"red\",xlab=\"Temps \u00e9coul\u00e9 depuis le 30 octobre 2020 (en jours)\",ylab=\"Nombre de d\u00e9c\u00e8s quotidiens\",pch=16, main=\"Evolutions du nombre de d\u00e9c\u00e8s quotidiens th\u00e9oriques et observ\u00e9s\") lines(t,alpha*X[,3]) On r\u00e9alise de nouveau un graphe repr\u00e9sentant l\u2019\u00e9volution de la proportion de tests positifs observ\u00e9s, PP , et de la proportion th\u00e9orique de tests positifs calcul\u00e9s, p , apr\u00e8s ajustement du mod\u00e8le SIRD. PP=PT/TT plot(t,PP[t],pch=16,col=\"#A162A6\", xlab=\"Temps \u00e9coule depuis le 30 octobre 2020 (en jours)\", ylab=\"Proportion de tests positifs quotidiens\", main = \"Proportions de tests positifs observ\u00e9s et th\u00e9oriques\") lines(t,p, lwd=2, col=\"#9CE06F\") legend(\"topright\", legend=c(\"Tests positifs observ\u00e9s\", \"Tests positifs th\u00e9oriques\"),col=c(\"#A162A6\", \"#9CE06F\"), lty=1, cex = 0.8,lwd=2) Puis, on compare \\sigma_1 (somme cumul\u00e9e des tests positifs observ\u00e9s) avec \\sigma_2 (somme cumul\u00e9e des tests positifs observ\u00e9s) obtenues avec le nouveau mod\u00e8le SIRD. On fait ensuite un graphique des sommes cumul\u00e9es des tests positifs th\u00e9oriques du mod\u00e8le SIRD et observ\u00e9s. sigma1=cumsum(PT[t]) #nombre total de tests r\u00e9alis\u00e9s * proportion de tests positifs th\u00e9oriques sigma2=cumsum(TT[t]*p) plot(t,sigma1,pch=16,xlab=\"Temps \u00e9coule depuis le 30 octobre 2020 (en jour)\",ylab=\"Somme cumul\u00e9e des tests positifs\",col=\"#A162A6\", main = \"Comparaison des sommes cumul\u00e9es des tests positifs\") lines(t,sigma2,lwd=2, col = \"#9CE06F\" ) legend(\"topleft\", legend=c(\"Tests positifs observ\u00e9s\", \"Tests positifs th\u00e9oriques\"), col=c(\"#A162A6\", \"#9CE06F\"), lty=1, cex = 0.8, lwd=2)","title":"Ajustement du mod\u00e8le aux donn\u00e9es"},{"location":"TD6/#estimation-de-la-reproductivite-du-virus_1","text":"A l\u2019aide de nos param\u00e8tres estim\u00e9s, nous sommes en mesure de calculer le nombre de reproduction effectif du virus au cours de la deuxi\u00e8me flamb\u00e9e : R_e2 = beta/(gamma+alpha)*(S0/N) # Re : nombre de reproduction effectif du virus print(paste(\"R_e=\",R_e2)) On trouve une reproductivit\u00e9 de \\mathcal R \\approx 0.88 . Nous pouvons \u00e9galement estimer le taux de l\u00e9talit\u00e9 (IFR) du virus durant le deuxi\u00e8me confinement : IFR = alpha/(alpha+gamma) # Infection Fatality Ratio print(paste(\"IFR=\",IFR)) Nous trouvons un IFR de 0.45%, comme pour la deuxi\u00e8me flamb\u00e9e (cf. TD5 ).","title":"Estimation de la reproductivit\u00e9 du virus"},{"location":"TD6/#dynamique-epidemique-sur-la-base-des-donnees-dhospitalisations","text":"","title":"Dynamique \u00e9pid\u00e9mique sur la base des donn\u00e9es d'hospitalisations"},{"location":"TD6/#modele-epidemiologique_1","text":"Nous d\u00e9finissons les variables S(t) : nombre d'individus sensibles au virus (non-infect\u00e9s) \u00e0 la date t\u200b , I(t) : nombre d'individus infect\u00e9s et infectieux non-hospitalis\u00e9s \u00e0 la date t\u200b , H(t)\u200b : nombre d'individus infect\u00e9s hospitalis\u00e9s \u00e0 la date t\u200b , R(t)\u200b : nombre d'individus \"retir\u00e9s\" de l'\u00e9pid\u00e9mie (gu\u00e9ris et immunis\u00e9s ou d\u00e9c\u00e9d\u00e9s) \u00e0 la date t , et les param\u00e8tres \\beta\u200b : taux de transmission par unit\u00e9 de temps (fr\u00e9quence des contacts \u200b \\times\u200b probabilit\u00e9 d'infection), \\rho\u200b : taux de \"gu\u00e9rison\" par unit\u00e9 de temps (inverse du temps moyen avant gu\u00e9rison ou d\u00e9c\u00e8s), \\alpha\u200b : taux d'hospitalisation par unit\u00e9 de temps (inverse du temps moyen avant hospitalisation), \\gamma\u200b : taux de gu\u00e9rison ou d\u00e9c\u00e8s \u00e0 l'h\u00f4pital (inverse du temps moyen avant sortie de l'h\u00f4pital). Le mod\u00e8le SIHR se traduit math\u00e9matiquement par le syst\u00e8me d'\u00e9quations diff\u00e9rentielles : \\begin{eqnarray*} \\frac{\\mathrm{d} S}{\\mathrm{d} t} &=& -\\beta \\frac{S}{N} I\\,,\\\\ \\frac{\\mathrm{d} I}{\\mathrm{d} t} &=& +\\beta \\frac{S}{N} I - (\\alpha+\\rho) I\\,,\\\\ \\frac{\\mathrm{d} H}{\\mathrm{d} t} &=& \\alpha I - \\gamma H\\,,\\\\ \\frac{\\mathrm{d} R}{\\mathrm{d} t} &=& \\rho I+ \\gamma H\\,. \\end{eqnarray*} La taille de la population est d\u00e9finie comme N= S+I+H+R=\\mbox{constante}\\,. La reproductivit\u00e9 du pathog\u00e8ne est d\u00e9fini comme \\mathcal R_0 = \\frac{\\beta}{\\alpha+\\rho}\\frac{S(t_0)}{N}\\,. C'est le nombre d'infections secondaires g\u00e9n\u00e9r\u00e9es par un individu infect\u00e9 dans la population initiale : si \\mathcal R_0>1\u200b une vague \u00e9pid\u00e9mique se forme. si \\mathcal R_0<1\u200b l'\u00e9pid\u00e9mie s'\u00e9teint progressivement. La probabilit\u00e9 d'\u00eatre hospitalis\u00e9 suite \u00e0 l'infection est p = \\frac{\\alpha}{\\alpha+\\rho}\\,. Nous allons maintenant tenter d'ajuster ce mod\u00e8le aux donn\u00e9es de COVID-19 en France sous R. Ces donn\u00e9es concernent le nombre de personnes hospitalis\u00e9es \u00e0 la date t\u200b , H(t)\u200b , ainsi que le nombre d'admissions \u00e0 l'h\u00f4pital \u00e0 la date t (par unit\u00e9 de temps) : A(t)=\\alpha I(t)\\,.","title":"Mod\u00e8le \u00e9pid\u00e9miologique"},{"location":"TD6/#modele-dobservation_1","text":"Nous consid\u00e9rerons que le nombre de nouvelles hospitalisations \u00e0 la date t est une variable al\u00e9atoire discr\u00e8te distribu\u00e9e selon une loi de Poisson de moyenne A(t)\u200b . De la m\u00eame fa\u00e7on, nous consid\u00e9rerons que le nombre de personnes hospitalis\u00e9es \u00e0 la date t \u200b est tir\u00e9 dans une loi de Poisson de moyenne \u200b H(t)\u200b . Appelons \\theta\u200b le vecteur des param\u00e8tres et conditions initiales \u00e0 estimer : \\theta=\\{\\alpha,\\beta,\\gamma,S(0),I(0),H(0)\\}\\,. Sous l'hypoth\u00e8se que les observations sont ind\u00e9pendantes conditionnellement au mod\u00e8le \u00e9pid\u00e9miologique (ce qui veut dire \"sachant la dynamique pr\u00e9dite par le mod\u00e8le th\u00e9orique\"), la vraisemblance ( likelihood ) peut s'\u00e9crire : \\mathcal{L}\\left(\\theta\\right)=\\prod_{t=0}^T \\text{Pr}(\\text{observer A admissions le jour }t| A(t))\\times\\text{Pr}(\\text{observer H hospitalisations le jour }t|H(t))\\,. Comme la fonction logarithme est monotone croissante, trouver le vecteur \\theta\u200b qui maximise \u200b \\mathcal L(\\theta) est \u00e9quivalent \u00e0 trouver le vecteur \u200b \\theta\u200b qui maximise la log-vraisemblance ( log-likelihood ) \u200b \\log\\mathcal{L}(\\theta) qui est plus commun\u00e9ment utilis\u00e9e en pratique. Nous travaillerons avec la log-vraisemblance.","title":"Mod\u00e8le d'observation"},{"location":"TD6/#traitement-des-donnees_2","text":"Importation du package n\u00e9cessaire au programme : # Importe la fonction ode qui permet de r\u00e9soudre une \u00e9quation diff\u00e9rentielle library(deSolve) Mise au propre de l\u2019espace de travail : rm(list=ls()) # Efface les variables cr\u00e9\u00e9es lors des ex\u00e9cutions pr\u00e9c\u00e9dentes graphics.off() # Ferme les fen\u00eatres ouvertes lors des ex\u00e9cutions pr\u00e9c\u00e9dentes Importation du jeu de donn\u00e9es sur les hospitalisations : # Lien permanent vers les donn\u00e9es d'hospitalisations urlhosp = url(\"https://www.data.gouv.fr/fr/datasets/r/d3a98a30-893f-47f7-96c5-2f4bcaaa0d71\") # Tableau li\u00e9 aux donn\u00e9es d'hospitalisation data = read.csv2(urlhosp, header=TRUE, sep=\",\") Cr\u00e9ation d\u2019un tableau avec seulement les donn\u00e9es du 2\u00e8me confinement : j2confifi = which(data[]==\"2020-10-30\") # Jour \u00e0 partir duquel commence 2\u00e8me confinement dernierjconfifi = which(data[]==\"2020-12-15\") # Dernier jour du 2\u00e8me confinement newtableau = data[j2confifi:dernierjconfifi,] # Tableau avec que donn\u00e9es 2\u00e8me confinement Vecteurs des donn\u00e9es d\u2019hospitalisations et d\u2019admissions \u00e0 l\u2019h\u00f4pital pendant le 2\u00e8me confinement : # Personnes admises \u00e0 l'hopital depuis le d\u00e9but du deuxi\u00e8me confinement A = c(newtableau[,10]) H = c(newtableau[,8]) # Personnes hospitalis\u00e9es depuis le d\u00e9but du deuxi\u00e8me confinement Visualisation des donn\u00e9es d\u2019hospitalisations et d\u2019admissions \u00e0 l\u2019h\u00f4pital pendant le 2\u00e8me confinement : nj = length(newtableau[,1]) plot(1:nj, A,xlab=\"Temps \u00e9coul\u00e9 depuis le 30 octobre 2020 (en jours)\", ylab=\"Nombre d'admissions \u00e0 l'hopital\", col=\"blue\") plot(1:nj, H,xlab=\"Temps \u00e9coul\u00e9 depuis le 30 octobre 2020 (en jours)\", ylab=\"Nombre de personnes hospitalis\u00e9es\",col=\"blue\")","title":"Traitement des donn\u00e9es"},{"location":"TD6/#ajustement-du-modele-aux-donnees_2","text":"Initialisation du mod\u00e8le (le 30 octobre 2020) : N = 64e6 # Taille de la population rho = 1/10 # Temps moyen avant gu\u00e9rison ou d\u00e9c\u00e8s : 10 jours gamma = 1/14 # Dur\u00e9e moyenne de l'hospitalisation : 14 jours R_0 = 1 # Nombre de reproduction de base en confinement beta = R_0*rho # Approximation du taux de transmission p = 0.1 # Probabilit\u00e9 d'\u00eatre hospitalis\u00e9 suite \u00e0 l'infection alpha = p*rho/(1-p) # Taux d'hospitalisation P0 = c(beta,alpha,gamma) # Vecteur des param\u00e8tres H0 = H[1] # Le nombre de personnes hospitalis\u00e9es au 30 octobre 2020 I0 = A[1]/alpha # Les admissions correspondent \u00e0 A(t) = alpha*I(t) R0 = (10/100)*N # Nombre de personnes immunis\u00e9es au 30 octobre (estimation grossi\u00e8re) S0 = N-I0-R0 # Nombre de personnes susceptibles d'\u00eatre infect\u00e9es S0 = N-I0-H0-R0 # La taille de la population sensible au 30 octobre X0 = c(S0,I0,H0) # Vecteur d'\u00e9tat. Pas besoin de simuler R=N-(S+I+H). Mod\u00e8le SIHR : t=0:nj SIHR = function(t, X, P){ beta = P[1] # Le taux de transmission alpha = P[2] # Le taux d'hospitalisation gamma = P[3] # Le taux de sortie d'h\u00f4pital S = X[1] I = X[2] H = X[3] # Le vecteur d'\u00e9tat X contient: S, I, et H y = beta*S*I/N # Le nombre de nouvelles infections par jour dS = -y # On exprime dS/dt = - beta*S*I dI = y-(alpha+rho)*I # On exprime dI/dt = beta*S*I - (alpha+rho)*I dH = alpha*I -gamma*H # On exprime dH/dt = alpha*I - gamma*H dX=c(dS,dI,dH) # Renvoie dX/dt tel que demand\u00e9 par la fonction ode return(list(dX)) } Fonction de log-vraisemblance : logLike=function(theta){ P = theta[1:3] # Les param\u00e8tres beta, alpha, et gamma X0 = theta[4:6] # Mise \u00e0 jour des conditions initiales X = ode(X0,t,SIHR,P) # R\u00e9solution du syst\u00e8me d'EDO (mod\u00e8le SIHR) h = X[,4] # Hospitalisation th\u00e9oriques : H(t) a = P[2]*X[,3] # Admissions th\u00e9oriques : alpha*I(t) LLH = dpois(H,h,log=T) # Probabilit\u00e9 d'observer H (loi de Poisson) LLA = dpois(A,a,log=T) # Probabilit\u00e9 d'observer A (Poisson) LL = sum(c(LLH,LLA)) # Log transforme produit des probas en somme return(LL) # Renvoie la log-vraisemblance (likelihood) } Arguments d'entr\u00e9e de la fonction de log-vraisemblance : theta0 = c(P0,X0) # Concat\u00e8ne les param\u00e8tres et conditions initiales Maximisation de la log-vraisemblance : opt = optim(theta0,logLike,control=list(fnscale=-1)) # Maximise logLike R\u00e9cup\u00e9ration des valeurs optimales des param\u00e8tres et conditions initiales du mod\u00e8le : #Les param\u00e8tres optimaux beta = opt$par[1] alpha = opt$par[2] gamma = opt$par[3] #Les conditions initiales optimales S0 = opt$par[4] I0 = opt$par[5] H0 = opt$par[6] Mise \u00e0 jour des vecteurs des conditions initiales : X0 = c(S0,I0,H0) # Vecteur des conditions initiales P0 = c(beta,alpha,gamma) # Vecteur des param\u00e8tres mis \u00e0 jour Simulation du mod\u00e8le pour les conditions initiales et param\u00e8tres estim\u00e9s : T = nj ; t0 = 1 ; t = t0:T # Mise \u00e0 jour du vecteur temps X = ode(X0,t,SIHR,P0) # Calcul de la solution optimale Comparaison visuelle de la solution du mod\u00e8le et des observations : # Affiche le nombre d\u2019individus hospitalis\u00e9s (donn\u00e9es et mod\u00e8le) plot(1:nj,H,xlab=\"Temps \u00e9coul\u00e9 depuis le 30 octobre (en jours)\", ylab=\"Nombre de personnes hospitalis\u00e9es\",col=\"blue\") lines(X[,1],X[,4]) plot(1:nj,A,xlab=\"Temps \u00e9coul\u00e9 depuis le 30 octobre (en jours)\", ylab=\"Nombre de nouvelles hospitalisations (par jour)\",col=\"red\"); lines(X[,1],alpha*X[,3])","title":"Ajustement du mod\u00e8le aux donn\u00e9es"},{"location":"TD6/#estimation-de-la-reproductivite-du-virus_2","text":"Affichage des valeurs estim\u00e9es des param\u00e8tres : R_0=beta/(alpha+rho)*S0/N # Nombre de reproduction de base estim\u00e9 print(R_0) p=alpha/(alpha+rho) # Probabilit\u00e9 d'\u00eatre hospitalis\u00e9 print(p) print(1/gamma) # Temps moyen d'hospitalisation Nous obtenons les estimations suivantes pour le deuxi\u00e8me confinement : Reproductivit\u00e9 du virus : \\mathcal R \\approx 0.81 , Probabilit\u00e9 d'\u00eatre hospitalis\u00e9 : p \\approx 0.10 , Temps moyen d'hospitalisation : 15 jours.","title":"Estimation de la reproductivit\u00e9 du virus"}]}